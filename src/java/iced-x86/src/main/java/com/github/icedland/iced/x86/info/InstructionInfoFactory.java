// SPDX-License-Identifier: MIT
// Copyright (C) 2018-present iced project and contributors

package com.github.icedland.iced.x86.info;

import com.github.icedland.iced.x86.CodeSize;
import com.github.icedland.iced.x86.Instruction;
import com.github.icedland.iced.x86.MemorySize;
import com.github.icedland.iced.x86.Register;
import com.github.icedland.iced.x86.internal.info.ImpliedAccess;

final class InstructionInfoFactory {
	static final class Flags {
		static final int NONE = 0;
		static final int NO_MEMORY_USAGE = 0x00000001;
		static final int NO_REGISTER_USAGE = 0x00000002;
		static final int IS_64_BIT = 0x00000004;
		static final int ZERO_EXT_VEC_REGS = 0x00000008;
	}

	private void addImpliedAccesses(int impliedAccess, Instruction instruction, int flags) {
		assert impliedAccess != ImpliedAccess.NONE : impliedAccess;
		switch (impliedAccess) {
		// GENERATOR-BEGIN: ImpliedAccessHandler
		// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
		case ImpliedAccess.NONE:
			break;
		case ImpliedAccess.SHIFT_IB_MASK1_FMOD9:
			break;
		case ImpliedAccess.SHIFT_IB_MASK1_FMOD11:
			break;
		case ImpliedAccess.SHIFT_IB_MASK1_F:
			break;
		case ImpliedAccess.SHIFT_IB_MASK3_F:
			break;
		case ImpliedAccess.CLEAR_RFLAGS:
			commandClearRflags(instruction, flags);
			break;
		case ImpliedAccess.T_PUSH1X2:
			commandPush(instruction, flags, 1, 2);
			break;
		case ImpliedAccess.T_PUSH1X4:
			commandPush(instruction, flags, 1, 4);
			break;
		case ImpliedAccess.T_POP1X2:
			commandPop(instruction, flags, 1, 2);
			break;
		case ImpliedAccess.T_POP1X4:
			commandPop(instruction, flags, 1, 4);
			break;
		case ImpliedAccess.T_RWAL:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.AL, OpAccess.READ_WRITE);
			}
			break;
		case ImpliedAccess.T_RWAX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.AX, OpAccess.READ_WRITE);
			}
			break;
		case ImpliedAccess.T_PUSH1X8:
			commandPush(instruction, flags, 1, 8);
			break;
		case ImpliedAccess.T_POP1X8:
			commandPop(instruction, flags, 1, 8);
			break;
		case ImpliedAccess.T_PUSHA2:
			commandPusha(instruction, flags, 2);
			break;
		case ImpliedAccess.T_PUSHA4:
			commandPusha(instruction, flags, 4);
			break;
		case ImpliedAccess.T_POPA2:
			commandPopa(instruction, flags, 2);
			break;
		case ImpliedAccess.T_POPA4:
			commandPopa(instruction, flags, 4);
			break;
		case ImpliedAccess.T_ARPL:
			commandArpl(instruction, flags);
			break;
		case ImpliedAccess.T_INS:
			commandIns(instruction, flags);
			break;
		case ImpliedAccess.T_OUTS:
			commandOuts(instruction, flags);
			break;
		case ImpliedAccess.T_LEA:
			commandLea(instruction, flags);
			break;
		case ImpliedAccess.T_GPR16:
			commandLastGpr(instruction, flags, Register.AX);
			break;
		case ImpliedAccess.T_POPRM2:
			commandPopRm(instruction, flags, 2);
			break;
		case ImpliedAccess.T_POPRM4:
			commandPopRm(instruction, flags, 4);
			break;
		case ImpliedAccess.T_POPRM8:
			commandPopRm(instruction, flags, 8);
			break;
		case ImpliedAccess.T_RAL_WAH:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.AL, OpAccess.READ);
				addRegister(flags, Register.AH, OpAccess.WRITE);
			}
			break;
		case ImpliedAccess.T_RAX_WEAX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.AX, OpAccess.READ);
				addRegister(flags, Register.EAX, OpAccess.WRITE);
			}
			break;
		case ImpliedAccess.T_RWEAX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.EAX, OpAccess.READ_WRITE);
			}
			break;
		case ImpliedAccess.T_RAX_WDX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.AX, OpAccess.READ);
				addRegister(flags, Register.DX, OpAccess.WRITE);
			}
			break;
		case ImpliedAccess.T_REAX_WEDX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.EAX, OpAccess.READ);
				addRegister(flags, Register.EDX, OpAccess.WRITE);
			}
			break;
		case ImpliedAccess.T_RRAX_WRDX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.RAX, OpAccess.READ);
				addRegister(flags, Register.RDX, OpAccess.WRITE);
			}
			break;
		case ImpliedAccess.T_PUSH2X2:
			commandPush(instruction, flags, 2, 2);
			break;
		case ImpliedAccess.T_PUSH2X4:
			commandPush(instruction, flags, 2, 4);
			break;
		case ImpliedAccess.T_RAH:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.AH, OpAccess.READ);
			}
			break;
		case ImpliedAccess.T_WAH:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.AH, OpAccess.WRITE);
			}
			break;
		case ImpliedAccess.T_MOVS:
			commandMovs(instruction, flags);
			break;
		case ImpliedAccess.T_CMPS:
			commandCmps(instruction, flags);
			break;
		case ImpliedAccess.T_STOS:
			commandStos(instruction, flags);
			break;
		case ImpliedAccess.T_LODS:
			commandLods(instruction, flags);
			break;
		case ImpliedAccess.T_SCAS:
			commandScas(instruction, flags);
			break;
		case ImpliedAccess.T_WES:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.ES, OpAccess.WRITE);
			}
			break;
		case ImpliedAccess.T_WDS:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.DS, OpAccess.WRITE);
			}
			break;
		case ImpliedAccess.T_CWEAX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.EAX, OpAccess.COND_WRITE);
			}
			break;
		case ImpliedAccess.T_ENTER2:
			commandEnter(instruction, flags, 2);
			break;
		case ImpliedAccess.T_ENTER4:
			commandEnter(instruction, flags, 4);
			break;
		case ImpliedAccess.T_ENTER8:
			commandEnter(instruction, flags, 8);
			break;
		case ImpliedAccess.T_LEAVE2:
			commandLeave(instruction, flags, 2);
			break;
		case ImpliedAccess.T_LEAVE4:
			commandLeave(instruction, flags, 4);
			break;
		case ImpliedAccess.T_LEAVE8:
			commandLeave(instruction, flags, 8);
			break;
		case ImpliedAccess.T_POP2X2:
			commandPop(instruction, flags, 2, 2);
			break;
		case ImpliedAccess.T_POP2X4:
			commandPop(instruction, flags, 2, 4);
			break;
		case ImpliedAccess.T_POP2X8:
			commandPop(instruction, flags, 2, 8);
			break;
		case ImpliedAccess.B64_T_WSS_POP5X2_F_POP3X2:
			if ((flags & Flags.IS_64_BIT) != 0) {
				if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
					addRegister(flags, Register.SS, OpAccess.WRITE);
				}
				commandPop(instruction, flags, 5, 2);
			}
			else {
				commandPop(instruction, flags, 3, 2);
			}
			break;
		case ImpliedAccess.B64_T_WSS_POP5X4_F_POP3X4:
			if ((flags & Flags.IS_64_BIT) != 0) {
				if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
					addRegister(flags, Register.SS, OpAccess.WRITE);
				}
				commandPop(instruction, flags, 5, 4);
			}
			else {
				commandPop(instruction, flags, 3, 4);
			}
			break;
		case ImpliedAccess.T_WSS_POP5X8:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.SS, OpAccess.WRITE);
			}
			commandPop(instruction, flags, 5, 8);
			break;
		case ImpliedAccess.T_RAL_WAX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.AL, OpAccess.READ);
				addRegister(flags, Register.AX, OpAccess.WRITE);
			}
			break;
		case ImpliedAccess.T_WAL:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.AL, OpAccess.WRITE);
			}
			break;
		case ImpliedAccess.T_RWST0:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.ST0, OpAccess.READ_WRITE);
			}
			break;
		case ImpliedAccess.T_RST0:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.ST0, OpAccess.READ);
			}
			break;
		case ImpliedAccess.T_RST0_RWST1:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.ST0, OpAccess.READ);
				addRegister(flags, Register.ST1, OpAccess.READ_WRITE);
			}
			break;
		case ImpliedAccess.T_RCWST0:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.ST0, OpAccess.READ_COND_WRITE);
			}
			break;
		case ImpliedAccess.T_RST1_RWST0:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.ST1, OpAccess.READ);
				addRegister(flags, Register.ST0, OpAccess.READ_WRITE);
			}
			break;
		case ImpliedAccess.T_RST0_RST1:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.ST0, OpAccess.READ);
				addRegister(flags, Register.ST1, OpAccess.READ);
			}
			break;
		case ImpliedAccess.T_WST0_TOST7_WMM0_TOMM7:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				for (int reg = Register.ST0; reg <= Register.ST7; reg++)
					addRegister(flags, reg, OpAccess.WRITE);
				for (int reg = Register.MM0; reg <= Register.MM7; reg++)
					addRegister(flags, reg, OpAccess.WRITE);
			}
			break;
		case ImpliedAccess.T_RST0_TOST7_RMM0_TOMM7:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				for (int reg = Register.ST0; reg <= Register.ST7; reg++)
					addRegister(flags, reg, OpAccess.READ);
				for (int reg = Register.MM0; reg <= Register.MM7; reg++)
					addRegister(flags, reg, OpAccess.READ);
			}
			break;
		case ImpliedAccess.T_RWCX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.CX, OpAccess.READ_WRITE);
			}
			break;
		case ImpliedAccess.T_RWECX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.ECX, OpAccess.READ_WRITE);
			}
			break;
		case ImpliedAccess.T_RWRCX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.RCX, OpAccess.READ_WRITE);
			}
			break;
		case ImpliedAccess.T_RCX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.CX, OpAccess.READ);
			}
			break;
		case ImpliedAccess.T_RECX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.ECX, OpAccess.READ);
			}
			break;
		case ImpliedAccess.T_RRCX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.RCX, OpAccess.READ);
			}
			break;
		case ImpliedAccess.T_WDX_RWAX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.DX, OpAccess.WRITE);
				addRegister(flags, Register.AX, OpAccess.READ_WRITE);
			}
			break;
		case ImpliedAccess.T_WEDX_RWEAX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.EDX, OpAccess.WRITE);
				addRegister(flags, Register.EAX, OpAccess.READ_WRITE);
			}
			break;
		case ImpliedAccess.T_WRDX_RWRAX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.RDX, OpAccess.WRITE);
				addRegister(flags, Register.RAX, OpAccess.READ_WRITE);
			}
			break;
		case ImpliedAccess.T_RWAX_RWDX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.AX, OpAccess.READ_WRITE);
				addRegister(flags, Register.DX, OpAccess.READ_WRITE);
			}
			break;
		case ImpliedAccess.T_RWEAX_RWEDX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.EAX, OpAccess.READ_WRITE);
				addRegister(flags, Register.EDX, OpAccess.READ_WRITE);
			}
			break;
		case ImpliedAccess.T_RWRAX_RWRDX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.RAX, OpAccess.READ_WRITE);
				addRegister(flags, Register.RDX, OpAccess.READ_WRITE);
			}
			break;
		case ImpliedAccess.T_PUSH2X8:
			commandPush(instruction, flags, 2, 8);
			break;
		case ImpliedAccess.T_RCR0:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.CR0, OpAccess.READ);
			}
			break;
		case ImpliedAccess.T_RWCR0:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.CR0, OpAccess.READ_WRITE);
			}
			break;
		case ImpliedAccess.T_GPR16_RWCR0:
			commandLastGpr(instruction, flags, Register.AX);
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.CR0, OpAccess.READ_WRITE);
			}
			break;
		case ImpliedAccess.T_RCWEAX_B64_T_CRRCX_CRRDX_CRRBX_CWRCX_CWRDX_CWRBX_F_CRECX_CREDX_CREBX_CRDS_CWECX_CWEDX_CWEBX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.EAX, OpAccess.READ_COND_WRITE);
			}
			if ((flags & Flags.IS_64_BIT) != 0) {
				if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
					addRegister(flags, Register.RCX, OpAccess.COND_READ);
					addRegister(flags, Register.RDX, OpAccess.COND_READ);
					addRegister(flags, Register.RBX, OpAccess.COND_READ);
					addRegister(flags, Register.RCX, OpAccess.COND_WRITE);
					addRegister(flags, Register.RDX, OpAccess.COND_WRITE);
					addRegister(flags, Register.RBX, OpAccess.COND_WRITE);
				}
			}
			else {
				if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
					addRegister(flags, Register.ECX, OpAccess.COND_READ);
					addRegister(flags, Register.EDX, OpAccess.COND_READ);
					addRegister(flags, Register.EBX, OpAccess.COND_READ);
					addRegister(flags, Register.DS, OpAccess.COND_READ);
					addRegister(flags, Register.ECX, OpAccess.COND_WRITE);
					addRegister(flags, Register.EDX, OpAccess.COND_WRITE);
					addRegister(flags, Register.EBX, OpAccess.COND_WRITE);
				}
			}
			break;
		case ImpliedAccess.T_CWECX_CWEDX_CWEBX_RWEAX_B64_T_CRRCX_CRRDX_CRRBX_F_CRECX_CREDX_CREBX_CRDS:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.ECX, OpAccess.COND_WRITE);
				addRegister(flags, Register.EDX, OpAccess.COND_WRITE);
				addRegister(flags, Register.EBX, OpAccess.COND_WRITE);
				addRegister(flags, Register.EAX, OpAccess.READ_WRITE);
			}
			if ((flags & Flags.IS_64_BIT) != 0) {
				if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
					addRegister(flags, Register.RCX, OpAccess.COND_READ);
					addRegister(flags, Register.RDX, OpAccess.COND_READ);
					addRegister(flags, Register.RBX, OpAccess.COND_READ);
				}
			}
			else {
				if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
					addRegister(flags, Register.ECX, OpAccess.COND_READ);
					addRegister(flags, Register.EDX, OpAccess.COND_READ);
					addRegister(flags, Register.EBX, OpAccess.COND_READ);
					addRegister(flags, Register.DS, OpAccess.COND_READ);
				}
			}
			break;
		case ImpliedAccess.T_RAX_RECX_REDX_RSEG:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.AX, OpAccess.READ);
				addRegister(flags, Register.ECX, OpAccess.READ);
				addRegister(flags, Register.EDX, OpAccess.READ);
				addMemorySegmentRegister(flags, getSegDefaultDS(instruction), OpAccess.READ);
			}
			break;
		case ImpliedAccess.T_REAX_RECX_REDX_RSEG:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.EAX, OpAccess.READ);
				addRegister(flags, Register.ECX, OpAccess.READ);
				addRegister(flags, Register.EDX, OpAccess.READ);
				addMemorySegmentRegister(flags, getSegDefaultDS(instruction), OpAccess.READ);
			}
			break;
		case ImpliedAccess.T_RECX_REDX_RRAX_RSEG:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.ECX, OpAccess.READ);
				addRegister(flags, Register.EDX, OpAccess.READ);
				addRegister(flags, Register.RAX, OpAccess.READ);
				addMemorySegmentRegister(flags, getSegDefaultDS(instruction), OpAccess.READ);
			}
			break;
		case ImpliedAccess.T_REAX_RECX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.EAX, OpAccess.READ);
				addRegister(flags, Register.ECX, OpAccess.READ);
			}
			break;
		case ImpliedAccess.T_RECX_WEAX_WEDX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.ECX, OpAccess.READ);
				addRegister(flags, Register.EAX, OpAccess.WRITE);
				addRegister(flags, Register.EDX, OpAccess.WRITE);
			}
			break;
		case ImpliedAccess.T_REAX_RECX_REDX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.EAX, OpAccess.READ);
				addRegister(flags, Register.ECX, OpAccess.READ);
				addRegister(flags, Register.EDX, OpAccess.READ);
			}
			break;
		case ImpliedAccess.T_RAX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.AX, OpAccess.READ);
			}
			break;
		case ImpliedAccess.T_REAX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.EAX, OpAccess.READ);
			}
			break;
		case ImpliedAccess.T_RRAX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.RAX, OpAccess.READ);
			}
			break;
		case ImpliedAccess.T_RAX_WFS_WGS:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.AX, OpAccess.READ);
				addRegister(flags, Register.FS, OpAccess.WRITE);
				addRegister(flags, Register.GS, OpAccess.WRITE);
			}
			break;
		case ImpliedAccess.T_REAX_WFS_WGS:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.EAX, OpAccess.READ);
				addRegister(flags, Register.FS, OpAccess.WRITE);
				addRegister(flags, Register.GS, OpAccess.WRITE);
			}
			break;
		case ImpliedAccess.T_RRAX_WFS_WGS:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.RAX, OpAccess.READ);
				addRegister(flags, Register.FS, OpAccess.WRITE);
				addRegister(flags, Register.GS, OpAccess.WRITE);
			}
			break;
		case ImpliedAccess.T_RAX_RFS_RGS:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.AX, OpAccess.READ);
				addRegister(flags, Register.FS, OpAccess.READ);
				addRegister(flags, Register.GS, OpAccess.READ);
			}
			break;
		case ImpliedAccess.T_REAX_RFS_RGS:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.EAX, OpAccess.READ);
				addRegister(flags, Register.FS, OpAccess.READ);
				addRegister(flags, Register.GS, OpAccess.READ);
			}
			break;
		case ImpliedAccess.T_RRAX_RFS_RGS:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.RAX, OpAccess.READ);
				addRegister(flags, Register.FS, OpAccess.READ);
				addRegister(flags, Register.GS, OpAccess.READ);
			}
			break;
		case ImpliedAccess.T_REAX_WCR0_WDR6_WDR7_WES_TOGS_WCR2_TOCR4_WDR0_TODR3_B64_T_WRAX_TOR15_F_WEAX_TOEDI:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.EAX, OpAccess.READ);
				addRegister(flags, Register.CR0, OpAccess.WRITE);
				addRegister(flags, Register.DR6, OpAccess.WRITE);
				addRegister(flags, Register.DR7, OpAccess.WRITE);
				for (int reg = Register.ES; reg <= Register.GS; reg++)
					addRegister(flags, reg, OpAccess.WRITE);
				for (int reg = Register.CR2; reg <= Register.CR4; reg++)
					addRegister(flags, reg, OpAccess.WRITE);
				for (int reg = Register.DR0; reg <= Register.DR3; reg++)
					addRegister(flags, reg, OpAccess.WRITE);
			}
			if ((flags & Flags.IS_64_BIT) != 0) {
				if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
					for (int reg = Register.RAX; reg <= Register.R15; reg++)
						addRegister(flags, reg, OpAccess.WRITE);
				}
			}
			else {
				if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
					for (int reg = Register.EAX; reg <= Register.EDI; reg++)
						addRegister(flags, reg, OpAccess.WRITE);
				}
			}
			break;
		case ImpliedAccess.T_RAX_RECX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.AX, OpAccess.READ);
				addRegister(flags, Register.ECX, OpAccess.READ);
			}
			break;
		case ImpliedAccess.T_RECX_RRAX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.ECX, OpAccess.READ);
				addRegister(flags, Register.RAX, OpAccess.READ);
			}
			break;
		case ImpliedAccess.T_WEAX_WECX_WEDX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.EAX, OpAccess.WRITE);
				addRegister(flags, Register.ECX, OpAccess.WRITE);
				addRegister(flags, Register.EDX, OpAccess.WRITE);
			}
			break;
		case ImpliedAccess.T_REAX_RECX_CREBX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.EAX, OpAccess.READ);
				addRegister(flags, Register.ECX, OpAccess.READ);
				addRegister(flags, Register.EBX, OpAccess.COND_READ);
			}
			break;
		case ImpliedAccess.T_RAX_RSEG:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.AX, OpAccess.READ);
				addMemorySegmentRegister(flags, getSegDefaultDS(instruction), OpAccess.READ);
			}
			break;
		case ImpliedAccess.T_REAX_RSEG:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.EAX, OpAccess.READ);
				addMemorySegmentRegister(flags, getSegDefaultDS(instruction), OpAccess.READ);
			}
			break;
		case ImpliedAccess.T_RRAX_RSEG:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.RAX, OpAccess.READ);
				addMemorySegmentRegister(flags, getSegDefaultDS(instruction), OpAccess.READ);
			}
			break;
		case ImpliedAccess.T_WECX_B64_T_WR11:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.ECX, OpAccess.WRITE);
			}
			if ((flags & Flags.IS_64_BIT) != 0) {
				if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
					addRegister(flags, Register.R11, OpAccess.WRITE);
				}
			}
			break;
		case ImpliedAccess.T_REDI_RES:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.EDI, OpAccess.READ);
				addRegister(flags, Register.ES, OpAccess.READ);
			}
			break;
		case ImpliedAccess.T_RECX_WCS_WSS_B64_T_RR11D:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.ECX, OpAccess.READ);
				addRegister(flags, Register.CS, OpAccess.WRITE);
				addRegister(flags, Register.SS, OpAccess.WRITE);
			}
			if ((flags & Flags.IS_64_BIT) != 0) {
				if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
					addRegister(flags, Register.R11D, OpAccess.READ);
				}
			}
			break;
		case ImpliedAccess.T_RR11D_RRCX_WCS_WSS:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.R11D, OpAccess.READ);
				addRegister(flags, Register.RCX, OpAccess.READ);
				addRegister(flags, Register.CS, OpAccess.WRITE);
				addRegister(flags, Register.SS, OpAccess.WRITE);
			}
			break;
		case ImpliedAccess.T_WEAX_WEDX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.EAX, OpAccess.WRITE);
				addRegister(flags, Register.EDX, OpAccess.WRITE);
			}
			break;
		case ImpliedAccess.T_WESP:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.ESP, OpAccess.WRITE);
			}
			break;
		case ImpliedAccess.T_RECX_REDX_WESP_WCS_WSS:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.ECX, OpAccess.READ);
				addRegister(flags, Register.EDX, OpAccess.READ);
				addRegister(flags, Register.ESP, OpAccess.WRITE);
				addRegister(flags, Register.CS, OpAccess.WRITE);
				addRegister(flags, Register.SS, OpAccess.WRITE);
			}
			break;
		case ImpliedAccess.T_RRCX_RRDX_WRSP_WCS_WSS:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.RCX, OpAccess.READ);
				addRegister(flags, Register.RDX, OpAccess.READ);
				addRegister(flags, Register.RSP, OpAccess.WRITE);
				addRegister(flags, Register.CS, OpAccess.WRITE);
				addRegister(flags, Register.SS, OpAccess.WRITE);
			}
			break;
		case ImpliedAccess.T_ZRRM:
			commandClearRegRegmem(instruction, flags);
			break;
		case ImpliedAccess.T_ZRRRM:
			commandClearRegRegRegmem(instruction, flags);
			break;
		case ImpliedAccess.B64_T_RWXMM0_TOXMM15_F_RWXMM0_TOXMM7:
			if ((flags & Flags.IS_64_BIT) != 0) {
				if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
					for (int reg = Register.XMM0; reg <= Register.XMM15; reg++)
						addRegister(flags, reg, OpAccess.READ_WRITE);
				}
			}
			else {
				if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
					for (int reg = Register.XMM0; reg <= Register.XMM7; reg++)
						addRegister(flags, reg, OpAccess.READ_WRITE);
				}
			}
			break;
		case ImpliedAccess.B64_T_WZMM0_TOZMM15_F_WZMM0_TOZMM7:
			if ((flags & Flags.IS_64_BIT) != 0) {
				if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
					for (int reg = Register.ZMM0; reg <= Register.ZMM15; reg++)
						addRegister(flags, reg, OpAccess.WRITE);
				}
			}
			else {
				if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
					for (int reg = Register.ZMM0; reg <= Register.ZMM7; reg++)
						addRegister(flags, reg, OpAccess.WRITE);
				}
			}
			break;
		case ImpliedAccess.T_CRECX_WECX_WEDX_WEBX_RWEAX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.ECX, OpAccess.COND_READ);
				addRegister(flags, Register.ECX, OpAccess.WRITE);
				addRegister(flags, Register.EDX, OpAccess.WRITE);
				addRegister(flags, Register.EBX, OpAccess.WRITE);
				addRegister(flags, Register.EAX, OpAccess.READ_WRITE);
			}
			break;
		case ImpliedAccess.T_CRMEM_CRSI_CREAX_CRES_CWEAX_CWEDX_RCWECX:
			if ((flags & Flags.NO_MEMORY_USAGE) == 0) {
				addMemory(Register.ES, Register.SI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE16, 0);
			}
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.SI, OpAccess.COND_READ);
				addRegister(flags, Register.EAX, OpAccess.COND_READ);
				if ((flags & Flags.IS_64_BIT) == 0)
					addRegister(flags, Register.ES, OpAccess.COND_READ);
				addRegister(flags, Register.EAX, OpAccess.COND_WRITE);
				addRegister(flags, Register.EDX, OpAccess.COND_WRITE);
				addRegister(flags, Register.ECX, OpAccess.READ_COND_WRITE);
			}
			break;
		case ImpliedAccess.T_CRMEM_CREAX_CRESI_CRES_CWEAX_CWEDX_RCWECX:
			if ((flags & Flags.NO_MEMORY_USAGE) == 0) {
				addMemory(Register.ES, Register.ESI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE32, 0);
			}
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.EAX, OpAccess.COND_READ);
				addRegister(flags, Register.ESI, OpAccess.COND_READ);
				if ((flags & Flags.IS_64_BIT) == 0)
					addRegister(flags, Register.ES, OpAccess.COND_READ);
				addRegister(flags, Register.EAX, OpAccess.COND_WRITE);
				addRegister(flags, Register.EDX, OpAccess.COND_WRITE);
				addRegister(flags, Register.ECX, OpAccess.READ_COND_WRITE);
			}
			break;
		case ImpliedAccess.T_CRMEM_CREAX_CRRSI_CRES_CWEAX_CWEDX_RCWRCX:
			if ((flags & Flags.NO_MEMORY_USAGE) == 0) {
				addMemory(Register.ES, Register.RSI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE64, 0);
			}
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.EAX, OpAccess.COND_READ);
				addRegister(flags, Register.RSI, OpAccess.COND_READ);
				if ((flags & Flags.IS_64_BIT) == 0)
					addRegister(flags, Register.ES, OpAccess.COND_READ);
				addRegister(flags, Register.EAX, OpAccess.COND_WRITE);
				addRegister(flags, Register.EDX, OpAccess.COND_WRITE);
				addRegister(flags, Register.RCX, OpAccess.READ_COND_WRITE);
			}
			break;
		case ImpliedAccess.T_CRMEM_CRMEM_CWMEM_CRSI_CRDI_CRES_CWSI_RCWAX_RCWCX:
			if ((flags & Flags.NO_MEMORY_USAGE) == 0) {
				addMemory(Register.ES, Register.SI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE16, 0);
				addMemory(Register.ES, Register.DI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE16, 0);
				addMemory(Register.ES, Register.DI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_WRITE, CodeSize.CODE16, 0);
			}
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.SI, OpAccess.COND_READ);
				addRegister(flags, Register.DI, OpAccess.COND_READ);
				if ((flags & Flags.IS_64_BIT) == 0)
					addRegister(flags, Register.ES, OpAccess.COND_READ);
				addRegister(flags, Register.SI, OpAccess.COND_WRITE);
				addRegister(flags, Register.AX, OpAccess.READ_COND_WRITE);
				addRegister(flags, Register.CX, OpAccess.READ_COND_WRITE);
			}
			break;
		case ImpliedAccess.T_CRMEM_CRMEM_CWMEM_CRESI_CREDI_CRES_CWESI_RCWEAX_RCWECX:
			if ((flags & Flags.NO_MEMORY_USAGE) == 0) {
				addMemory(Register.ES, Register.ESI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE32, 0);
				addMemory(Register.ES, Register.EDI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE32, 0);
				addMemory(Register.ES, Register.EDI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_WRITE, CodeSize.CODE32, 0);
			}
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.ESI, OpAccess.COND_READ);
				addRegister(flags, Register.EDI, OpAccess.COND_READ);
				if ((flags & Flags.IS_64_BIT) == 0)
					addRegister(flags, Register.ES, OpAccess.COND_READ);
				addRegister(flags, Register.ESI, OpAccess.COND_WRITE);
				addRegister(flags, Register.EAX, OpAccess.READ_COND_WRITE);
				addRegister(flags, Register.ECX, OpAccess.READ_COND_WRITE);
			}
			break;
		case ImpliedAccess.T_CRMEM_CRMEM_CWMEM_CRRSI_CRRDI_CRES_CWRSI_RCWRAX_RCWRCX:
			if ((flags & Flags.NO_MEMORY_USAGE) == 0) {
				addMemory(Register.ES, Register.RSI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE64, 0);
				addMemory(Register.ES, Register.RDI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE64, 0);
				addMemory(Register.ES, Register.RDI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_WRITE, CodeSize.CODE64, 0);
			}
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.RSI, OpAccess.COND_READ);
				addRegister(flags, Register.RDI, OpAccess.COND_READ);
				if ((flags & Flags.IS_64_BIT) == 0)
					addRegister(flags, Register.ES, OpAccess.COND_READ);
				addRegister(flags, Register.RSI, OpAccess.COND_WRITE);
				addRegister(flags, Register.RAX, OpAccess.READ_COND_WRITE);
				addRegister(flags, Register.RCX, OpAccess.READ_COND_WRITE);
			}
			break;
		case ImpliedAccess.T_RCL_RAX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.CL, OpAccess.READ);
				addRegister(flags, Register.AX, OpAccess.READ);
			}
			break;
		case ImpliedAccess.T_RCL_REAX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.CL, OpAccess.READ);
				addRegister(flags, Register.EAX, OpAccess.READ);
			}
			break;
		case ImpliedAccess.T_XSTORE2:
			commandXstore(instruction, flags, 2);
			break;
		case ImpliedAccess.T_XSTORE4:
			commandXstore(instruction, flags, 4);
			break;
		case ImpliedAccess.T_XSTORE8:
			commandXstore(instruction, flags, 8);
			break;
		case ImpliedAccess.T_CRMEM_CRMEM_CRMEM_CWMEM_CRDX_CRBX_CRSI_CRDI_CRES_CWSI_CWDI_RCWCX:
			if ((flags & Flags.NO_MEMORY_USAGE) == 0) {
				addMemory(Register.ES, Register.DX, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE16, 0);
				addMemory(Register.ES, Register.BX, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE16, 0);
				addMemory(Register.ES, Register.SI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE16, 0);
				addMemory(Register.ES, Register.DI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_WRITE, CodeSize.CODE16, 0);
			}
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.DX, OpAccess.COND_READ);
				addRegister(flags, Register.BX, OpAccess.COND_READ);
				addRegister(flags, Register.SI, OpAccess.COND_READ);
				addRegister(flags, Register.DI, OpAccess.COND_READ);
				if ((flags & Flags.IS_64_BIT) == 0)
					addRegister(flags, Register.ES, OpAccess.COND_READ);
				addRegister(flags, Register.SI, OpAccess.COND_WRITE);
				addRegister(flags, Register.DI, OpAccess.COND_WRITE);
				addRegister(flags, Register.CX, OpAccess.READ_COND_WRITE);
			}
			break;
		case ImpliedAccess.T_CRMEM_CRMEM_CRMEM_CWMEM_CREDX_CREBX_CRESI_CREDI_CRES_CWESI_CWEDI_RCWECX:
			if ((flags & Flags.NO_MEMORY_USAGE) == 0) {
				addMemory(Register.ES, Register.EDX, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE32, 0);
				addMemory(Register.ES, Register.EBX, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE32, 0);
				addMemory(Register.ES, Register.ESI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE32, 0);
				addMemory(Register.ES, Register.EDI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_WRITE, CodeSize.CODE32, 0);
			}
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.EDX, OpAccess.COND_READ);
				addRegister(flags, Register.EBX, OpAccess.COND_READ);
				addRegister(flags, Register.ESI, OpAccess.COND_READ);
				addRegister(flags, Register.EDI, OpAccess.COND_READ);
				if ((flags & Flags.IS_64_BIT) == 0)
					addRegister(flags, Register.ES, OpAccess.COND_READ);
				addRegister(flags, Register.ESI, OpAccess.COND_WRITE);
				addRegister(flags, Register.EDI, OpAccess.COND_WRITE);
				addRegister(flags, Register.ECX, OpAccess.READ_COND_WRITE);
			}
			break;
		case ImpliedAccess.T_CRMEM_CRMEM_CRMEM_CWMEM_CRRDX_CRRBX_CRRSI_CRRDI_CRES_CWRSI_CWRDI_RCWRCX:
			if ((flags & Flags.NO_MEMORY_USAGE) == 0) {
				addMemory(Register.ES, Register.RDX, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE64, 0);
				addMemory(Register.ES, Register.RBX, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE64, 0);
				addMemory(Register.ES, Register.RSI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE64, 0);
				addMemory(Register.ES, Register.RDI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_WRITE, CodeSize.CODE64, 0);
			}
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.RDX, OpAccess.COND_READ);
				addRegister(flags, Register.RBX, OpAccess.COND_READ);
				addRegister(flags, Register.RSI, OpAccess.COND_READ);
				addRegister(flags, Register.RDI, OpAccess.COND_READ);
				if ((flags & Flags.IS_64_BIT) == 0)
					addRegister(flags, Register.ES, OpAccess.COND_READ);
				addRegister(flags, Register.RSI, OpAccess.COND_WRITE);
				addRegister(flags, Register.RDI, OpAccess.COND_WRITE);
				addRegister(flags, Register.RCX, OpAccess.READ_COND_WRITE);
			}
			break;
		case ImpliedAccess.T_CRMEM_CRMEM_CRMEM_CRMEM_CWMEM_CWMEM_CRAX_CRDX_CRBX_CRSI_CRDI_CRES_CWSI_CWDI_RCWCX:
			if ((flags & Flags.NO_MEMORY_USAGE) == 0) {
				addMemory(Register.ES, Register.AX, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE16, 0);
				addMemory(Register.ES, Register.DX, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE16, 0);
				addMemory(Register.ES, Register.BX, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE16, 0);
				addMemory(Register.ES, Register.SI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE16, 0);
				addMemory(Register.ES, Register.AX, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_WRITE, CodeSize.CODE16, 0);
				addMemory(Register.ES, Register.DI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_WRITE, CodeSize.CODE16, 0);
			}
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.AX, OpAccess.COND_READ);
				addRegister(flags, Register.DX, OpAccess.COND_READ);
				addRegister(flags, Register.BX, OpAccess.COND_READ);
				addRegister(flags, Register.SI, OpAccess.COND_READ);
				addRegister(flags, Register.DI, OpAccess.COND_READ);
				if ((flags & Flags.IS_64_BIT) == 0)
					addRegister(flags, Register.ES, OpAccess.COND_READ);
				addRegister(flags, Register.SI, OpAccess.COND_WRITE);
				addRegister(flags, Register.DI, OpAccess.COND_WRITE);
				addRegister(flags, Register.CX, OpAccess.READ_COND_WRITE);
			}
			break;
		case ImpliedAccess.T_CRMEM_CRMEM_CRMEM_CRMEM_CWMEM_CWMEM_CREAX_CREDX_CREBX_CRESI_CREDI_CRES_CWESI_CWEDI_RCWECX:
			if ((flags & Flags.NO_MEMORY_USAGE) == 0) {
				addMemory(Register.ES, Register.EAX, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE32, 0);
				addMemory(Register.ES, Register.EDX, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE32, 0);
				addMemory(Register.ES, Register.EBX, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE32, 0);
				addMemory(Register.ES, Register.ESI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE32, 0);
				addMemory(Register.ES, Register.EAX, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_WRITE, CodeSize.CODE32, 0);
				addMemory(Register.ES, Register.EDI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_WRITE, CodeSize.CODE32, 0);
			}
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.EAX, OpAccess.COND_READ);
				addRegister(flags, Register.EDX, OpAccess.COND_READ);
				addRegister(flags, Register.EBX, OpAccess.COND_READ);
				addRegister(flags, Register.ESI, OpAccess.COND_READ);
				addRegister(flags, Register.EDI, OpAccess.COND_READ);
				if ((flags & Flags.IS_64_BIT) == 0)
					addRegister(flags, Register.ES, OpAccess.COND_READ);
				addRegister(flags, Register.ESI, OpAccess.COND_WRITE);
				addRegister(flags, Register.EDI, OpAccess.COND_WRITE);
				addRegister(flags, Register.ECX, OpAccess.READ_COND_WRITE);
			}
			break;
		case ImpliedAccess.T_CRMEM_CRMEM_CRMEM_CRMEM_CWMEM_CWMEM_CRRAX_CRRDX_CRRBX_CRRSI_CRRDI_CRES_CWRSI_CWRDI_RCWRCX:
			if ((flags & Flags.NO_MEMORY_USAGE) == 0) {
				addMemory(Register.ES, Register.RAX, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE64, 0);
				addMemory(Register.ES, Register.RDX, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE64, 0);
				addMemory(Register.ES, Register.RBX, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE64, 0);
				addMemory(Register.ES, Register.RSI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE64, 0);
				addMemory(Register.ES, Register.RAX, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_WRITE, CodeSize.CODE64, 0);
				addMemory(Register.ES, Register.RDI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_WRITE, CodeSize.CODE64, 0);
			}
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.RAX, OpAccess.COND_READ);
				addRegister(flags, Register.RDX, OpAccess.COND_READ);
				addRegister(flags, Register.RBX, OpAccess.COND_READ);
				addRegister(flags, Register.RSI, OpAccess.COND_READ);
				addRegister(flags, Register.RDI, OpAccess.COND_READ);
				if ((flags & Flags.IS_64_BIT) == 0)
					addRegister(flags, Register.ES, OpAccess.COND_READ);
				addRegister(flags, Register.RSI, OpAccess.COND_WRITE);
				addRegister(flags, Register.RDI, OpAccess.COND_WRITE);
				addRegister(flags, Register.RCX, OpAccess.READ_COND_WRITE);
			}
			break;
		case ImpliedAccess.T_RCWAL:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.AL, OpAccess.READ_COND_WRITE);
			}
			break;
		case ImpliedAccess.T_RCWAX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.AX, OpAccess.READ_COND_WRITE);
			}
			break;
		case ImpliedAccess.T_RCWEAX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.EAX, OpAccess.READ_COND_WRITE);
			}
			break;
		case ImpliedAccess.T_REAX_REDX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.EAX, OpAccess.READ);
				addRegister(flags, Register.EDX, OpAccess.READ);
			}
			break;
		case ImpliedAccess.T_GPR8:
			commandLastGpr(instruction, flags, Register.AL);
			break;
		case ImpliedAccess.T_GPR32_REAX_REDX:
			commandLastGpr(instruction, flags, Register.EAX);
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.EAX, OpAccess.READ);
				addRegister(flags, Register.EDX, OpAccess.READ);
			}
			break;
		case ImpliedAccess.T_RMEM_RSEG:
			if ((flags & Flags.NO_MEMORY_USAGE) == 0) {
				addMemory(getSegDefaultDS(instruction), instruction.getOp0Register(), Register.NONE, 1, 0x0, MemorySize.UINT8, OpAccess.READ, CodeSize.UNKNOWN, 0);
			}
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addMemorySegmentRegister(flags, getSegDefaultDS(instruction), OpAccess.READ);
			}
			break;
		case ImpliedAccess.T_RCWRAX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.RAX, OpAccess.READ_COND_WRITE);
			}
			break;
		case ImpliedAccess.T_WSS:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.SS, OpAccess.WRITE);
			}
			break;
		case ImpliedAccess.T_WFS:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.FS, OpAccess.WRITE);
			}
			break;
		case ImpliedAccess.T_WGS:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.GS, OpAccess.WRITE);
			}
			break;
		case ImpliedAccess.T_CRECX_CREBX_RCWEAX_RCWEDX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.ECX, OpAccess.COND_READ);
				addRegister(flags, Register.EBX, OpAccess.COND_READ);
				addRegister(flags, Register.EAX, OpAccess.READ_COND_WRITE);
				addRegister(flags, Register.EDX, OpAccess.READ_COND_WRITE);
			}
			break;
		case ImpliedAccess.T_CRRCX_CRRBX_RCWRAX_RCWRDX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.RCX, OpAccess.COND_READ);
				addRegister(flags, Register.RBX, OpAccess.COND_READ);
				addRegister(flags, Register.RAX, OpAccess.READ_COND_WRITE);
				addRegister(flags, Register.RDX, OpAccess.READ_COND_WRITE);
			}
			break;
		case ImpliedAccess.T_WMEM_RAR_DI_RSEG:
			if ((flags & Flags.NO_MEMORY_USAGE) == 0) {
				addMemory(getSegDefaultDS(instruction), getARDI(instruction), Register.NONE, 1, 0x0, instruction.getMemorySize(), OpAccess.WRITE, CodeSize.UNKNOWN, 0);
			}
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, getARDI(instruction), OpAccess.READ);
				addMemorySegmentRegister(flags, getSegDefaultDS(instruction), OpAccess.READ);
			}
			break;
		case ImpliedAccess.T_RXMM0:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.XMM0, OpAccess.READ);
			}
			break;
		case ImpliedAccess.T_REDX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.EDX, OpAccess.READ);
			}
			break;
		case ImpliedAccess.T_RRDX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.RDX, OpAccess.READ);
			}
			break;
		case ImpliedAccess.T_WMEM_RES:
			if ((flags & Flags.NO_MEMORY_USAGE) == 0) {
				addMemory(Register.ES, instruction.getOp0Register(), Register.NONE, 1, 0x0, instruction.getMemorySize(), OpAccess.WRITE, CodeSize.UNKNOWN, 0);
			}
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				if ((flags & Flags.IS_64_BIT) == 0)
					addRegister(flags, Register.ES, OpAccess.READ);
			}
			break;
		case ImpliedAccess.T_REAX_REDX_WXMM0:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.EAX, OpAccess.READ);
				addRegister(flags, Register.EDX, OpAccess.READ);
				addRegister(flags, Register.XMM0, OpAccess.WRITE);
			}
			break;
		case ImpliedAccess.T_RRAX_RRDX_WXMM0:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.RAX, OpAccess.READ);
				addRegister(flags, Register.RDX, OpAccess.READ);
				addRegister(flags, Register.XMM0, OpAccess.WRITE);
			}
			break;
		case ImpliedAccess.T_REAX_REDX_WECX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.EAX, OpAccess.READ);
				addRegister(flags, Register.EDX, OpAccess.READ);
				addRegister(flags, Register.ECX, OpAccess.WRITE);
			}
			break;
		case ImpliedAccess.T_RRAX_RRDX_WECX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.RAX, OpAccess.READ);
				addRegister(flags, Register.RDX, OpAccess.READ);
				addRegister(flags, Register.ECX, OpAccess.WRITE);
			}
			break;
		case ImpliedAccess.T_WXMM0:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.XMM0, OpAccess.WRITE);
			}
			break;
		case ImpliedAccess.T_WECX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.ECX, OpAccess.WRITE);
			}
			break;
		case ImpliedAccess.T_RMEM_RDS:
			if ((flags & Flags.NO_MEMORY_USAGE) == 0) {
				addMemory(Register.DS, instruction.getOp0Register(), Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.READ, CodeSize.UNKNOWN, 0);
			}
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				if ((flags & Flags.IS_64_BIT) == 0)
					addRegister(flags, Register.DS, OpAccess.READ);
			}
			break;
		case ImpliedAccess.T_RRCX_RRDX_RWRAX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.RCX, OpAccess.READ);
				addRegister(flags, Register.RDX, OpAccess.READ);
				addRegister(flags, Register.RAX, OpAccess.READ_WRITE);
			}
			break;
		case ImpliedAccess.T_RMEM_RRCX_RSEG_RWRAX:
			if ((flags & Flags.NO_MEMORY_USAGE) == 0) {
				addMemory(getSegDefaultDS(instruction), Register.RCX, Register.NONE, 1, 0x0, MemorySize.UINT128, OpAccess.READ, CodeSize.CODE64, 0);
			}
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.RCX, OpAccess.READ);
				addMemorySegmentRegister(flags, getSegDefaultDS(instruction), OpAccess.READ);
				addRegister(flags, Register.RAX, OpAccess.READ_WRITE);
			}
			break;
		case ImpliedAccess.T_RWRAX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.RAX, OpAccess.READ_WRITE);
			}
			break;
		case ImpliedAccess.T_RAX_RECX_REDX_WEAX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.AX, OpAccess.READ);
				addRegister(flags, Register.ECX, OpAccess.READ);
				addRegister(flags, Register.EDX, OpAccess.READ);
				addRegister(flags, Register.EAX, OpAccess.WRITE);
			}
			break;
		case ImpliedAccess.T_RECX_REDX_RWEAX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.ECX, OpAccess.READ);
				addRegister(flags, Register.EDX, OpAccess.READ);
				addRegister(flags, Register.EAX, OpAccess.READ_WRITE);
			}
			break;
		case ImpliedAccess.T_RECX_REDX_RWRAX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.ECX, OpAccess.READ);
				addRegister(flags, Register.EDX, OpAccess.READ);
				addRegister(flags, Register.RAX, OpAccess.READ_WRITE);
			}
			break;
		case ImpliedAccess.T_RAX_RECX_REDX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.AX, OpAccess.READ);
				addRegister(flags, Register.ECX, OpAccess.READ);
				addRegister(flags, Register.EDX, OpAccess.READ);
			}
			break;
		case ImpliedAccess.T_RECX_REDX_RRAX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.ECX, OpAccess.READ);
				addRegister(flags, Register.EDX, OpAccess.READ);
				addRegister(flags, Register.RAX, OpAccess.READ);
			}
			break;
		case ImpliedAccess.T_WTMM0_TOTMM7:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				for (int reg = Register.TMM0; reg <= Register.TMM7; reg++)
					addRegister(flags, reg, OpAccess.WRITE);
			}
			break;
		case ImpliedAccess.T_REAX_REBX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.EAX, OpAccess.READ);
				addRegister(flags, Register.EBX, OpAccess.READ);
			}
			break;
		case ImpliedAccess.T_REBX_WEAX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.EBX, OpAccess.READ);
				addRegister(flags, Register.EAX, OpAccess.WRITE);
			}
			break;
		case ImpliedAccess.T_EMMI_W:
			commandEmmi(instruction, flags, OpAccess.WRITE);
			break;
		case ImpliedAccess.T_EMMI_RW:
			commandEmmi(instruction, flags, OpAccess.READ_WRITE);
			break;
		case ImpliedAccess.T_EMMI_R:
			commandEmmi(instruction, flags, OpAccess.READ);
			break;
		case ImpliedAccess.T_CRRCX_CRRDX_CRR8_CRR9_RWRAX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.RCX, OpAccess.COND_READ);
				addRegister(flags, Register.RDX, OpAccess.COND_READ);
				addRegister(flags, Register.R8, OpAccess.COND_READ);
				addRegister(flags, Register.R9, OpAccess.COND_READ);
				addRegister(flags, Register.RAX, OpAccess.READ_WRITE);
			}
			break;
		case ImpliedAccess.T_RWXMM0_TOXMM7:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				for (int reg = Register.XMM0; reg <= Register.XMM7; reg++)
					addRegister(flags, reg, OpAccess.READ_WRITE);
			}
			break;
		case ImpliedAccess.T_REAX_RXMM0:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.EAX, OpAccess.READ);
				addRegister(flags, Register.XMM0, OpAccess.READ);
			}
			break;
		case ImpliedAccess.T_WXMM1_WXMM2_RWXMM0_WXMM4_TOXMM6:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.XMM1, OpAccess.WRITE);
				addRegister(flags, Register.XMM2, OpAccess.WRITE);
				addRegister(flags, Register.XMM0, OpAccess.READ_WRITE);
				for (int reg = Register.XMM4; reg <= Register.XMM6; reg++)
					addRegister(flags, reg, OpAccess.WRITE);
			}
			break;
		case ImpliedAccess.T_RWXMM0_RWXMM1_WXMM2_TOXMM6:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.XMM0, OpAccess.READ_WRITE);
				addRegister(flags, Register.XMM1, OpAccess.READ_WRITE);
				for (int reg = Register.XMM2; reg <= Register.XMM6; reg++)
					addRegister(flags, reg, OpAccess.WRITE);
			}
			break;
		case ImpliedAccess.T_POP3X8:
			commandPop(instruction, flags, 3, 8);
			break;
		case ImpliedAccess.T_CRMEM_CRMEM_CWMEM_CRBX_CRSI_CRDI_CRES_CWSI_RCWAX_RCWCX:
			if ((flags & Flags.NO_MEMORY_USAGE) == 0) {
				addMemory(Register.ES, Register.SI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE16, 0);
				addMemory(Register.ES, Register.DI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE16, 0);
				addMemory(Register.ES, Register.DI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_WRITE, CodeSize.CODE16, 0);
			}
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.BX, OpAccess.COND_READ);
				addRegister(flags, Register.SI, OpAccess.COND_READ);
				addRegister(flags, Register.DI, OpAccess.COND_READ);
				if ((flags & Flags.IS_64_BIT) == 0)
					addRegister(flags, Register.ES, OpAccess.COND_READ);
				addRegister(flags, Register.SI, OpAccess.COND_WRITE);
				addRegister(flags, Register.AX, OpAccess.READ_COND_WRITE);
				addRegister(flags, Register.CX, OpAccess.READ_COND_WRITE);
			}
			break;
		case ImpliedAccess.T_CRMEM_CRMEM_CWMEM_CREBX_CRESI_CREDI_CRES_CWESI_RCWEAX_RCWECX:
			if ((flags & Flags.NO_MEMORY_USAGE) == 0) {
				addMemory(Register.ES, Register.ESI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE32, 0);
				addMemory(Register.ES, Register.EDI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE32, 0);
				addMemory(Register.ES, Register.EDI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_WRITE, CodeSize.CODE32, 0);
			}
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.EBX, OpAccess.COND_READ);
				addRegister(flags, Register.ESI, OpAccess.COND_READ);
				addRegister(flags, Register.EDI, OpAccess.COND_READ);
				if ((flags & Flags.IS_64_BIT) == 0)
					addRegister(flags, Register.ES, OpAccess.COND_READ);
				addRegister(flags, Register.ESI, OpAccess.COND_WRITE);
				addRegister(flags, Register.EAX, OpAccess.READ_COND_WRITE);
				addRegister(flags, Register.ECX, OpAccess.READ_COND_WRITE);
			}
			break;
		case ImpliedAccess.T_CRMEM_CRMEM_CWMEM_CRRBX_CRRSI_CRRDI_CRES_CWRSI_RCWRAX_RCWRCX:
			if ((flags & Flags.NO_MEMORY_USAGE) == 0) {
				addMemory(Register.ES, Register.RSI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE64, 0);
				addMemory(Register.ES, Register.RDI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE64, 0);
				addMemory(Register.ES, Register.RDI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_WRITE, CodeSize.CODE64, 0);
			}
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.RBX, OpAccess.COND_READ);
				addRegister(flags, Register.RSI, OpAccess.COND_READ);
				addRegister(flags, Register.RDI, OpAccess.COND_READ);
				if ((flags & Flags.IS_64_BIT) == 0)
					addRegister(flags, Register.ES, OpAccess.COND_READ);
				addRegister(flags, Register.RSI, OpAccess.COND_WRITE);
				addRegister(flags, Register.RAX, OpAccess.READ_COND_WRITE);
				addRegister(flags, Register.RCX, OpAccess.READ_COND_WRITE);
			}
			break;
		case ImpliedAccess.T_CRMEM_CRMEM_CRMEM_CWMEM_CRAX_CRDX_CRBX_CRSI_CRDI_CRES_CWSI_CWDI_RCWCX:
			if ((flags & Flags.NO_MEMORY_USAGE) == 0) {
				addMemory(Register.ES, Register.DX, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE16, 0);
				addMemory(Register.ES, Register.BX, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE16, 0);
				addMemory(Register.ES, Register.SI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE16, 0);
				addMemory(Register.ES, Register.DI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_WRITE, CodeSize.CODE16, 0);
			}
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.AX, OpAccess.COND_READ);
				addRegister(flags, Register.DX, OpAccess.COND_READ);
				addRegister(flags, Register.BX, OpAccess.COND_READ);
				addRegister(flags, Register.SI, OpAccess.COND_READ);
				addRegister(flags, Register.DI, OpAccess.COND_READ);
				if ((flags & Flags.IS_64_BIT) == 0)
					addRegister(flags, Register.ES, OpAccess.COND_READ);
				addRegister(flags, Register.SI, OpAccess.COND_WRITE);
				addRegister(flags, Register.DI, OpAccess.COND_WRITE);
				addRegister(flags, Register.CX, OpAccess.READ_COND_WRITE);
			}
			break;
		case ImpliedAccess.T_CRMEM_CRMEM_CRMEM_CWMEM_CREAX_CREDX_CREBX_CRESI_CREDI_CRES_CWESI_CWEDI_RCWECX:
			if ((flags & Flags.NO_MEMORY_USAGE) == 0) {
				addMemory(Register.ES, Register.EDX, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE32, 0);
				addMemory(Register.ES, Register.EBX, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE32, 0);
				addMemory(Register.ES, Register.ESI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE32, 0);
				addMemory(Register.ES, Register.EDI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_WRITE, CodeSize.CODE32, 0);
			}
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.EAX, OpAccess.COND_READ);
				addRegister(flags, Register.EDX, OpAccess.COND_READ);
				addRegister(flags, Register.EBX, OpAccess.COND_READ);
				addRegister(flags, Register.ESI, OpAccess.COND_READ);
				addRegister(flags, Register.EDI, OpAccess.COND_READ);
				if ((flags & Flags.IS_64_BIT) == 0)
					addRegister(flags, Register.ES, OpAccess.COND_READ);
				addRegister(flags, Register.ESI, OpAccess.COND_WRITE);
				addRegister(flags, Register.EDI, OpAccess.COND_WRITE);
				addRegister(flags, Register.ECX, OpAccess.READ_COND_WRITE);
			}
			break;
		case ImpliedAccess.T_CRMEM_CRMEM_CRMEM_CWMEM_CRRAX_CRRDX_CRRBX_CRRSI_CRRDI_CRES_CWRSI_CWRDI_RCWRCX:
			if ((flags & Flags.NO_MEMORY_USAGE) == 0) {
				addMemory(Register.ES, Register.RDX, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE64, 0);
				addMemory(Register.ES, Register.RBX, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE64, 0);
				addMemory(Register.ES, Register.RSI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE64, 0);
				addMemory(Register.ES, Register.RDI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_WRITE, CodeSize.CODE64, 0);
			}
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.RAX, OpAccess.COND_READ);
				addRegister(flags, Register.RDX, OpAccess.COND_READ);
				addRegister(flags, Register.RBX, OpAccess.COND_READ);
				addRegister(flags, Register.RSI, OpAccess.COND_READ);
				addRegister(flags, Register.RDI, OpAccess.COND_READ);
				if ((flags & Flags.IS_64_BIT) == 0)
					addRegister(flags, Register.ES, OpAccess.COND_READ);
				addRegister(flags, Register.RSI, OpAccess.COND_WRITE);
				addRegister(flags, Register.RDI, OpAccess.COND_WRITE);
				addRegister(flags, Register.RCX, OpAccess.READ_COND_WRITE);
			}
			break;
		case ImpliedAccess.T_GPR16_WGS:
			commandLastGpr(instruction, flags, Register.AX);
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.GS, OpAccess.WRITE);
			}
			break;
		case ImpliedAccess.T_WRSP_WCS_WSS_POP5X8:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.RSP, OpAccess.WRITE);
				addRegister(flags, Register.CS, OpAccess.WRITE);
				addRegister(flags, Register.SS, OpAccess.WRITE);
			}
			commandPop(instruction, flags, 5, 8);
			break;
		case ImpliedAccess.T_RCS_RSS_WRSP_POP5X8:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.CS, OpAccess.READ);
				addRegister(flags, Register.SS, OpAccess.READ);
				addRegister(flags, Register.RSP, OpAccess.WRITE);
			}
			commandPop(instruction, flags, 5, 8);
			break;
		case ImpliedAccess.T_REAX_RECX_WEDX_WEBX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.EAX, OpAccess.READ);
				addRegister(flags, Register.ECX, OpAccess.READ);
				addRegister(flags, Register.EDX, OpAccess.WRITE);
				addRegister(flags, Register.EBX, OpAccess.WRITE);
			}
			break;
		case ImpliedAccess.T_REAX_RECX_REDX_CREBX_CWEDX_CWEBX:
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.EAX, OpAccess.READ);
				addRegister(flags, Register.ECX, OpAccess.READ);
				addRegister(flags, Register.EDX, OpAccess.READ);
				addRegister(flags, Register.EBX, OpAccess.COND_READ);
				addRegister(flags, Register.EDX, OpAccess.COND_WRITE);
				addRegister(flags, Register.EBX, OpAccess.COND_WRITE);
			}
			break;
		case ImpliedAccess.T_MEMDISPLM64:
			commandMemDispl(flags, -64);
			break;
		case ImpliedAccess.T_CRMEM_CRMEM_CWMEM_CRSI_CRDI_CRES_CWSI_RCWCX:
			if ((flags & Flags.NO_MEMORY_USAGE) == 0) {
				addMemory(Register.ES, Register.SI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE16, 0);
				addMemory(Register.ES, Register.DI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE16, 0);
				addMemory(Register.ES, Register.DI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_WRITE, CodeSize.CODE16, 0);
			}
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.SI, OpAccess.COND_READ);
				addRegister(flags, Register.DI, OpAccess.COND_READ);
				if ((flags & Flags.IS_64_BIT) == 0)
					addRegister(flags, Register.ES, OpAccess.COND_READ);
				addRegister(flags, Register.SI, OpAccess.COND_WRITE);
				addRegister(flags, Register.CX, OpAccess.READ_COND_WRITE);
			}
			break;
		case ImpliedAccess.T_CRMEM_CRMEM_CWMEM_CRESI_CREDI_CRES_CWESI_RCWECX:
			if ((flags & Flags.NO_MEMORY_USAGE) == 0) {
				addMemory(Register.ES, Register.ESI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE32, 0);
				addMemory(Register.ES, Register.EDI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE32, 0);
				addMemory(Register.ES, Register.EDI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_WRITE, CodeSize.CODE32, 0);
			}
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.ESI, OpAccess.COND_READ);
				addRegister(flags, Register.EDI, OpAccess.COND_READ);
				if ((flags & Flags.IS_64_BIT) == 0)
					addRegister(flags, Register.ES, OpAccess.COND_READ);
				addRegister(flags, Register.ESI, OpAccess.COND_WRITE);
				addRegister(flags, Register.ECX, OpAccess.READ_COND_WRITE);
			}
			break;
		case ImpliedAccess.T_CRMEM_CRMEM_CWMEM_CRRSI_CRRDI_CRES_CWRSI_RCWRCX:
			if ((flags & Flags.NO_MEMORY_USAGE) == 0) {
				addMemory(Register.ES, Register.RSI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE64, 0);
				addMemory(Register.ES, Register.RDI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_READ, CodeSize.CODE64, 0);
				addMemory(Register.ES, Register.RDI, Register.NONE, 1, 0x0, MemorySize.UNKNOWN, OpAccess.COND_WRITE, CodeSize.CODE64, 0);
			}
			if ((flags & Flags.NO_REGISTER_USAGE) == 0) {
				addRegister(flags, Register.RSI, OpAccess.COND_READ);
				addRegister(flags, Register.RDI, OpAccess.COND_READ);
				if ((flags & Flags.IS_64_BIT) == 0)
					addRegister(flags, Register.ES, OpAccess.COND_READ);
				addRegister(flags, Register.RSI, OpAccess.COND_WRITE);
				addRegister(flags, Register.RCX, OpAccess.READ_COND_WRITE);
			}
			break;
		// GENERATOR-END: ImpliedAccessHandler

		default:
			throw new UnsupportedOperationException();
		}
	}

	private static int getARDI(Instruction instruction) {
		throw new UnsupportedOperationException(); // TODO
	}

	private static int getSegDefaultDS(Instruction instruction) {
		throw new UnsupportedOperationException(); // TODO
	}

	private void commandPush(Instruction instruction, int flags, int count, int opSize) {
		throw new UnsupportedOperationException(); // TODO
	}

	private void commandPop(Instruction instruction, int flags, int count, int opSize) {
		throw new UnsupportedOperationException(); // TODO
	}

	private void commandPopRm(Instruction instruction, int flags, int opSize) {
		throw new UnsupportedOperationException(); // TODO
	}

	private void commandPusha(Instruction instruction, int flags, int opSize) {
		throw new UnsupportedOperationException(); // TODO
	}

	private void commandPopa(Instruction instruction, int flags, int opSize) {
		throw new UnsupportedOperationException(); // TODO
	}

	private void commandIns(Instruction instruction, int flags) {
		throw new UnsupportedOperationException(); // TODO
	}

	private void commandOuts(Instruction instruction, int flags) {
		throw new UnsupportedOperationException(); // TODO
	}

	private void commandMovs(Instruction instruction, int flags) {
		throw new UnsupportedOperationException(); // TODO
	}

	private void commandCmps(Instruction instruction, int flags) {
		throw new UnsupportedOperationException(); // TODO
	}

	private void commandStos(Instruction instruction, int flags) {
		throw new UnsupportedOperationException(); // TODO
	}

	private void commandLods(Instruction instruction, int flags) {
		throw new UnsupportedOperationException(); // TODO
	}

	private void commandScas(Instruction instruction, int flags) {
		throw new UnsupportedOperationException(); // TODO
	}

	private void commandXstore(Instruction instruction, int flags, int size) {
		throw new UnsupportedOperationException(); // TODO
	}

	private void commandEnter(Instruction instruction, int flags, int opSize) {
		throw new UnsupportedOperationException(); // TODO
	}

	private void commandLeave(Instruction instruction, int flags, int opSize) {
		throw new UnsupportedOperationException(); // TODO
	}

	private void commandClearRflags(Instruction instruction, int flags) {
		throw new UnsupportedOperationException(); // TODO
	}

	private void commandClearRegRegmem(Instruction instruction, int flags) {
		throw new UnsupportedOperationException(); // TODO
	}

	private void commandClearRegRegRegmem(Instruction instruction, int flags) {
		throw new UnsupportedOperationException(); // TODO
	}

	private void commandArpl(Instruction instruction, int flags) {
		throw new UnsupportedOperationException(); // TODO
	}

	private void commandLastGpr(Instruction instruction, int flags, int baseReg) {
		throw new UnsupportedOperationException(); // TODO
	}

	private void commandLea(Instruction instruction, int flags) {
		throw new UnsupportedOperationException(); // TODO
	}

	private void commandEmmi(Instruction instruction, int flags, int opAccess) {
		throw new UnsupportedOperationException(); // TODO
	}

	private void commandMemDispl(int flags, int extraDispl) {
		throw new UnsupportedOperationException(); // TODO
	}

	private void addMemory(int segReg, int baseReg, int indexReg, int scale, long displ, int memorySize, int access, int addressSize, int vsibSize) {
		throw new UnsupportedOperationException(); // TODO
	}

	private void addMemorySegmentRegister(int flags, int seg, int access) {
		throw new UnsupportedOperationException(); // TODO
	}

	private void addRegister(int flags, int reg, int access) {
		throw new UnsupportedOperationException(); // TODO
	}
}
