// SPDX-License-Identifier: MIT
// Copyright (C) 2018-present iced project and contributors

// ⚠️This file was generated by GENERATOR!🦹‍♂️

#![allow(clippy::if_same_then_else)]

use crate::code_asm::fn_asm_traits::*;
use crate::code_asm::mem::*;
use crate::code_asm::op_state::MemoryOperandSize;
use crate::code_asm::reg::*;
use crate::code_asm::{CodeAssembler, CodeLabel};
use crate::{Code, IcedError, Instruction, Register, RepPrefixKind};
use core::i8;

#[rustfmt::skip]
impl CodeAsmAaa for CodeAssembler {
	#[inline]
	fn aaa(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Aaa))
	}
}

#[rustfmt::skip]
impl CodeAsmAad<i32> for CodeAssembler {
	#[inline]
	fn aad(&mut self, op0: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Aad_imm8, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAad<u32> for CodeAssembler {
	#[inline]
	fn aad(&mut self, op0: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Aad_imm8, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAam<i32> for CodeAssembler {
	#[inline]
	fn aam(&mut self, op0: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Aam_imm8, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAam<u32> for CodeAssembler {
	#[inline]
	fn aam(&mut self, op0: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Aam_imm8, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAas for CodeAssembler {
	#[inline]
	fn aas(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Aas))
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<__AsmRegister8, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn adc(&mut self, op0: __AsmRegister8, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Adc_rm8_r8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<__AsmMemoryOperand, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn adc(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Adc_rm8_r8, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn adc(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Adc_rm16_r16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<__AsmMemoryOperand, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn adc(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Adc_rm16_r16, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn adc(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Adc_rm32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<__AsmMemoryOperand, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn adc(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Adc_rm32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn adc(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Adc_rm64_r64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<__AsmMemoryOperand, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn adc(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Adc_rm64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<__AsmRegister8, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn adc(&mut self, op0: __AsmRegister8, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Adc_r8_rm8, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn adc(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Adc_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn adc(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Adc_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn adc(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Adc_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<__AsmRegister8, i32> for CodeAssembler {
	#[inline]
	fn adc(&mut self, op0: __AsmRegister8, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AL { Code::Adc_AL_imm8 } else { Code::Adc_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<__AsmRegister16, i32> for CodeAssembler {
	fn adc(&mut self, op0: __AsmRegister16, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AX {
			Code::Adc_AX_imm16
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Adc_rm16_imm8
		} else {
			Code::Adc_rm16_imm16
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<__AsmRegister32, i32> for CodeAssembler {
	fn adc(&mut self, op0: __AsmRegister32, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::EAX {
			Code::Adc_EAX_imm32
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Adc_rm32_imm8
		} else {
			Code::Adc_rm32_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<__AsmRegister64, i32> for CodeAssembler {
	fn adc(&mut self, op0: __AsmRegister64, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::RAX {
			Code::Adc_RAX_imm32
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Adc_rm64_imm8
		} else {
			Code::Adc_rm64_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<__AsmMemoryOperand, i32> for CodeAssembler {
	fn adc(&mut self, op0: __AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Adc_rm64_imm8 } else { Code::Adc_rm64_imm32 }
		} else if op0.size() == MemoryOperandSize::Dword {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Adc_rm32_imm8 } else { Code::Adc_rm32_imm32 }
		} else if op0.size() == MemoryOperandSize::Word {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Adc_rm16_imm8 } else { Code::Adc_rm16_imm16 }
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Adc_rm8_imm8
		} else {
			return Err(IcedError::new("adc: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<__AsmRegister8, u32> for CodeAssembler {
	#[inline]
	fn adc(&mut self, op0: __AsmRegister8, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AL { Code::Adc_AL_imm8 } else { Code::Adc_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<__AsmRegister16, u32> for CodeAssembler {
	fn adc(&mut self, op0: __AsmRegister16, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AX {
			Code::Adc_AX_imm16
		} else if op1 <= i8::MAX as u32 || (0xFF80 <= op1 && op1 <= 0xFFFF) {
			Code::Adc_rm16_imm8
		} else {
			Code::Adc_rm16_imm16
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<__AsmRegister32, u32> for CodeAssembler {
	fn adc(&mut self, op0: __AsmRegister32, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::EAX {
			Code::Adc_EAX_imm32
		} else if op1 <= i8::MAX as u32 || 0xFFFF_FF80 <= op1 {
			Code::Adc_rm32_imm8
		} else {
			Code::Adc_rm32_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<__AsmMemoryOperand, u32> for CodeAssembler {
	fn adc(&mut self, op0: __AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Dword {
			if op1 <= i8::MAX as u32 || 0xFFFF_FF80 <= op1 { Code::Adc_rm32_imm8 } else { Code::Adc_rm32_imm32 }
		} else if op0.size() == MemoryOperandSize::Word {
			if op1 <= i8::MAX as u32 || (0xFF80 <= op1 && op1 <= 0xFFFF) { Code::Adc_rm16_imm8 } else { Code::Adc_rm16_imm16 }
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Adc_rm8_imm8
		} else {
			return Err(IcedError::new("adc: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdcx<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn adcx(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Adcx_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdcx<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn adcx(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Adcx_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdcx<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn adcx(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Adcx_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdcx<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn adcx(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Adcx_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<__AsmRegister8, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn add(&mut self, op0: __AsmRegister8, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Add_rm8_r8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<__AsmMemoryOperand, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn add(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Add_rm8_r8, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn add(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Add_rm16_r16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<__AsmMemoryOperand, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn add(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Add_rm16_r16, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn add(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Add_rm32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<__AsmMemoryOperand, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn add(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Add_rm32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn add(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Add_rm64_r64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<__AsmMemoryOperand, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn add(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Add_rm64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<__AsmRegister8, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn add(&mut self, op0: __AsmRegister8, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Add_r8_rm8, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn add(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Add_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn add(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Add_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn add(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Add_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<__AsmRegister8, i32> for CodeAssembler {
	#[inline]
	fn add(&mut self, op0: __AsmRegister8, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AL { Code::Add_AL_imm8 } else { Code::Add_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<__AsmRegister16, i32> for CodeAssembler {
	fn add(&mut self, op0: __AsmRegister16, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AX {
			Code::Add_AX_imm16
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Add_rm16_imm8
		} else {
			Code::Add_rm16_imm16
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<__AsmRegister32, i32> for CodeAssembler {
	fn add(&mut self, op0: __AsmRegister32, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::EAX {
			Code::Add_EAX_imm32
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Add_rm32_imm8
		} else {
			Code::Add_rm32_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<__AsmRegister64, i32> for CodeAssembler {
	fn add(&mut self, op0: __AsmRegister64, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::RAX {
			Code::Add_RAX_imm32
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Add_rm64_imm8
		} else {
			Code::Add_rm64_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<__AsmMemoryOperand, i32> for CodeAssembler {
	fn add(&mut self, op0: __AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Add_rm64_imm8 } else { Code::Add_rm64_imm32 }
		} else if op0.size() == MemoryOperandSize::Dword {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Add_rm32_imm8 } else { Code::Add_rm32_imm32 }
		} else if op0.size() == MemoryOperandSize::Word {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Add_rm16_imm8 } else { Code::Add_rm16_imm16 }
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Add_rm8_imm8
		} else {
			return Err(IcedError::new("add: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<__AsmRegister8, u32> for CodeAssembler {
	#[inline]
	fn add(&mut self, op0: __AsmRegister8, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AL { Code::Add_AL_imm8 } else { Code::Add_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<__AsmRegister16, u32> for CodeAssembler {
	fn add(&mut self, op0: __AsmRegister16, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AX {
			Code::Add_AX_imm16
		} else if op1 <= i8::MAX as u32 || (0xFF80 <= op1 && op1 <= 0xFFFF) {
			Code::Add_rm16_imm8
		} else {
			Code::Add_rm16_imm16
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<__AsmRegister32, u32> for CodeAssembler {
	fn add(&mut self, op0: __AsmRegister32, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::EAX {
			Code::Add_EAX_imm32
		} else if op1 <= i8::MAX as u32 || 0xFFFF_FF80 <= op1 {
			Code::Add_rm32_imm8
		} else {
			Code::Add_rm32_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<__AsmMemoryOperand, u32> for CodeAssembler {
	fn add(&mut self, op0: __AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Dword {
			if op1 <= i8::MAX as u32 || 0xFFFF_FF80 <= op1 { Code::Add_rm32_imm8 } else { Code::Add_rm32_imm32 }
		} else if op0.size() == MemoryOperandSize::Word {
			if op1 <= i8::MAX as u32 || (0xFF80 <= op1 && op1 <= 0xFFFF) { Code::Add_rm16_imm8 } else { Code::Add_rm16_imm16 }
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Add_rm8_imm8
		} else {
			return Err(IcedError::new("add: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAddpd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn addpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Addpd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAddpd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn addpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Addpd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAddps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn addps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Addps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAddps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn addps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Addps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAddsd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn addsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Addsd_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAddsd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn addsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Addsd_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAddss<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn addss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Addss_xmm_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAddss<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn addss(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Addss_xmm_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAddsubpd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn addsubpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Addsubpd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAddsubpd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn addsubpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Addsubpd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAddsubps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn addsubps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Addsubps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAddsubps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn addsubps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Addsubps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdox<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn adox(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Adox_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdox<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn adox(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Adox_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdox<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn adox(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Adox_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdox<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn adox(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Adox_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAesdec<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn aesdec(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Aesdec_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAesdec<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn aesdec(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Aesdec_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAesdec128kl<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn aesdec128kl(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Aesdec128kl_xmm_m384, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAesdec256kl<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn aesdec256kl(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Aesdec256kl_xmm_m512, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAesdeclast<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn aesdeclast(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Aesdeclast_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAesdeclast<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn aesdeclast(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Aesdeclast_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAesdecwide128kl<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn aesdecwide128kl(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Aesdecwide128kl_m384, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAesdecwide256kl<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn aesdecwide256kl(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Aesdecwide256kl_m512, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAesenc<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn aesenc(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Aesenc_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAesenc<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn aesenc(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Aesenc_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAesenc128kl<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn aesenc128kl(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Aesenc128kl_xmm_m384, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAesenc256kl<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn aesenc256kl(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Aesenc256kl_xmm_m512, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAesenclast<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn aesenclast(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Aesenclast_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAesenclast<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn aesenclast(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Aesenclast_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAesencwide128kl<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn aesencwide128kl(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Aesencwide128kl_m384, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAesencwide256kl<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn aesencwide256kl(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Aesencwide256kl_m512, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAesimc<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn aesimc(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Aesimc_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAesimc<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn aesimc(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Aesimc_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAeskeygenassist<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn aeskeygenassist(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Aeskeygenassist_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAeskeygenassist<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn aeskeygenassist(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Aeskeygenassist_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAeskeygenassist<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn aeskeygenassist(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Aeskeygenassist_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAeskeygenassist<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn aeskeygenassist(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Aeskeygenassist_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAltinst for CodeAssembler {
	#[inline]
	fn altinst(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Altinst))
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<__AsmRegister8, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn and(&mut self, op0: __AsmRegister8, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::And_rm8_r8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<__AsmMemoryOperand, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn and(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::And_rm8_r8, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn and(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::And_rm16_r16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<__AsmMemoryOperand, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn and(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::And_rm16_r16, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn and(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::And_rm32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<__AsmMemoryOperand, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn and(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::And_rm32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn and(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::And_rm64_r64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<__AsmMemoryOperand, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn and(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::And_rm64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<__AsmRegister8, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn and(&mut self, op0: __AsmRegister8, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::And_r8_rm8, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn and(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::And_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn and(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::And_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn and(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::And_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<__AsmRegister8, i32> for CodeAssembler {
	#[inline]
	fn and(&mut self, op0: __AsmRegister8, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AL { Code::And_AL_imm8 } else { Code::And_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<__AsmRegister16, i32> for CodeAssembler {
	fn and(&mut self, op0: __AsmRegister16, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AX {
			Code::And_AX_imm16
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::And_rm16_imm8
		} else {
			Code::And_rm16_imm16
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<__AsmRegister32, i32> for CodeAssembler {
	fn and(&mut self, op0: __AsmRegister32, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::EAX {
			Code::And_EAX_imm32
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::And_rm32_imm8
		} else {
			Code::And_rm32_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<__AsmRegister64, i32> for CodeAssembler {
	fn and(&mut self, op0: __AsmRegister64, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::RAX {
			Code::And_RAX_imm32
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::And_rm64_imm8
		} else {
			Code::And_rm64_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<__AsmMemoryOperand, i32> for CodeAssembler {
	fn and(&mut self, op0: __AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::And_rm64_imm8 } else { Code::And_rm64_imm32 }
		} else if op0.size() == MemoryOperandSize::Dword {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::And_rm32_imm8 } else { Code::And_rm32_imm32 }
		} else if op0.size() == MemoryOperandSize::Word {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::And_rm16_imm8 } else { Code::And_rm16_imm16 }
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::And_rm8_imm8
		} else {
			return Err(IcedError::new("and: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<__AsmRegister8, u32> for CodeAssembler {
	#[inline]
	fn and(&mut self, op0: __AsmRegister8, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AL { Code::And_AL_imm8 } else { Code::And_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<__AsmRegister16, u32> for CodeAssembler {
	fn and(&mut self, op0: __AsmRegister16, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AX {
			Code::And_AX_imm16
		} else if op1 <= i8::MAX as u32 || (0xFF80 <= op1 && op1 <= 0xFFFF) {
			Code::And_rm16_imm8
		} else {
			Code::And_rm16_imm16
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<__AsmRegister32, u32> for CodeAssembler {
	fn and(&mut self, op0: __AsmRegister32, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::EAX {
			Code::And_EAX_imm32
		} else if op1 <= i8::MAX as u32 || 0xFFFF_FF80 <= op1 {
			Code::And_rm32_imm8
		} else {
			Code::And_rm32_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<__AsmMemoryOperand, u32> for CodeAssembler {
	fn and(&mut self, op0: __AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Dword {
			if op1 <= i8::MAX as u32 || 0xFFFF_FF80 <= op1 { Code::And_rm32_imm8 } else { Code::And_rm32_imm32 }
		} else if op0.size() == MemoryOperandSize::Word {
			if op1 <= i8::MAX as u32 || (0xFF80 <= op1 && op1 <= 0xFFFF) { Code::And_rm16_imm8 } else { Code::And_rm16_imm16 }
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::And_rm8_imm8
		} else {
			return Err(IcedError::new("and: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAndn<__AsmRegister32, __AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn andn(&mut self, op0: __AsmRegister32, op1: __AsmRegister32, op2: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Andn_r32_r32_rm32, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAndn<__AsmRegister64, __AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn andn(&mut self, op0: __AsmRegister64, op1: __AsmRegister64, op2: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Andn_r64_r64_rm64, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAndn<__AsmRegister32, __AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn andn(&mut self, op0: __AsmRegister32, op1: __AsmRegister32, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Andn_r32_r32_rm32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAndn<__AsmRegister64, __AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn andn(&mut self, op0: __AsmRegister64, op1: __AsmRegister64, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Andn_r64_r64_rm64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAndnpd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn andnpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Andnpd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAndnpd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn andnpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Andnpd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAndnps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn andnps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Andnps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAndnps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn andnps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Andnps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAndpd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn andpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Andpd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAndpd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn andpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Andpd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAndps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn andps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Andps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAndps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn andps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Andps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmArpl<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn arpl(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Arpl_rm16_r16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmArpl<__AsmMemoryOperand, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn arpl(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Arpl_rm16_r16, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmArpl<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn arpl(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Arpl_r32m16_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmArpl<__AsmMemoryOperand, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn arpl(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Arpl_r32m16_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBb0_reset for CodeAssembler {
	#[inline]
	fn bb0_reset(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Bb0_reset))
	}
}

#[rustfmt::skip]
impl CodeAsmBb1_reset for CodeAssembler {
	#[inline]
	fn bb1_reset(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Bb1_reset))
	}
}

#[rustfmt::skip]
impl CodeAsmBextr<__AsmRegister32, __AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn bextr(&mut self, op0: __AsmRegister32, op1: __AsmRegister32, op2: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Bextr_r32_rm32_r32, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBextr<__AsmRegister32, __AsmMemoryOperand, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn bextr(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand, op2: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Bextr_r32_rm32_r32, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBextr<__AsmRegister64, __AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn bextr(&mut self, op0: __AsmRegister64, op1: __AsmRegister64, op2: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Bextr_r64_rm64_r64, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBextr<__AsmRegister64, __AsmMemoryOperand, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn bextr(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand, op2: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Bextr_r64_rm64_r64, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBextr<__AsmRegister32, __AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn bextr(&mut self, op0: __AsmRegister32, op1: __AsmRegister32, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Bextr_r32_rm32_imm32, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBextr<__AsmRegister64, __AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn bextr(&mut self, op0: __AsmRegister64, op1: __AsmRegister64, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Bextr_r64_rm64_imm32, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBextr<__AsmRegister32, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn bextr(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Bextr_r32_rm32_imm32, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBextr<__AsmRegister64, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn bextr(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Bextr_r64_rm64_imm32, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBextr<__AsmRegister32, __AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn bextr(&mut self, op0: __AsmRegister32, op1: __AsmRegister32, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Bextr_r32_rm32_imm32, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBextr<__AsmRegister64, __AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn bextr(&mut self, op0: __AsmRegister64, op1: __AsmRegister64, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Bextr_r64_rm64_imm32, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBextr<__AsmRegister32, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn bextr(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Bextr_r32_rm32_imm32, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBextr<__AsmRegister64, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn bextr(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Bextr_r64_rm64_imm32, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlcfill<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn blcfill(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blcfill_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlcfill<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn blcfill(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blcfill_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlcfill<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blcfill(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blcfill_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlcfill<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blcfill(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blcfill_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlci<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn blci(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blci_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlci<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn blci(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blci_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlci<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blci(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blci_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlci<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blci(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blci_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlcic<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn blcic(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blcic_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlcic<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn blcic(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blcic_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlcic<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blcic(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blcic_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlcic<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blcic(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blcic_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlcmsk<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn blcmsk(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blcmsk_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlcmsk<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn blcmsk(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blcmsk_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlcmsk<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blcmsk(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blcmsk_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlcmsk<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blcmsk(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blcmsk_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlcs<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn blcs(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blcs_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlcs<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn blcs(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blcs_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlcs<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blcs(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blcs_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlcs<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blcs(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blcs_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlendpd<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn blendpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Blendpd_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlendpd<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn blendpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Blendpd_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlendpd<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn blendpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Blendpd_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlendpd<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn blendpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Blendpd_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlendps<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn blendps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Blendps_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlendps<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn blendps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Blendps_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlendps<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn blendps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Blendps_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlendps<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn blendps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Blendps_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlendvpd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn blendvpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Blendvpd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlendvpd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blendvpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Blendvpd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlendvps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn blendvps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Blendvps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlendvps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blendvps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Blendvps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlsfill<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn blsfill(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blsfill_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlsfill<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn blsfill(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blsfill_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlsfill<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blsfill(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blsfill_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlsfill<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blsfill(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blsfill_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlsi<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn blsi(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Blsi_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlsi<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn blsi(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Blsi_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlsi<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blsi(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Blsi_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlsi<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blsi(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Blsi_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlsic<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn blsic(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blsic_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlsic<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn blsic(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blsic_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlsic<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blsic(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blsic_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlsic<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blsic(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blsic_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlsmsk<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn blsmsk(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Blsmsk_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlsmsk<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn blsmsk(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Blsmsk_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlsmsk<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blsmsk(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Blsmsk_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlsmsk<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blsmsk(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Blsmsk_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlsr<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn blsr(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Blsr_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlsr<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn blsr(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Blsr_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlsr<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blsr(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Blsr_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlsr<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blsr(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Blsr_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBndcl<__AsmRegisterBnd, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn bndcl(&mut self, op0: __AsmRegisterBnd, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bndcl_bnd_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBndcl<__AsmRegisterBnd, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn bndcl(&mut self, op0: __AsmRegisterBnd, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bndcl_bnd_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBndcl<__AsmRegisterBnd, __AsmMemoryOperand> for CodeAssembler {
	fn bndcl(&mut self, op0: __AsmRegisterBnd, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.size() == MemoryOperandSize::Qword {
			Code::Bndcl_bnd_rm64
		} else if op1.size() == MemoryOperandSize::Dword {
			Code::Bndcl_bnd_rm32
		} else {
			return Err(IcedError::new("bndcl: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBndcn<__AsmRegisterBnd, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn bndcn(&mut self, op0: __AsmRegisterBnd, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bndcn_bnd_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBndcn<__AsmRegisterBnd, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn bndcn(&mut self, op0: __AsmRegisterBnd, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bndcn_bnd_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBndcn<__AsmRegisterBnd, __AsmMemoryOperand> for CodeAssembler {
	fn bndcn(&mut self, op0: __AsmRegisterBnd, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.size() == MemoryOperandSize::Qword {
			Code::Bndcn_bnd_rm64
		} else if op1.size() == MemoryOperandSize::Dword {
			Code::Bndcn_bnd_rm32
		} else {
			return Err(IcedError::new("bndcn: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBndcu<__AsmRegisterBnd, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn bndcu(&mut self, op0: __AsmRegisterBnd, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bndcu_bnd_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBndcu<__AsmRegisterBnd, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn bndcu(&mut self, op0: __AsmRegisterBnd, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bndcu_bnd_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBndcu<__AsmRegisterBnd, __AsmMemoryOperand> for CodeAssembler {
	fn bndcu(&mut self, op0: __AsmRegisterBnd, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.size() == MemoryOperandSize::Qword {
			Code::Bndcu_bnd_rm64
		} else if op1.size() == MemoryOperandSize::Dword {
			Code::Bndcu_bnd_rm32
		} else {
			return Err(IcedError::new("bndcu: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBndldx<__AsmRegisterBnd, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn bndldx(&mut self, op0: __AsmRegisterBnd, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bndldx_bnd_mib, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBndmk<__AsmRegisterBnd, __AsmMemoryOperand> for CodeAssembler {
	fn bndmk(&mut self, op0: __AsmRegisterBnd, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.size() == MemoryOperandSize::Qword {
			Code::Bndmk_bnd_m64
		} else if op1.size() == MemoryOperandSize::Dword {
			Code::Bndmk_bnd_m32
		} else {
			return Err(IcedError::new("bndmk: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBndmov<__AsmRegisterBnd, __AsmRegisterBnd> for CodeAssembler {
	#[inline]
	fn bndmov(&mut self, op0: __AsmRegisterBnd, op1: __AsmRegisterBnd) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 { Code::Bndmov_bnd_bndm128 } else { Code::Bndmov_bnd_bndm64 };
		self.add_instr(Instruction::with2(code, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBndmov<__AsmMemoryOperand, __AsmRegisterBnd> for CodeAssembler {
	#[inline]
	fn bndmov(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterBnd) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 { Code::Bndmov_bndm128_bnd } else { Code::Bndmov_bndm64_bnd };
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBndmov<__AsmRegisterBnd, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn bndmov(&mut self, op0: __AsmRegisterBnd, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 { Code::Bndmov_bnd_bndm128 } else { Code::Bndmov_bnd_bndm64 };
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBndstx<__AsmMemoryOperand, __AsmRegisterBnd> for CodeAssembler {
	#[inline]
	fn bndstx(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterBnd) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bndstx_mib_bnd, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBound<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn bound(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bound_r16_m1616, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBound<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn bound(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bound_r32_m3232, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBsf<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn bsf(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bsf_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBsf<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn bsf(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bsf_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBsf<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn bsf(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bsf_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBsf<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn bsf(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bsf_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBsf<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn bsf(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bsf_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBsf<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn bsf(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bsf_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBsr<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn bsr(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bsr_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBsr<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn bsr(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bsr_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBsr<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn bsr(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bsr_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBsr<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn bsr(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bsr_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBsr<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn bsr(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bsr_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBsr<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn bsr(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bsr_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBswap<__AsmRegister16> for CodeAssembler {
	#[inline]
	fn bswap(&mut self, op0: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Bswap_r16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBswap<__AsmRegister32> for CodeAssembler {
	#[inline]
	fn bswap(&mut self, op0: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Bswap_r32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBswap<__AsmRegister64> for CodeAssembler {
	#[inline]
	fn bswap(&mut self, op0: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Bswap_r64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBt<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn bt(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bt_rm16_r16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBt<__AsmMemoryOperand, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn bt(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bt_rm16_r16, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBt<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn bt(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bt_rm32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBt<__AsmMemoryOperand, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn bt(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bt_rm32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBt<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn bt(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bt_rm64_r64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBt<__AsmMemoryOperand, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn bt(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bt_rm64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBt<__AsmRegister16, i32> for CodeAssembler {
	#[inline]
	fn bt(&mut self, op0: __AsmRegister16, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bt_rm16_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBt<__AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn bt(&mut self, op0: __AsmRegister32, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bt_rm32_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBt<__AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn bt(&mut self, op0: __AsmRegister64, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bt_rm64_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBt<__AsmMemoryOperand, i32> for CodeAssembler {
	fn bt(&mut self, op0: __AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Bt_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Bt_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Bt_rm16_imm8
		} else {
			return Err(IcedError::new("bt: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBt<__AsmRegister16, u32> for CodeAssembler {
	#[inline]
	fn bt(&mut self, op0: __AsmRegister16, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bt_rm16_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBt<__AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn bt(&mut self, op0: __AsmRegister32, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bt_rm32_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBt<__AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn bt(&mut self, op0: __AsmRegister64, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bt_rm64_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBt<__AsmMemoryOperand, u32> for CodeAssembler {
	fn bt(&mut self, op0: __AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Bt_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Bt_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Bt_rm16_imm8
		} else {
			return Err(IcedError::new("bt: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtc<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn btc(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btc_rm16_r16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtc<__AsmMemoryOperand, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn btc(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btc_rm16_r16, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtc<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn btc(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btc_rm32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtc<__AsmMemoryOperand, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn btc(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btc_rm32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtc<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn btc(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btc_rm64_r64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtc<__AsmMemoryOperand, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn btc(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btc_rm64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtc<__AsmRegister16, i32> for CodeAssembler {
	#[inline]
	fn btc(&mut self, op0: __AsmRegister16, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btc_rm16_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtc<__AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn btc(&mut self, op0: __AsmRegister32, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btc_rm32_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtc<__AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn btc(&mut self, op0: __AsmRegister64, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btc_rm64_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtc<__AsmMemoryOperand, i32> for CodeAssembler {
	fn btc(&mut self, op0: __AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Btc_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Btc_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Btc_rm16_imm8
		} else {
			return Err(IcedError::new("btc: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtc<__AsmRegister16, u32> for CodeAssembler {
	#[inline]
	fn btc(&mut self, op0: __AsmRegister16, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btc_rm16_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtc<__AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn btc(&mut self, op0: __AsmRegister32, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btc_rm32_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtc<__AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn btc(&mut self, op0: __AsmRegister64, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btc_rm64_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtc<__AsmMemoryOperand, u32> for CodeAssembler {
	fn btc(&mut self, op0: __AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Btc_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Btc_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Btc_rm16_imm8
		} else {
			return Err(IcedError::new("btc: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtr<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn btr(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btr_rm16_r16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtr<__AsmMemoryOperand, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn btr(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btr_rm16_r16, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtr<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn btr(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btr_rm32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtr<__AsmMemoryOperand, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn btr(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btr_rm32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtr<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn btr(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btr_rm64_r64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtr<__AsmMemoryOperand, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn btr(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btr_rm64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtr<__AsmRegister16, i32> for CodeAssembler {
	#[inline]
	fn btr(&mut self, op0: __AsmRegister16, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btr_rm16_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtr<__AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn btr(&mut self, op0: __AsmRegister32, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btr_rm32_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtr<__AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn btr(&mut self, op0: __AsmRegister64, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btr_rm64_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtr<__AsmMemoryOperand, i32> for CodeAssembler {
	fn btr(&mut self, op0: __AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Btr_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Btr_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Btr_rm16_imm8
		} else {
			return Err(IcedError::new("btr: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtr<__AsmRegister16, u32> for CodeAssembler {
	#[inline]
	fn btr(&mut self, op0: __AsmRegister16, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btr_rm16_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtr<__AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn btr(&mut self, op0: __AsmRegister32, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btr_rm32_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtr<__AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn btr(&mut self, op0: __AsmRegister64, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btr_rm64_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtr<__AsmMemoryOperand, u32> for CodeAssembler {
	fn btr(&mut self, op0: __AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Btr_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Btr_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Btr_rm16_imm8
		} else {
			return Err(IcedError::new("btr: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBts<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn bts(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bts_rm16_r16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBts<__AsmMemoryOperand, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn bts(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bts_rm16_r16, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBts<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn bts(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bts_rm32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBts<__AsmMemoryOperand, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn bts(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bts_rm32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBts<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn bts(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bts_rm64_r64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBts<__AsmMemoryOperand, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn bts(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bts_rm64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBts<__AsmRegister16, i32> for CodeAssembler {
	#[inline]
	fn bts(&mut self, op0: __AsmRegister16, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bts_rm16_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBts<__AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn bts(&mut self, op0: __AsmRegister32, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bts_rm32_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBts<__AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn bts(&mut self, op0: __AsmRegister64, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bts_rm64_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBts<__AsmMemoryOperand, i32> for CodeAssembler {
	fn bts(&mut self, op0: __AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Bts_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Bts_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Bts_rm16_imm8
		} else {
			return Err(IcedError::new("bts: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBts<__AsmRegister16, u32> for CodeAssembler {
	#[inline]
	fn bts(&mut self, op0: __AsmRegister16, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bts_rm16_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBts<__AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn bts(&mut self, op0: __AsmRegister32, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bts_rm32_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBts<__AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn bts(&mut self, op0: __AsmRegister64, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bts_rm64_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBts<__AsmMemoryOperand, u32> for CodeAssembler {
	fn bts(&mut self, op0: __AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Bts_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Bts_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Bts_rm16_imm8
		} else {
			return Err(IcedError::new("bts: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBzhi<__AsmRegister32, __AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn bzhi(&mut self, op0: __AsmRegister32, op1: __AsmRegister32, op2: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Bzhi_r32_rm32_r32, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBzhi<__AsmRegister32, __AsmMemoryOperand, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn bzhi(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand, op2: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Bzhi_r32_rm32_r32, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBzhi<__AsmRegister64, __AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn bzhi(&mut self, op0: __AsmRegister64, op1: __AsmRegister64, op2: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Bzhi_r64_rm64_r64, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBzhi<__AsmRegister64, __AsmMemoryOperand, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn bzhi(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand, op2: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Bzhi_r64_rm64_r64, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCall<__AsmRegister16> for CodeAssembler {
	#[inline]
	fn call(&mut self, op0: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Call_rm16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCall<__AsmRegister32> for CodeAssembler {
	#[inline]
	fn call(&mut self, op0: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Call_rm32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCall<__AsmRegister64> for CodeAssembler {
	#[inline]
	fn call(&mut self, op0: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Call_rm64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCall<__AsmMemoryOperand> for CodeAssembler {
	fn call(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Tbyte {
			Code::Call_m1664
		} else if op0.size() == MemoryOperandSize::Qword {
			Code::Call_rm64
		} else if op0.size() == MemoryOperandSize::Fword {
			Code::Call_m1632
		} else if op0.size() == MemoryOperandSize::Dword {
			if self.bitness() >= 32 { Code::Call_rm32 } else { Code::Call_m1616 }
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Call_rm16
		} else {
			return Err(IcedError::new("call: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCall<CodeLabel> for CodeAssembler {
	fn call(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Call_rel32_64
		} else if self.bitness() >= 32 {
			Code::Call_rel32_32
		} else {
			Code::Call_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCall<u64> for CodeAssembler {
	fn call(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Call_rel32_64
		} else if self.bitness() >= 32 {
			Code::Call_rel32_32
		} else {
			Code::Call_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCbw for CodeAssembler {
	#[inline]
	fn cbw(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Cbw))
	}
}

#[rustfmt::skip]
impl CodeAsmCcs_encrypt for CodeAssembler {
	fn ccs_encrypt(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Ccs_encrypt_64
		} else if self.bitness() >= 32 {
			Code::Ccs_encrypt_32
		} else {
			Code::Ccs_encrypt_16
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmCcs_hash for CodeAssembler {
	fn ccs_hash(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Ccs_hash_64
		} else if self.bitness() >= 32 {
			Code::Ccs_hash_32
		} else {
			Code::Ccs_hash_16
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmCdq for CodeAssembler {
	#[inline]
	fn cdq(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Cdq))
	}
}

#[rustfmt::skip]
impl CodeAsmCdqe for CodeAssembler {
	#[inline]
	fn cdqe(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Cdqe))
	}
}

#[rustfmt::skip]
impl CodeAsmCl1invmb for CodeAssembler {
	#[inline]
	fn cl1invmb(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Cl1invmb))
	}
}

#[rustfmt::skip]
impl CodeAsmClac for CodeAssembler {
	#[inline]
	fn clac(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Clac))
	}
}

#[rustfmt::skip]
impl CodeAsmClc for CodeAssembler {
	#[inline]
	fn clc(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Clc))
	}
}

#[rustfmt::skip]
impl CodeAsmCld for CodeAssembler {
	#[inline]
	fn cld(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Cld))
	}
}

#[rustfmt::skip]
impl CodeAsmCldemote<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cldemote(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Cldemote_m8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmClflush<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn clflush(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Clflush_m8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmClflushopt<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn clflushopt(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Clflushopt_m8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmClgi for CodeAssembler {
	#[inline]
	fn clgi(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Clgi))
	}
}

#[rustfmt::skip]
impl CodeAsmCli for CodeAssembler {
	#[inline]
	fn cli(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Cli))
	}
}

#[rustfmt::skip]
impl CodeAsmClrssbsy<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn clrssbsy(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Clrssbsy_m64, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmClts for CodeAssembler {
	#[inline]
	fn clts(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Clts))
	}
}

#[rustfmt::skip]
impl CodeAsmClui for CodeAssembler {
	#[inline]
	fn clui(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Clui))
	}
}

#[rustfmt::skip]
impl CodeAsmClwb<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn clwb(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Clwb_m8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmClzero for CodeAssembler {
	fn clzero(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Clzeroq
		} else if self.bitness() >= 32 {
			Code::Clzerod
		} else {
			Code::Clzerow
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmCmc for CodeAssembler {
	#[inline]
	fn cmc(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Cmc))
	}
}

#[rustfmt::skip]
impl CodeAsmCmova<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmova(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmova_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmova<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmova(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmova_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmova<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmova(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmova_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmova<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmova(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmova_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmova<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmova(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmova_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmova<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmova(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmova_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovae<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovae(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovae_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovae<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovae(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovae_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovae<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovae(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovae_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovae<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovae(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovae_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovae<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovae(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovae_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovae<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovae(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovae_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovb<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovb(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovb_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovb<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovb(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovb_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovb<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovb(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovb_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovb<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovb(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovb_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovb<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovb(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovb_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovb<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovb(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovb_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovbe<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovbe(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovbe_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovbe<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovbe(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovbe_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovbe<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovbe(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovbe_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovbe<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovbe(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovbe_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovbe<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovbe(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovbe_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovbe<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovbe(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovbe_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmove<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmove(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmove_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmove<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmove(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmove_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmove<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmove(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmove_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmove<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmove(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmove_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmove<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmove(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmove_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmove<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmove(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmove_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovg<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovg(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovg_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovg<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovg(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovg_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovg<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovg(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovg_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovg<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovg(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovg_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovg<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovg(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovg_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovg<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovg(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovg_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovge<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovge(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovge_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovge<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovge(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovge_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovge<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovge(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovge_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovge<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovge(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovge_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovge<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovge(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovge_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovge<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovge(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovge_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovl<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovl(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovl_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovl<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovl(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovl_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovl<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovl(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovl_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovl<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovl(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovl_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovl<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovl(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovl_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovl<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovl(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovl_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovle<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovle(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovle_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovle<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovle(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovle_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovle<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovle(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovle_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovle<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovle(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovle_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovle<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovle(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovle_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovle<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovle(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovle_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovne<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovne(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovne_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovne<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovne(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovne_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovne<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovne(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovne_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovne<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovne(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovne_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovne<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovne(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovne_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovne<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovne(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovne_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovno<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovno(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovno_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovno<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovno(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovno_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovno<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovno(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovno_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovno<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovno(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovno_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovno<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovno(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovno_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovno<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovno(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovno_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnp<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovnp(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovnp_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnp<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovnp(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovnp_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnp<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovnp(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovnp_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnp<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovnp(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovnp_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnp<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovnp(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovnp_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnp<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovnp(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovnp_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovns<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovns(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovns_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovns<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovns(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovns_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovns<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovns(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovns_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovns<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovns(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovns_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovns<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovns(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovns_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovns<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovns(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovns_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovo<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovo(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovo_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovo<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovo(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovo_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovo<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovo(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovo_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovo<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovo(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovo_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovo<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovo(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovo_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovo<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovo(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovo_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovp<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovp(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovp_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovp<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovp(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovp_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovp<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovp(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovp_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovp<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovp(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovp_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovp<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovp(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovp_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovp<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovp(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovp_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovs<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovs(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovs_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovs<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovs(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovs_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovs<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovs(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovs_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovs<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovs(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovs_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovs<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovs(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovs_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovs<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovs(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovs_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<__AsmRegister8, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn cmp(&mut self, op0: __AsmRegister8, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmp_rm8_r8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<__AsmMemoryOperand, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn cmp(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmp_rm8_r8, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmp(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmp_rm16_r16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<__AsmMemoryOperand, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmp(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmp_rm16_r16, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmp(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmp_rm32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<__AsmMemoryOperand, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmp(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmp_rm32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmp(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmp_rm64_r64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<__AsmMemoryOperand, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmp(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmp_rm64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<__AsmRegister8, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmp(&mut self, op0: __AsmRegister8, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmp_r8_rm8, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmp(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmp_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmp(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmp_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmp(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmp_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<__AsmRegister8, i32> for CodeAssembler {
	#[inline]
	fn cmp(&mut self, op0: __AsmRegister8, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AL { Code::Cmp_AL_imm8 } else { Code::Cmp_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<__AsmRegister16, i32> for CodeAssembler {
	fn cmp(&mut self, op0: __AsmRegister16, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AX {
			Code::Cmp_AX_imm16
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Cmp_rm16_imm8
		} else {
			Code::Cmp_rm16_imm16
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<__AsmRegister32, i32> for CodeAssembler {
	fn cmp(&mut self, op0: __AsmRegister32, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::EAX {
			Code::Cmp_EAX_imm32
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Cmp_rm32_imm8
		} else {
			Code::Cmp_rm32_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<__AsmRegister64, i32> for CodeAssembler {
	fn cmp(&mut self, op0: __AsmRegister64, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::RAX {
			Code::Cmp_RAX_imm32
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Cmp_rm64_imm8
		} else {
			Code::Cmp_rm64_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<__AsmMemoryOperand, i32> for CodeAssembler {
	fn cmp(&mut self, op0: __AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Cmp_rm64_imm8 } else { Code::Cmp_rm64_imm32 }
		} else if op0.size() == MemoryOperandSize::Dword {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Cmp_rm32_imm8 } else { Code::Cmp_rm32_imm32 }
		} else if op0.size() == MemoryOperandSize::Word {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Cmp_rm16_imm8 } else { Code::Cmp_rm16_imm16 }
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Cmp_rm8_imm8
		} else {
			return Err(IcedError::new("cmp: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<__AsmRegister8, u32> for CodeAssembler {
	#[inline]
	fn cmp(&mut self, op0: __AsmRegister8, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AL { Code::Cmp_AL_imm8 } else { Code::Cmp_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<__AsmRegister16, u32> for CodeAssembler {
	fn cmp(&mut self, op0: __AsmRegister16, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AX {
			Code::Cmp_AX_imm16
		} else if op1 <= i8::MAX as u32 || (0xFF80 <= op1 && op1 <= 0xFFFF) {
			Code::Cmp_rm16_imm8
		} else {
			Code::Cmp_rm16_imm16
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<__AsmRegister32, u32> for CodeAssembler {
	fn cmp(&mut self, op0: __AsmRegister32, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::EAX {
			Code::Cmp_EAX_imm32
		} else if op1 <= i8::MAX as u32 || 0xFFFF_FF80 <= op1 {
			Code::Cmp_rm32_imm8
		} else {
			Code::Cmp_rm32_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<__AsmMemoryOperand, u32> for CodeAssembler {
	fn cmp(&mut self, op0: __AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Dword {
			if op1 <= i8::MAX as u32 || 0xFFFF_FF80 <= op1 { Code::Cmp_rm32_imm8 } else { Code::Cmp_rm32_imm32 }
		} else if op0.size() == MemoryOperandSize::Word {
			if op1 <= i8::MAX as u32 || (0xFF80 <= op1 && op1 <= 0xFFFF) { Code::Cmp_rm16_imm8 } else { Code::Cmp_rm16_imm16 }
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Cmp_rm8_imm8
		} else {
			return Err(IcedError::new("cmp: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpeqpd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpeqpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmppd<__AsmRegisterXmm, __AsmRegisterXmm, i32>>::cmppd(self, op0, op1, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpeqpd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpeqpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmppd<__AsmRegisterXmm, __AsmMemoryOperand, i32>>::cmppd(self, op0, op1, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpeqps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpeqps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpps<__AsmRegisterXmm, __AsmRegisterXmm, i32>>::cmpps(self, op0, op1, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpeqps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpeqps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpps<__AsmRegisterXmm, __AsmMemoryOperand, i32>>::cmpps(self, op0, op1, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpeqsd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpeqsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpsd3<__AsmRegisterXmm, __AsmRegisterXmm, i32>>::cmpsd_3(self, op0, op1, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpeqsd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpeqsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpsd3<__AsmRegisterXmm, __AsmMemoryOperand, i32>>::cmpsd_3(self, op0, op1, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpeqss<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpeqss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpss<__AsmRegisterXmm, __AsmRegisterXmm, i32>>::cmpss(self, op0, op1, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpeqss<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpeqss(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpss<__AsmRegisterXmm, __AsmMemoryOperand, i32>>::cmpss(self, op0, op1, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmCmplepd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmplepd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmppd<__AsmRegisterXmm, __AsmRegisterXmm, i32>>::cmppd(self, op0, op1, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmCmplepd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmplepd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmppd<__AsmRegisterXmm, __AsmMemoryOperand, i32>>::cmppd(self, op0, op1, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpleps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpleps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpps<__AsmRegisterXmm, __AsmRegisterXmm, i32>>::cmpps(self, op0, op1, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpleps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpleps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpps<__AsmRegisterXmm, __AsmMemoryOperand, i32>>::cmpps(self, op0, op1, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmCmplesd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmplesd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpsd3<__AsmRegisterXmm, __AsmRegisterXmm, i32>>::cmpsd_3(self, op0, op1, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmCmplesd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmplesd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpsd3<__AsmRegisterXmm, __AsmMemoryOperand, i32>>::cmpsd_3(self, op0, op1, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpless<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpless(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpss<__AsmRegisterXmm, __AsmRegisterXmm, i32>>::cmpss(self, op0, op1, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpless<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpless(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpss<__AsmRegisterXmm, __AsmMemoryOperand, i32>>::cmpss(self, op0, op1, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpltpd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpltpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmppd<__AsmRegisterXmm, __AsmRegisterXmm, i32>>::cmppd(self, op0, op1, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpltpd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpltpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmppd<__AsmRegisterXmm, __AsmMemoryOperand, i32>>::cmppd(self, op0, op1, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpltps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpltps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpps<__AsmRegisterXmm, __AsmRegisterXmm, i32>>::cmpps(self, op0, op1, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpltps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpltps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpps<__AsmRegisterXmm, __AsmMemoryOperand, i32>>::cmpps(self, op0, op1, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpltsd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpltsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpsd3<__AsmRegisterXmm, __AsmRegisterXmm, i32>>::cmpsd_3(self, op0, op1, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpltsd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpltsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpsd3<__AsmRegisterXmm, __AsmMemoryOperand, i32>>::cmpsd_3(self, op0, op1, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpltss<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpltss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpss<__AsmRegisterXmm, __AsmRegisterXmm, i32>>::cmpss(self, op0, op1, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpltss<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpltss(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpss<__AsmRegisterXmm, __AsmMemoryOperand, i32>>::cmpss(self, op0, op1, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpneqpd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpneqpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmppd<__AsmRegisterXmm, __AsmRegisterXmm, i32>>::cmppd(self, op0, op1, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpneqpd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpneqpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmppd<__AsmRegisterXmm, __AsmMemoryOperand, i32>>::cmppd(self, op0, op1, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpneqps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpneqps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpps<__AsmRegisterXmm, __AsmRegisterXmm, i32>>::cmpps(self, op0, op1, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpneqps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpneqps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpps<__AsmRegisterXmm, __AsmMemoryOperand, i32>>::cmpps(self, op0, op1, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpneqsd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpneqsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpsd3<__AsmRegisterXmm, __AsmRegisterXmm, i32>>::cmpsd_3(self, op0, op1, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpneqsd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpneqsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpsd3<__AsmRegisterXmm, __AsmMemoryOperand, i32>>::cmpsd_3(self, op0, op1, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpneqss<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpneqss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpss<__AsmRegisterXmm, __AsmRegisterXmm, i32>>::cmpss(self, op0, op1, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpneqss<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpneqss(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpss<__AsmRegisterXmm, __AsmMemoryOperand, i32>>::cmpss(self, op0, op1, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnlepd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpnlepd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmppd<__AsmRegisterXmm, __AsmRegisterXmm, i32>>::cmppd(self, op0, op1, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnlepd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpnlepd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmppd<__AsmRegisterXmm, __AsmMemoryOperand, i32>>::cmppd(self, op0, op1, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnleps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpnleps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpps<__AsmRegisterXmm, __AsmRegisterXmm, i32>>::cmpps(self, op0, op1, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnleps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpnleps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpps<__AsmRegisterXmm, __AsmMemoryOperand, i32>>::cmpps(self, op0, op1, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnlesd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpnlesd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpsd3<__AsmRegisterXmm, __AsmRegisterXmm, i32>>::cmpsd_3(self, op0, op1, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnlesd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpnlesd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpsd3<__AsmRegisterXmm, __AsmMemoryOperand, i32>>::cmpsd_3(self, op0, op1, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnless<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpnless(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpss<__AsmRegisterXmm, __AsmRegisterXmm, i32>>::cmpss(self, op0, op1, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnless<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpnless(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpss<__AsmRegisterXmm, __AsmMemoryOperand, i32>>::cmpss(self, op0, op1, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnltpd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpnltpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmppd<__AsmRegisterXmm, __AsmRegisterXmm, i32>>::cmppd(self, op0, op1, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnltpd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpnltpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmppd<__AsmRegisterXmm, __AsmMemoryOperand, i32>>::cmppd(self, op0, op1, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnltps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpnltps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpps<__AsmRegisterXmm, __AsmRegisterXmm, i32>>::cmpps(self, op0, op1, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnltps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpnltps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpps<__AsmRegisterXmm, __AsmMemoryOperand, i32>>::cmpps(self, op0, op1, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnltsd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpnltsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpsd3<__AsmRegisterXmm, __AsmRegisterXmm, i32>>::cmpsd_3(self, op0, op1, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnltsd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpnltsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpsd3<__AsmRegisterXmm, __AsmMemoryOperand, i32>>::cmpsd_3(self, op0, op1, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnltss<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpnltss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpss<__AsmRegisterXmm, __AsmRegisterXmm, i32>>::cmpss(self, op0, op1, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnltss<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpnltss(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpss<__AsmRegisterXmm, __AsmMemoryOperand, i32>>::cmpss(self, op0, op1, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpordpd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpordpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmppd<__AsmRegisterXmm, __AsmRegisterXmm, i32>>::cmppd(self, op0, op1, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpordpd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpordpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmppd<__AsmRegisterXmm, __AsmMemoryOperand, i32>>::cmppd(self, op0, op1, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpordps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpordps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpps<__AsmRegisterXmm, __AsmRegisterXmm, i32>>::cmpps(self, op0, op1, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpordps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpordps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpps<__AsmRegisterXmm, __AsmMemoryOperand, i32>>::cmpps(self, op0, op1, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpordsd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpordsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpsd3<__AsmRegisterXmm, __AsmRegisterXmm, i32>>::cmpsd_3(self, op0, op1, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpordsd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpordsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpsd3<__AsmRegisterXmm, __AsmMemoryOperand, i32>>::cmpsd_3(self, op0, op1, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpordss<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpordss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpss<__AsmRegisterXmm, __AsmRegisterXmm, i32>>::cmpss(self, op0, op1, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpordss<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpordss(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpss<__AsmRegisterXmm, __AsmMemoryOperand, i32>>::cmpss(self, op0, op1, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmCmppd<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn cmppd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Cmppd_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmppd<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn cmppd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Cmppd_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmppd<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn cmppd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Cmppd_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmppd<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn cmppd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Cmppd_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpps<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn cmpps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Cmpps_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpps<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn cmpps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Cmpps_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpps<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn cmpps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Cmpps_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpps<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn cmpps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Cmpps_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpsb for CodeAssembler {
	#[inline]
	fn cmpsb(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_cmpsb(self.bitness(), Register::None, RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpsd for CodeAssembler {
	#[inline]
	fn cmpsd(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_cmpsd(self.bitness(), Register::None, RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpsd3<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn cmpsd_3(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Cmpsd_xmm_xmmm64_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpsd3<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn cmpsd_3(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Cmpsd_xmm_xmmm64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpsd3<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn cmpsd_3(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Cmpsd_xmm_xmmm64_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpsd3<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn cmpsd_3(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Cmpsd_xmm_xmmm64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpsq for CodeAssembler {
	#[inline]
	fn cmpsq(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_cmpsq(self.bitness(), Register::None, RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpss<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn cmpss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Cmpss_xmm_xmmm32_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpss<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn cmpss(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Cmpss_xmm_xmmm32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpss<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn cmpss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Cmpss_xmm_xmmm32_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpss<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn cmpss(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Cmpss_xmm_xmmm32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpsw for CodeAssembler {
	#[inline]
	fn cmpsw(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_cmpsw(self.bitness(), Register::None, RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpunordpd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpunordpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmppd<__AsmRegisterXmm, __AsmRegisterXmm, i32>>::cmppd(self, op0, op1, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpunordpd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpunordpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmppd<__AsmRegisterXmm, __AsmMemoryOperand, i32>>::cmppd(self, op0, op1, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpunordps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpunordps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpps<__AsmRegisterXmm, __AsmRegisterXmm, i32>>::cmpps(self, op0, op1, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpunordps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpunordps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpps<__AsmRegisterXmm, __AsmMemoryOperand, i32>>::cmpps(self, op0, op1, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpunordsd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpunordsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpsd3<__AsmRegisterXmm, __AsmRegisterXmm, i32>>::cmpsd_3(self, op0, op1, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpunordsd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpunordsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpsd3<__AsmRegisterXmm, __AsmMemoryOperand, i32>>::cmpsd_3(self, op0, op1, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpunordss<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpunordss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpss<__AsmRegisterXmm, __AsmRegisterXmm, i32>>::cmpss(self, op0, op1, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpunordss<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpunordss(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpss<__AsmRegisterXmm, __AsmMemoryOperand, i32>>::cmpss(self, op0, op1, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpxchg<__AsmRegister8, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn cmpxchg(&mut self, op0: __AsmRegister8, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmpxchg_rm8_r8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpxchg<__AsmMemoryOperand, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn cmpxchg(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmpxchg_rm8_r8, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpxchg<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmpxchg(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmpxchg_rm16_r16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpxchg<__AsmMemoryOperand, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmpxchg(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmpxchg_rm16_r16, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpxchg<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmpxchg(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmpxchg_rm32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpxchg<__AsmMemoryOperand, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmpxchg(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmpxchg_rm32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpxchg<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmpxchg(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmpxchg_rm64_r64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpxchg<__AsmMemoryOperand, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmpxchg(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmpxchg_rm64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpxchg16b<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpxchg16b(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Cmpxchg16b_m128, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpxchg8b<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpxchg8b(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Cmpxchg8b_m64, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmComisd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn comisd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Comisd_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmComisd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn comisd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Comisd_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmComiss<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn comiss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Comiss_xmm_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmComiss<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn comiss(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Comiss_xmm_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCpu_read for CodeAssembler {
	#[inline]
	fn cpu_read(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Cpu_read))
	}
}

#[rustfmt::skip]
impl CodeAsmCpu_write for CodeAssembler {
	#[inline]
	fn cpu_write(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Cpu_write))
	}
}

#[rustfmt::skip]
impl CodeAsmCpuid for CodeAssembler {
	#[inline]
	fn cpuid(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Cpuid))
	}
}

#[rustfmt::skip]
impl CodeAsmCqo for CodeAssembler {
	#[inline]
	fn cqo(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Cqo))
	}
}

#[rustfmt::skip]
impl CodeAsmCrc32<__AsmRegister32, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn crc32(&mut self, op0: __AsmRegister32, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Crc32_r32_rm8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCrc32<__AsmRegister64, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn crc32(&mut self, op0: __AsmRegister64, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Crc32_r64_rm8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCrc32<__AsmRegister32, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn crc32(&mut self, op0: __AsmRegister32, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Crc32_r32_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCrc32<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn crc32(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Crc32_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCrc32<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn crc32(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Crc32_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCrc32<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	fn crc32(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.size() == MemoryOperandSize::Dword {
			Code::Crc32_r32_rm32
		} else if op1.size() == MemoryOperandSize::Word {
			Code::Crc32_r32_rm16
		} else if op1.size() == MemoryOperandSize::Byte {
			Code::Crc32_r32_rm8
		} else {
			return Err(IcedError::new("crc32: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCrc32<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	fn crc32(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.size() == MemoryOperandSize::Qword {
			Code::Crc32_r64_rm64
		} else if op1.size() == MemoryOperandSize::Byte {
			Code::Crc32_r64_rm8
		} else {
			return Err(IcedError::new("crc32: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtdq2pd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvtdq2pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtdq2pd_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtdq2pd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvtdq2pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtdq2pd_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtdq2ps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvtdq2ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtdq2ps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtdq2ps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvtdq2ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtdq2ps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtpd2dq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvtpd2dq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtpd2dq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtpd2dq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvtpd2dq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtpd2dq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtpd2pi<__AsmRegisterMm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvtpd2pi(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtpd2pi_mm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtpd2pi<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvtpd2pi(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtpd2pi_mm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtpd2ps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvtpd2ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtpd2ps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtpd2ps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvtpd2ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtpd2ps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtpi2pd<__AsmRegisterXmm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn cvtpi2pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtpi2pd_xmm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtpi2pd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvtpi2pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtpi2pd_xmm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtpi2ps<__AsmRegisterXmm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn cvtpi2ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtpi2ps_xmm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtpi2ps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvtpi2ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtpi2ps_xmm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtps2dq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvtps2dq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtps2dq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtps2dq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvtps2dq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtps2dq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtps2pd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvtps2pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtps2pd_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtps2pd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvtps2pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtps2pd_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtps2pi<__AsmRegisterMm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvtps2pi(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtps2pi_mm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtps2pi<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvtps2pi(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtps2pi_mm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtsd2si<__AsmRegister32, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvtsd2si(&mut self, op0: __AsmRegister32, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtsd2si_r32_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtsd2si<__AsmRegister64, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvtsd2si(&mut self, op0: __AsmRegister64, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtsd2si_r64_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtsd2si<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvtsd2si(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtsd2si_r32_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtsd2si<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvtsd2si(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtsd2si_r64_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtsd2ss<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvtsd2ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtsd2ss_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtsd2ss<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvtsd2ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtsd2ss_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtsi2sd<__AsmRegisterXmm, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn cvtsi2sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtsi2sd_xmm_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtsi2sd<__AsmRegisterXmm, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn cvtsi2sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtsi2sd_xmm_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtsi2sd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn cvtsi2sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.size() == MemoryOperandSize::Qword {
			Code::Cvtsi2sd_xmm_rm64
		} else if op1.size() == MemoryOperandSize::Dword {
			Code::Cvtsi2sd_xmm_rm32
		} else {
			return Err(IcedError::new("cvtsi2sd: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtsi2ss<__AsmRegisterXmm, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn cvtsi2ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtsi2ss_xmm_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtsi2ss<__AsmRegisterXmm, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn cvtsi2ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtsi2ss_xmm_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtsi2ss<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn cvtsi2ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.size() == MemoryOperandSize::Qword {
			Code::Cvtsi2ss_xmm_rm64
		} else if op1.size() == MemoryOperandSize::Dword {
			Code::Cvtsi2ss_xmm_rm32
		} else {
			return Err(IcedError::new("cvtsi2ss: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtss2sd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvtss2sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtss2sd_xmm_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtss2sd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvtss2sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtss2sd_xmm_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtss2si<__AsmRegister32, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvtss2si(&mut self, op0: __AsmRegister32, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtss2si_r32_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtss2si<__AsmRegister64, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvtss2si(&mut self, op0: __AsmRegister64, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtss2si_r64_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtss2si<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvtss2si(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtss2si_r32_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtss2si<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvtss2si(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtss2si_r64_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvttpd2dq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvttpd2dq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvttpd2dq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvttpd2dq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvttpd2dq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvttpd2dq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvttpd2pi<__AsmRegisterMm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvttpd2pi(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvttpd2pi_mm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvttpd2pi<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvttpd2pi(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvttpd2pi_mm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvttps2dq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvttps2dq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvttps2dq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvttps2dq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvttps2dq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvttps2dq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvttps2pi<__AsmRegisterMm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvttps2pi(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvttps2pi_mm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvttps2pi<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvttps2pi(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvttps2pi_mm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvttsd2si<__AsmRegister32, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvttsd2si(&mut self, op0: __AsmRegister32, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvttsd2si_r32_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvttsd2si<__AsmRegister64, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvttsd2si(&mut self, op0: __AsmRegister64, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvttsd2si_r64_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvttsd2si<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvttsd2si(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvttsd2si_r32_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvttsd2si<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvttsd2si(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvttsd2si_r64_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvttss2si<__AsmRegister32, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvttss2si(&mut self, op0: __AsmRegister32, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvttss2si_r32_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvttss2si<__AsmRegister64, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvttss2si(&mut self, op0: __AsmRegister64, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvttss2si_r64_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvttss2si<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvttss2si(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvttss2si_r32_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvttss2si<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvttss2si(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvttss2si_r64_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCwd for CodeAssembler {
	#[inline]
	fn cwd(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Cwd))
	}
}

#[rustfmt::skip]
impl CodeAsmCwde for CodeAssembler {
	#[inline]
	fn cwde(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Cwde))
	}
}

#[rustfmt::skip]
impl CodeAsmDaa for CodeAssembler {
	#[inline]
	fn daa(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Daa))
	}
}

#[rustfmt::skip]
impl CodeAsmDas for CodeAssembler {
	#[inline]
	fn das(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Das))
	}
}

#[rustfmt::skip]
impl CodeAsmDec<__AsmRegister8> for CodeAssembler {
	#[inline]
	fn dec(&mut self, op0: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Dec_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmDec<__AsmRegister16> for CodeAssembler {
	#[inline]
	fn dec(&mut self, op0: __AsmRegister16) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 { Code::Dec_rm16 } else { Code::Dec_r16 };
		self.add_instr(Instruction::with1(code, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmDec<__AsmRegister32> for CodeAssembler {
	#[inline]
	fn dec(&mut self, op0: __AsmRegister32) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 { Code::Dec_rm32 } else { Code::Dec_r32 };
		self.add_instr(Instruction::with1(code, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmDec<__AsmRegister64> for CodeAssembler {
	#[inline]
	fn dec(&mut self, op0: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Dec_rm64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmDec<__AsmMemoryOperand> for CodeAssembler {
	fn dec(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Dec_rm64
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Dec_rm32
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Dec_rm16
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Dec_rm8
		} else {
			return Err(IcedError::new("dec: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmDiv<__AsmRegister8> for CodeAssembler {
	#[inline]
	fn div(&mut self, op0: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Div_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmDiv<__AsmRegister16> for CodeAssembler {
	#[inline]
	fn div(&mut self, op0: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Div_rm16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmDiv<__AsmRegister32> for CodeAssembler {
	#[inline]
	fn div(&mut self, op0: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Div_rm32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmDiv<__AsmRegister64> for CodeAssembler {
	#[inline]
	fn div(&mut self, op0: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Div_rm64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmDiv<__AsmMemoryOperand> for CodeAssembler {
	fn div(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Div_rm64
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Div_rm32
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Div_rm16
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Div_rm8
		} else {
			return Err(IcedError::new("div: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmDivpd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn divpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Divpd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmDivpd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn divpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Divpd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmDivps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn divps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Divps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmDivps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn divps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Divps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmDivsd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn divsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Divsd_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmDivsd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn divsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Divsd_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmDivss<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn divss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Divss_xmm_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmDivss<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn divss(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Divss_xmm_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmDmint for CodeAssembler {
	#[inline]
	fn dmint(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Dmint))
	}
}

#[rustfmt::skip]
impl CodeAsmDppd<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn dppd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Dppd_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmDppd<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn dppd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Dppd_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmDppd<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn dppd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Dppd_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmDppd<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn dppd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Dppd_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmDpps<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn dpps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Dpps_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmDpps<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn dpps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Dpps_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmDpps<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn dpps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Dpps_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmDpps<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn dpps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Dpps_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmEmms for CodeAssembler {
	#[inline]
	fn emms(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Emms))
	}
}

#[rustfmt::skip]
impl CodeAsmEncls for CodeAssembler {
	#[inline]
	fn encls(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Encls))
	}
}

#[rustfmt::skip]
impl CodeAsmEnclu for CodeAssembler {
	#[inline]
	fn enclu(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Enclu))
	}
}

#[rustfmt::skip]
impl CodeAsmEnclv for CodeAssembler {
	#[inline]
	fn enclv(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Enclv))
	}
}

#[rustfmt::skip]
impl CodeAsmEncodekey128<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn encodekey128(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Encodekey128_r32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmEncodekey256<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn encodekey256(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Encodekey256_r32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmEndbr32 for CodeAssembler {
	#[inline]
	fn endbr32(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Endbr32))
	}
}

#[rustfmt::skip]
impl CodeAsmEndbr64 for CodeAssembler {
	#[inline]
	fn endbr64(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Endbr64))
	}
}

#[rustfmt::skip]
impl CodeAsmEnqcmd<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn enqcmd(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Enqcmd_r16_m512, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmEnqcmd<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn enqcmd(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Enqcmd_r32_m512, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmEnqcmd<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn enqcmd(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Enqcmd_r64_m512, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmEnqcmds<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn enqcmds(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Enqcmds_r16_m512, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmEnqcmds<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn enqcmds(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Enqcmds_r32_m512, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmEnqcmds<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn enqcmds(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Enqcmds_r64_m512, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmEnter<i32, i32> for CodeAssembler {
	fn enter(&mut self, op0: i32, op1: i32) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Enterq_imm16_imm8
		} else if self.bitness() >= 32 {
			Code::Enterd_imm16_imm8
		} else {
			Code::Enterw_imm16_imm8
		};
		self.add_instr(Instruction::with2(code, op0, op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmEnter<u32, u32> for CodeAssembler {
	fn enter(&mut self, op0: u32, op1: u32) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Enterq_imm16_imm8
		} else if self.bitness() >= 32 {
			Code::Enterd_imm16_imm8
		} else {
			Code::Enterw_imm16_imm8
		};
		self.add_instr(Instruction::with2(code, op0, op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmErets for CodeAssembler {
	#[inline]
	fn erets(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Erets))
	}
}

#[rustfmt::skip]
impl CodeAsmEretu for CodeAssembler {
	#[inline]
	fn eretu(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Eretu))
	}
}

#[rustfmt::skip]
impl CodeAsmExtractps<__AsmRegister32, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn extractps(&mut self, op0: __AsmRegister32, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Extractps_rm32_xmm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmExtractps<__AsmRegister64, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn extractps(&mut self, op0: __AsmRegister64, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Extractps_r64m32_xmm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmExtractps<__AsmMemoryOperand, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn extractps(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Extractps_rm32_xmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmExtractps<__AsmRegister32, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn extractps(&mut self, op0: __AsmRegister32, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Extractps_rm32_xmm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmExtractps<__AsmRegister64, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn extractps(&mut self, op0: __AsmRegister64, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Extractps_r64m32_xmm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmExtractps<__AsmMemoryOperand, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn extractps(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Extractps_rm32_xmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmExtrq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn extrq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Extrq_xmm_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmExtrq3<__AsmRegisterXmm, i32, i32> for CodeAssembler {
	#[inline]
	fn extrq_3(&mut self, op0: __AsmRegisterXmm, op1: i32, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Extrq_xmm_imm8_imm8, op0.register(), op1, op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmExtrq3<__AsmRegisterXmm, u32, u32> for CodeAssembler {
	#[inline]
	fn extrq_3(&mut self, op0: __AsmRegisterXmm, op1: u32, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Extrq_xmm_imm8_imm8, op0.register(), op1, op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmF2xm1 for CodeAssembler {
	#[inline]
	fn f2xm1(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::F2xm1))
	}
}

#[rustfmt::skip]
impl CodeAsmFabs for CodeAssembler {
	#[inline]
	fn fabs(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fabs))
	}
}

#[rustfmt::skip]
impl CodeAsmFadd<__AsmMemoryOperand> for CodeAssembler {
	fn fadd(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Fadd_m64fp
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Fadd_m32fp
		} else {
			return Err(IcedError::new("fadd: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFadd2<__AsmRegisterSt, __AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fadd_2(&mut self, op0: __AsmRegisterSt, op1: __AsmRegisterSt) -> Result<(), IcedError> {
		let code = if op0.register() == Register::ST0 { Code::Fadd_st0_sti } else { Code::Fadd_sti_st0 };
		self.add_instr(Instruction::with2(code, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFaddp<__AsmRegisterSt, __AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn faddp(&mut self, op0: __AsmRegisterSt, op1: __AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Faddp_sti_st0, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFbld<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn fbld(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fbld_m80bcd, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFbstp<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn fbstp(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fbstp_m80bcd, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFchs for CodeAssembler {
	#[inline]
	fn fchs(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fchs))
	}
}

#[rustfmt::skip]
impl CodeAsmFclex for CodeAssembler {
	#[inline]
	fn fclex(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fclex))
	}
}

#[rustfmt::skip]
impl CodeAsmFcmovb<__AsmRegisterSt, __AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fcmovb(&mut self, op0: __AsmRegisterSt, op1: __AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fcmovb_st0_sti, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFcmovbe<__AsmRegisterSt, __AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fcmovbe(&mut self, op0: __AsmRegisterSt, op1: __AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fcmovbe_st0_sti, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFcmove<__AsmRegisterSt, __AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fcmove(&mut self, op0: __AsmRegisterSt, op1: __AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fcmove_st0_sti, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFcmovnb<__AsmRegisterSt, __AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fcmovnb(&mut self, op0: __AsmRegisterSt, op1: __AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fcmovnb_st0_sti, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFcmovnbe<__AsmRegisterSt, __AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fcmovnbe(&mut self, op0: __AsmRegisterSt, op1: __AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fcmovnbe_st0_sti, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFcmovne<__AsmRegisterSt, __AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fcmovne(&mut self, op0: __AsmRegisterSt, op1: __AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fcmovne_st0_sti, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFcmovnu<__AsmRegisterSt, __AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fcmovnu(&mut self, op0: __AsmRegisterSt, op1: __AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fcmovnu_st0_sti, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFcmovu<__AsmRegisterSt, __AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fcmovu(&mut self, op0: __AsmRegisterSt, op1: __AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fcmovu_st0_sti, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFcom<__AsmMemoryOperand> for CodeAssembler {
	fn fcom(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Fcom_m64fp
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Fcom_m32fp
		} else {
			return Err(IcedError::new("fcom: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFcom2<__AsmRegisterSt, __AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fcom_2(&mut self, op0: __AsmRegisterSt, op1: __AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fcom_st0_sti, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFcomi<__AsmRegisterSt, __AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fcomi(&mut self, op0: __AsmRegisterSt, op1: __AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fcomi_st0_sti, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFcomip<__AsmRegisterSt, __AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fcomip(&mut self, op0: __AsmRegisterSt, op1: __AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fcomip_st0_sti, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFcomp<__AsmMemoryOperand> for CodeAssembler {
	fn fcomp(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Fcomp_m64fp
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Fcomp_m32fp
		} else {
			return Err(IcedError::new("fcomp: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFcomp2<__AsmRegisterSt, __AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fcomp_2(&mut self, op0: __AsmRegisterSt, op1: __AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fcomp_st0_sti, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFcompp for CodeAssembler {
	#[inline]
	fn fcompp(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fcompp))
	}
}

#[rustfmt::skip]
impl CodeAsmFcos for CodeAssembler {
	#[inline]
	fn fcos(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fcos))
	}
}

#[rustfmt::skip]
impl CodeAsmFdecstp for CodeAssembler {
	#[inline]
	fn fdecstp(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fdecstp))
	}
}

#[rustfmt::skip]
impl CodeAsmFdisi for CodeAssembler {
	#[inline]
	fn fdisi(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fdisi))
	}
}

#[rustfmt::skip]
impl CodeAsmFdiv<__AsmMemoryOperand> for CodeAssembler {
	fn fdiv(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Fdiv_m64fp
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Fdiv_m32fp
		} else {
			return Err(IcedError::new("fdiv: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFdiv2<__AsmRegisterSt, __AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fdiv_2(&mut self, op0: __AsmRegisterSt, op1: __AsmRegisterSt) -> Result<(), IcedError> {
		let code = if op0.register() == Register::ST0 { Code::Fdiv_st0_sti } else { Code::Fdiv_sti_st0 };
		self.add_instr(Instruction::with2(code, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFdivp<__AsmRegisterSt, __AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fdivp(&mut self, op0: __AsmRegisterSt, op1: __AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fdivp_sti_st0, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFdivr<__AsmMemoryOperand> for CodeAssembler {
	fn fdivr(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Fdivr_m64fp
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Fdivr_m32fp
		} else {
			return Err(IcedError::new("fdivr: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFdivr2<__AsmRegisterSt, __AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fdivr_2(&mut self, op0: __AsmRegisterSt, op1: __AsmRegisterSt) -> Result<(), IcedError> {
		let code = if op0.register() == Register::ST0 { Code::Fdivr_st0_sti } else { Code::Fdivr_sti_st0 };
		self.add_instr(Instruction::with2(code, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFdivrp<__AsmRegisterSt, __AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fdivrp(&mut self, op0: __AsmRegisterSt, op1: __AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fdivrp_sti_st0, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFemms for CodeAssembler {
	#[inline]
	fn femms(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Femms))
	}
}

#[rustfmt::skip]
impl CodeAsmFeni for CodeAssembler {
	#[inline]
	fn feni(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Feni))
	}
}

#[rustfmt::skip]
impl CodeAsmFfree<__AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn ffree(&mut self, op0: __AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Ffree_sti, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFfreep<__AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn ffreep(&mut self, op0: __AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Ffreep_sti, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFiadd<__AsmMemoryOperand> for CodeAssembler {
	fn fiadd(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Dword {
			Code::Fiadd_m32int
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Fiadd_m16int
		} else {
			return Err(IcedError::new("fiadd: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFicom<__AsmMemoryOperand> for CodeAssembler {
	fn ficom(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Dword {
			Code::Ficom_m32int
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Ficom_m16int
		} else {
			return Err(IcedError::new("ficom: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFicomp<__AsmMemoryOperand> for CodeAssembler {
	fn ficomp(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Dword {
			Code::Ficomp_m32int
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Ficomp_m16int
		} else {
			return Err(IcedError::new("ficomp: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFidiv<__AsmMemoryOperand> for CodeAssembler {
	fn fidiv(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Dword {
			Code::Fidiv_m32int
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Fidiv_m16int
		} else {
			return Err(IcedError::new("fidiv: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFidivr<__AsmMemoryOperand> for CodeAssembler {
	fn fidivr(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Dword {
			Code::Fidivr_m32int
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Fidivr_m16int
		} else {
			return Err(IcedError::new("fidivr: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFild<__AsmMemoryOperand> for CodeAssembler {
	fn fild(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Fild_m64int
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Fild_m32int
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Fild_m16int
		} else {
			return Err(IcedError::new("fild: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFimul<__AsmMemoryOperand> for CodeAssembler {
	fn fimul(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Dword {
			Code::Fimul_m32int
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Fimul_m16int
		} else {
			return Err(IcedError::new("fimul: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFincstp for CodeAssembler {
	#[inline]
	fn fincstp(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fincstp))
	}
}

#[rustfmt::skip]
impl CodeAsmFinit for CodeAssembler {
	#[inline]
	fn finit(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Finit))
	}
}

#[rustfmt::skip]
impl CodeAsmFist<__AsmMemoryOperand> for CodeAssembler {
	fn fist(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Dword {
			Code::Fist_m32int
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Fist_m16int
		} else {
			return Err(IcedError::new("fist: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFistp<__AsmMemoryOperand> for CodeAssembler {
	fn fistp(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Fistp_m64int
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Fistp_m32int
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Fistp_m16int
		} else {
			return Err(IcedError::new("fistp: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFisttp<__AsmMemoryOperand> for CodeAssembler {
	fn fisttp(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Fisttp_m64int
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Fisttp_m32int
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Fisttp_m16int
		} else {
			return Err(IcedError::new("fisttp: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFisub<__AsmMemoryOperand> for CodeAssembler {
	fn fisub(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Dword {
			Code::Fisub_m32int
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Fisub_m16int
		} else {
			return Err(IcedError::new("fisub: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFisubr<__AsmMemoryOperand> for CodeAssembler {
	fn fisubr(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Dword {
			Code::Fisubr_m32int
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Fisubr_m16int
		} else {
			return Err(IcedError::new("fisubr: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFld<__AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fld(&mut self, op0: __AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fld_sti, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFld<__AsmMemoryOperand> for CodeAssembler {
	fn fld(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Tbyte {
			Code::Fld_m80fp
		} else if op0.size() == MemoryOperandSize::Qword {
			Code::Fld_m64fp
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Fld_m32fp
		} else {
			return Err(IcedError::new("fld: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFld1 for CodeAssembler {
	#[inline]
	fn fld1(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fld1))
	}
}

#[rustfmt::skip]
impl CodeAsmFldcw<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn fldcw(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fldcw_m2byte, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFldenv<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn fldenv(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Fldenv_m28byte } else { Code::Fldenv_m14byte };
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFldl2e for CodeAssembler {
	#[inline]
	fn fldl2e(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fldl2e))
	}
}

#[rustfmt::skip]
impl CodeAsmFldl2t for CodeAssembler {
	#[inline]
	fn fldl2t(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fldl2t))
	}
}

#[rustfmt::skip]
impl CodeAsmFldlg2 for CodeAssembler {
	#[inline]
	fn fldlg2(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fldlg2))
	}
}

#[rustfmt::skip]
impl CodeAsmFldln2 for CodeAssembler {
	#[inline]
	fn fldln2(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fldln2))
	}
}

#[rustfmt::skip]
impl CodeAsmFldpi for CodeAssembler {
	#[inline]
	fn fldpi(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fldpi))
	}
}

#[rustfmt::skip]
impl CodeAsmFldz for CodeAssembler {
	#[inline]
	fn fldz(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fldz))
	}
}

#[rustfmt::skip]
impl CodeAsmFmul<__AsmMemoryOperand> for CodeAssembler {
	fn fmul(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Fmul_m64fp
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Fmul_m32fp
		} else {
			return Err(IcedError::new("fmul: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFmul2<__AsmRegisterSt, __AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fmul_2(&mut self, op0: __AsmRegisterSt, op1: __AsmRegisterSt) -> Result<(), IcedError> {
		let code = if op0.register() == Register::ST0 { Code::Fmul_st0_sti } else { Code::Fmul_sti_st0 };
		self.add_instr(Instruction::with2(code, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFmulp<__AsmRegisterSt, __AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fmulp(&mut self, op0: __AsmRegisterSt, op1: __AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fmulp_sti_st0, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFnclex for CodeAssembler {
	#[inline]
	fn fnclex(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fnclex))
	}
}

#[rustfmt::skip]
impl CodeAsmFndisi for CodeAssembler {
	#[inline]
	fn fndisi(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fndisi))
	}
}

#[rustfmt::skip]
impl CodeAsmFneni for CodeAssembler {
	#[inline]
	fn fneni(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fneni))
	}
}

#[rustfmt::skip]
impl CodeAsmFninit for CodeAssembler {
	#[inline]
	fn fninit(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fninit))
	}
}

#[rustfmt::skip]
impl CodeAsmFnop for CodeAssembler {
	#[inline]
	fn fnop(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fnop))
	}
}

#[rustfmt::skip]
impl CodeAsmFnsave<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn fnsave(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Fnsave_m108byte } else { Code::Fnsave_m94byte };
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFnsetpm for CodeAssembler {
	#[inline]
	fn fnsetpm(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fnsetpm))
	}
}

#[rustfmt::skip]
impl CodeAsmFnstcw<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn fnstcw(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fnstcw_m2byte, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFnstdw<__AsmRegister16> for CodeAssembler {
	#[inline]
	fn fnstdw(&mut self, op0: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fnstdw_AX, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFnstenv<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn fnstenv(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Fnstenv_m28byte } else { Code::Fnstenv_m14byte };
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFnstsg<__AsmRegister16> for CodeAssembler {
	#[inline]
	fn fnstsg(&mut self, op0: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fnstsg_AX, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFnstsw<__AsmRegister16> for CodeAssembler {
	#[inline]
	fn fnstsw(&mut self, op0: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fnstsw_AX, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFnstsw<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn fnstsw(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fnstsw_m2byte, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFpatan for CodeAssembler {
	#[inline]
	fn fpatan(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fpatan))
	}
}

#[rustfmt::skip]
impl CodeAsmFprem for CodeAssembler {
	#[inline]
	fn fprem(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fprem))
	}
}

#[rustfmt::skip]
impl CodeAsmFprem1 for CodeAssembler {
	#[inline]
	fn fprem1(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fprem1))
	}
}

#[rustfmt::skip]
impl CodeAsmFptan for CodeAssembler {
	#[inline]
	fn fptan(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fptan))
	}
}

#[rustfmt::skip]
impl CodeAsmFrndint for CodeAssembler {
	#[inline]
	fn frndint(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Frndint))
	}
}

#[rustfmt::skip]
impl CodeAsmFrstor<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn frstor(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Frstor_m108byte } else { Code::Frstor_m94byte };
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFrstpm for CodeAssembler {
	#[inline]
	fn frstpm(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Frstpm))
	}
}

#[rustfmt::skip]
impl CodeAsmFsave<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn fsave(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Fsave_m108byte } else { Code::Fsave_m94byte };
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFscale for CodeAssembler {
	#[inline]
	fn fscale(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fscale))
	}
}

#[rustfmt::skip]
impl CodeAsmFsetpm for CodeAssembler {
	#[inline]
	fn fsetpm(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fsetpm))
	}
}

#[rustfmt::skip]
impl CodeAsmFsin for CodeAssembler {
	#[inline]
	fn fsin(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fsin))
	}
}

#[rustfmt::skip]
impl CodeAsmFsincos for CodeAssembler {
	#[inline]
	fn fsincos(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fsincos))
	}
}

#[rustfmt::skip]
impl CodeAsmFsqrt for CodeAssembler {
	#[inline]
	fn fsqrt(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fsqrt))
	}
}

#[rustfmt::skip]
impl CodeAsmFst<__AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fst(&mut self, op0: __AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fst_sti, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFst<__AsmMemoryOperand> for CodeAssembler {
	fn fst(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Fst_m64fp
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Fst_m32fp
		} else {
			return Err(IcedError::new("fst: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFstcw<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn fstcw(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fstcw_m2byte, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFstdw<__AsmRegister16> for CodeAssembler {
	#[inline]
	fn fstdw(&mut self, op0: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fstdw_AX, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFstenv<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn fstenv(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Fstenv_m28byte } else { Code::Fstenv_m14byte };
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFstp<__AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fstp(&mut self, op0: __AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fstp_sti, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFstp<__AsmMemoryOperand> for CodeAssembler {
	fn fstp(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Tbyte {
			Code::Fstp_m80fp
		} else if op0.size() == MemoryOperandSize::Qword {
			Code::Fstp_m64fp
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Fstp_m32fp
		} else {
			return Err(IcedError::new("fstp: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFstpnce<__AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fstpnce(&mut self, op0: __AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fstpnce_sti, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFstsg<__AsmRegister16> for CodeAssembler {
	#[inline]
	fn fstsg(&mut self, op0: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fstsg_AX, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFstsw<__AsmRegister16> for CodeAssembler {
	#[inline]
	fn fstsw(&mut self, op0: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fstsw_AX, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFstsw<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn fstsw(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fstsw_m2byte, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFsub<__AsmMemoryOperand> for CodeAssembler {
	fn fsub(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Fsub_m64fp
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Fsub_m32fp
		} else {
			return Err(IcedError::new("fsub: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFsub2<__AsmRegisterSt, __AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fsub_2(&mut self, op0: __AsmRegisterSt, op1: __AsmRegisterSt) -> Result<(), IcedError> {
		let code = if op0.register() == Register::ST0 { Code::Fsub_st0_sti } else { Code::Fsub_sti_st0 };
		self.add_instr(Instruction::with2(code, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFsubp<__AsmRegisterSt, __AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fsubp(&mut self, op0: __AsmRegisterSt, op1: __AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fsubp_sti_st0, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFsubr<__AsmMemoryOperand> for CodeAssembler {
	fn fsubr(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Fsubr_m64fp
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Fsubr_m32fp
		} else {
			return Err(IcedError::new("fsubr: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFsubr2<__AsmRegisterSt, __AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fsubr_2(&mut self, op0: __AsmRegisterSt, op1: __AsmRegisterSt) -> Result<(), IcedError> {
		let code = if op0.register() == Register::ST0 { Code::Fsubr_st0_sti } else { Code::Fsubr_sti_st0 };
		self.add_instr(Instruction::with2(code, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFsubrp<__AsmRegisterSt, __AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fsubrp(&mut self, op0: __AsmRegisterSt, op1: __AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fsubrp_sti_st0, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFtst for CodeAssembler {
	#[inline]
	fn ftst(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Ftst))
	}
}

#[rustfmt::skip]
impl CodeAsmFucom<__AsmRegisterSt, __AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fucom(&mut self, op0: __AsmRegisterSt, op1: __AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fucom_st0_sti, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFucomi<__AsmRegisterSt, __AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fucomi(&mut self, op0: __AsmRegisterSt, op1: __AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fucomi_st0_sti, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFucomip<__AsmRegisterSt, __AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fucomip(&mut self, op0: __AsmRegisterSt, op1: __AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fucomip_st0_sti, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFucomp<__AsmRegisterSt, __AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fucomp(&mut self, op0: __AsmRegisterSt, op1: __AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fucomp_st0_sti, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFucompp for CodeAssembler {
	#[inline]
	fn fucompp(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fucompp))
	}
}

#[rustfmt::skip]
impl CodeAsmFxam for CodeAssembler {
	#[inline]
	fn fxam(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fxam))
	}
}

#[rustfmt::skip]
impl CodeAsmFxch<__AsmRegisterSt, __AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fxch(&mut self, op0: __AsmRegisterSt, op1: __AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fxch_st0_sti, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFxrstor<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn fxrstor(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fxrstor_m512byte, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFxrstor64<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn fxrstor64(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fxrstor64_m512byte, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFxsave<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn fxsave(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fxsave_m512byte, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFxsave64<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn fxsave64(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fxsave64_m512byte, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFxtract for CodeAssembler {
	#[inline]
	fn fxtract(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fxtract))
	}
}

#[rustfmt::skip]
impl CodeAsmFyl2x for CodeAssembler {
	#[inline]
	fn fyl2x(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fyl2x))
	}
}

#[rustfmt::skip]
impl CodeAsmFyl2xp1 for CodeAssembler {
	#[inline]
	fn fyl2xp1(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fyl2xp1))
	}
}

#[rustfmt::skip]
impl CodeAsmGetsec for CodeAssembler {
	#[inline]
	fn getsec(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Getsecd))
	}
}

#[rustfmt::skip]
impl CodeAsmGetsecq for CodeAssembler {
	#[inline]
	fn getsecq(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Getsecq))
	}
}

#[rustfmt::skip]
impl CodeAsmGf2p8affineinvqb<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn gf2p8affineinvqb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Gf2p8affineinvqb_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmGf2p8affineinvqb<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn gf2p8affineinvqb(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Gf2p8affineinvqb_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmGf2p8affineinvqb<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn gf2p8affineinvqb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Gf2p8affineinvqb_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmGf2p8affineinvqb<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn gf2p8affineinvqb(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Gf2p8affineinvqb_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmGf2p8affineqb<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn gf2p8affineqb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Gf2p8affineqb_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmGf2p8affineqb<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn gf2p8affineqb(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Gf2p8affineqb_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmGf2p8affineqb<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn gf2p8affineqb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Gf2p8affineqb_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmGf2p8affineqb<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn gf2p8affineqb(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Gf2p8affineqb_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmGf2p8mulb<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn gf2p8mulb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Gf2p8mulb_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmGf2p8mulb<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn gf2p8mulb(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Gf2p8mulb_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmHaddpd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn haddpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Haddpd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmHaddpd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn haddpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Haddpd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmHaddps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn haddps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Haddps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmHaddps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn haddps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Haddps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmHlt for CodeAssembler {
	#[inline]
	fn hlt(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Hlt))
	}
}

#[rustfmt::skip]
impl CodeAsmHreset<i32> for CodeAssembler {
	#[inline]
	fn hreset(&mut self, op0: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Hreset_imm8, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmHreset<u32> for CodeAssembler {
	#[inline]
	fn hreset(&mut self, op0: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Hreset_imm8, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmHsubpd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn hsubpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Hsubpd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmHsubpd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn hsubpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Hsubpd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmHsubps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn hsubps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Hsubps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmHsubps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn hsubps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Hsubps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmIbts<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn ibts(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ibts_rm16_r16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmIbts<__AsmMemoryOperand, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn ibts(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ibts_rm16_r16, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmIbts<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn ibts(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ibts_rm32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmIbts<__AsmMemoryOperand, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn ibts(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ibts_rm32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmIdiv<__AsmRegister8> for CodeAssembler {
	#[inline]
	fn idiv(&mut self, op0: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Idiv_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmIdiv<__AsmRegister16> for CodeAssembler {
	#[inline]
	fn idiv(&mut self, op0: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Idiv_rm16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmIdiv<__AsmRegister32> for CodeAssembler {
	#[inline]
	fn idiv(&mut self, op0: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Idiv_rm32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmIdiv<__AsmRegister64> for CodeAssembler {
	#[inline]
	fn idiv(&mut self, op0: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Idiv_rm64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmIdiv<__AsmMemoryOperand> for CodeAssembler {
	fn idiv(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Idiv_rm64
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Idiv_rm32
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Idiv_rm16
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Idiv_rm8
		} else {
			return Err(IcedError::new("idiv: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul<__AsmRegister8> for CodeAssembler {
	#[inline]
	fn imul(&mut self, op0: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Imul_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul<__AsmRegister16> for CodeAssembler {
	#[inline]
	fn imul(&mut self, op0: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Imul_rm16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul<__AsmRegister32> for CodeAssembler {
	#[inline]
	fn imul(&mut self, op0: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Imul_rm32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul<__AsmRegister64> for CodeAssembler {
	#[inline]
	fn imul(&mut self, op0: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Imul_rm64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul<__AsmMemoryOperand> for CodeAssembler {
	fn imul(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Imul_rm64
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Imul_rm32
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Imul_rm16
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Imul_rm8
		} else {
			return Err(IcedError::new("imul: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul2<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn imul_2(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Imul_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul2<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn imul_2(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Imul_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul2<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn imul_2(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Imul_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul2<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn imul_2(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Imul_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul2<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn imul_2(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Imul_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul2<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn imul_2(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Imul_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul3<__AsmRegister16, __AsmRegister16, i32> for CodeAssembler {
	#[inline]
	fn imul_3(&mut self, op0: __AsmRegister16, op1: __AsmRegister16, op2: i32) -> Result<(), IcedError> {
		let code = if op2 >= i8::MIN as i32 && op2 <= i8::MAX as i32 { Code::Imul_r16_rm16_imm8 } else { Code::Imul_r16_rm16_imm16 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul3<__AsmRegister32, __AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn imul_3(&mut self, op0: __AsmRegister32, op1: __AsmRegister32, op2: i32) -> Result<(), IcedError> {
		let code = if op2 >= i8::MIN as i32 && op2 <= i8::MAX as i32 { Code::Imul_r32_rm32_imm8 } else { Code::Imul_r32_rm32_imm32 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul3<__AsmRegister64, __AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn imul_3(&mut self, op0: __AsmRegister64, op1: __AsmRegister64, op2: i32) -> Result<(), IcedError> {
		let code = if op2 >= i8::MIN as i32 && op2 <= i8::MAX as i32 { Code::Imul_r64_rm64_imm8 } else { Code::Imul_r64_rm64_imm32 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul3<__AsmRegister16, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn imul_3(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		let code = if op2 >= i8::MIN as i32 && op2 <= i8::MAX as i32 { Code::Imul_r16_rm16_imm8 } else { Code::Imul_r16_rm16_imm16 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul3<__AsmRegister32, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn imul_3(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		let code = if op2 >= i8::MIN as i32 && op2 <= i8::MAX as i32 { Code::Imul_r32_rm32_imm8 } else { Code::Imul_r32_rm32_imm32 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul3<__AsmRegister64, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn imul_3(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		let code = if op2 >= i8::MIN as i32 && op2 <= i8::MAX as i32 { Code::Imul_r64_rm64_imm8 } else { Code::Imul_r64_rm64_imm32 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul3<__AsmRegister16, __AsmRegister16, u32> for CodeAssembler {
	#[inline]
	fn imul_3(&mut self, op0: __AsmRegister16, op1: __AsmRegister16, op2: u32) -> Result<(), IcedError> {
		let code = if op2 <= i8::MAX as u32 || (0xFF80 <= op2 && op2 <= 0xFFFF) { Code::Imul_r16_rm16_imm8 } else { Code::Imul_r16_rm16_imm16 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul3<__AsmRegister32, __AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn imul_3(&mut self, op0: __AsmRegister32, op1: __AsmRegister32, op2: u32) -> Result<(), IcedError> {
		let code = if op2 <= i8::MAX as u32 || 0xFFFF_FF80 <= op2 { Code::Imul_r32_rm32_imm8 } else { Code::Imul_r32_rm32_imm32 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul3<__AsmRegister16, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn imul_3(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		let code = if op2 <= i8::MAX as u32 || (0xFF80 <= op2 && op2 <= 0xFFFF) { Code::Imul_r16_rm16_imm8 } else { Code::Imul_r16_rm16_imm16 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul3<__AsmRegister32, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn imul_3(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		let code = if op2 <= i8::MAX as u32 || 0xFFFF_FF80 <= op2 { Code::Imul_r32_rm32_imm8 } else { Code::Imul_r32_rm32_imm32 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmIn<__AsmRegister8, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn in_(&mut self, op0: __AsmRegister8, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::In_AL_DX, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmIn<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn in_(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::In_AX_DX, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmIn<__AsmRegister32, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn in_(&mut self, op0: __AsmRegister32, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::In_EAX_DX, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmIn<__AsmRegister8, i32> for CodeAssembler {
	#[inline]
	fn in_(&mut self, op0: __AsmRegister8, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::In_AL_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmIn<__AsmRegister16, i32> for CodeAssembler {
	#[inline]
	fn in_(&mut self, op0: __AsmRegister16, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::In_AX_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmIn<__AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn in_(&mut self, op0: __AsmRegister32, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::In_EAX_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmIn<__AsmRegister8, u32> for CodeAssembler {
	#[inline]
	fn in_(&mut self, op0: __AsmRegister8, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::In_AL_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmIn<__AsmRegister16, u32> for CodeAssembler {
	#[inline]
	fn in_(&mut self, op0: __AsmRegister16, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::In_AX_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmIn<__AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn in_(&mut self, op0: __AsmRegister32, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::In_EAX_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmInc<__AsmRegister8> for CodeAssembler {
	#[inline]
	fn inc(&mut self, op0: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Inc_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmInc<__AsmRegister16> for CodeAssembler {
	#[inline]
	fn inc(&mut self, op0: __AsmRegister16) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 { Code::Inc_rm16 } else { Code::Inc_r16 };
		self.add_instr(Instruction::with1(code, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmInc<__AsmRegister32> for CodeAssembler {
	#[inline]
	fn inc(&mut self, op0: __AsmRegister32) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 { Code::Inc_rm32 } else { Code::Inc_r32 };
		self.add_instr(Instruction::with1(code, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmInc<__AsmRegister64> for CodeAssembler {
	#[inline]
	fn inc(&mut self, op0: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Inc_rm64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmInc<__AsmMemoryOperand> for CodeAssembler {
	fn inc(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Inc_rm64
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Inc_rm32
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Inc_rm16
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Inc_rm8
		} else {
			return Err(IcedError::new("inc: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmIncsspd<__AsmRegister32> for CodeAssembler {
	#[inline]
	fn incsspd(&mut self, op0: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Incsspd_r32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmIncsspq<__AsmRegister64> for CodeAssembler {
	#[inline]
	fn incsspq(&mut self, op0: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Incsspq_r64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmInsb for CodeAssembler {
	#[inline]
	fn insb(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_insb(self.bitness(), RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmInsd for CodeAssembler {
	#[inline]
	fn insd(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_insd(self.bitness(), RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmInsertps<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn insertps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Insertps_xmm_xmmm32_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmInsertps<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn insertps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Insertps_xmm_xmmm32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmInsertps<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn insertps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Insertps_xmm_xmmm32_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmInsertps<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn insertps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Insertps_xmm_xmmm32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmInsertq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn insertq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Insertq_xmm_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmInsertq4<__AsmRegisterXmm, __AsmRegisterXmm, i32, i32> for CodeAssembler {
	#[inline]
	fn insertq_4(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::Insertq_xmm_xmm_imm8_imm8, op0.register(), op1.register(), op2, op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmInsertq4<__AsmRegisterXmm, __AsmRegisterXmm, u32, u32> for CodeAssembler {
	#[inline]
	fn insertq_4(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::Insertq_xmm_xmm_imm8_imm8, op0.register(), op1.register(), op2, op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmInsw for CodeAssembler {
	#[inline]
	fn insw(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_insw(self.bitness(), RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmInt<i32> for CodeAssembler {
	#[inline]
	fn int(&mut self, op0: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Int_imm8, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmInt<u32> for CodeAssembler {
	#[inline]
	fn int(&mut self, op0: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Int_imm8, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmInt1 for CodeAssembler {
	#[inline]
	fn int1(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Int1))
	}
}

#[rustfmt::skip]
impl CodeAsmInt3 for CodeAssembler {
	#[inline]
	fn int3(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Int3))
	}
}

#[rustfmt::skip]
impl CodeAsmInto for CodeAssembler {
	#[inline]
	fn into(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Into))
	}
}

#[rustfmt::skip]
impl CodeAsmInvd for CodeAssembler {
	#[inline]
	fn invd(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Invd))
	}
}

#[rustfmt::skip]
impl CodeAsmInvept<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn invept(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Invept_r32_m128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmInvept<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn invept(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Invept_r64_m128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmInvlpg<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn invlpg(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Invlpg_m, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmInvlpga for CodeAssembler {
	fn invlpga(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Invlpgaq
		} else if self.bitness() >= 32 {
			Code::Invlpgad
		} else {
			Code::Invlpgaw
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmInvlpgb for CodeAssembler {
	fn invlpgb(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Invlpgbq
		} else if self.bitness() >= 32 {
			Code::Invlpgbd
		} else {
			Code::Invlpgbw
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmInvpcid<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn invpcid(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Invpcid_r32_m128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmInvpcid<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn invpcid(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Invpcid_r64_m128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmInvvpid<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn invvpid(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Invvpid_r32_m128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmInvvpid<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn invvpid(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Invvpid_r64_m128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmIret for CodeAssembler {
	#[inline]
	fn iret(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Iretw))
	}
}

#[rustfmt::skip]
impl CodeAsmIretd for CodeAssembler {
	#[inline]
	fn iretd(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Iretd))
	}
}

#[rustfmt::skip]
impl CodeAsmIretq for CodeAssembler {
	#[inline]
	fn iretq(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Iretq))
	}
}

#[rustfmt::skip]
impl CodeAsmJa<CodeLabel> for CodeAssembler {
	fn ja(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Ja_rel8_64
			} else if self.bitness() >= 32 {
				Code::Ja_rel8_32
			} else {
				Code::Ja_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Ja_rel32_64
		} else if self.bitness() >= 32 {
			Code::Ja_rel32_32
		} else {
			Code::Ja_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJa<u64> for CodeAssembler {
	fn ja(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Ja_rel8_64
			} else if self.bitness() >= 32 {
				Code::Ja_rel8_32
			} else {
				Code::Ja_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Ja_rel32_64
		} else if self.bitness() >= 32 {
			Code::Ja_rel32_32
		} else {
			Code::Ja_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJae<CodeLabel> for CodeAssembler {
	fn jae(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jae_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jae_rel8_32
			} else {
				Code::Jae_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jae_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jae_rel32_32
		} else {
			Code::Jae_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJae<u64> for CodeAssembler {
	fn jae(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jae_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jae_rel8_32
			} else {
				Code::Jae_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jae_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jae_rel32_32
		} else {
			Code::Jae_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJb<CodeLabel> for CodeAssembler {
	fn jb(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jb_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jb_rel8_32
			} else {
				Code::Jb_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jb_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jb_rel32_32
		} else {
			Code::Jb_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJb<u64> for CodeAssembler {
	fn jb(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jb_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jb_rel8_32
			} else {
				Code::Jb_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jb_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jb_rel32_32
		} else {
			Code::Jb_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJbe<CodeLabel> for CodeAssembler {
	fn jbe(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jbe_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jbe_rel8_32
			} else {
				Code::Jbe_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jbe_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jbe_rel32_32
		} else {
			Code::Jbe_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJbe<u64> for CodeAssembler {
	fn jbe(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jbe_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jbe_rel8_32
			} else {
				Code::Jbe_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jbe_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jbe_rel32_32
		} else {
			Code::Jbe_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJcxz<CodeLabel> for CodeAssembler {
	#[inline]
	fn jcxz(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_branch(Code::Jcxz_rel8_16, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJcxz<u64> for CodeAssembler {
	#[inline]
	fn jcxz(&mut self, op0: u64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_branch(Code::Jcxz_rel8_16, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJe<CodeLabel> for CodeAssembler {
	fn je(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Je_rel8_64
			} else if self.bitness() >= 32 {
				Code::Je_rel8_32
			} else {
				Code::Je_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Je_rel32_64
		} else if self.bitness() >= 32 {
			Code::Je_rel32_32
		} else {
			Code::Je_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJe<u64> for CodeAssembler {
	fn je(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Je_rel8_64
			} else if self.bitness() >= 32 {
				Code::Je_rel8_32
			} else {
				Code::Je_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Je_rel32_64
		} else if self.bitness() >= 32 {
			Code::Je_rel32_32
		} else {
			Code::Je_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJecxz<CodeLabel> for CodeAssembler {
	#[inline]
	fn jecxz(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_branch(Code::Jecxz_rel8_32, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJecxz<u64> for CodeAssembler {
	#[inline]
	fn jecxz(&mut self, op0: u64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_branch(Code::Jecxz_rel8_32, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJg<CodeLabel> for CodeAssembler {
	fn jg(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jg_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jg_rel8_32
			} else {
				Code::Jg_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jg_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jg_rel32_32
		} else {
			Code::Jg_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJg<u64> for CodeAssembler {
	fn jg(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jg_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jg_rel8_32
			} else {
				Code::Jg_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jg_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jg_rel32_32
		} else {
			Code::Jg_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJge<CodeLabel> for CodeAssembler {
	fn jge(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jge_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jge_rel8_32
			} else {
				Code::Jge_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jge_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jge_rel32_32
		} else {
			Code::Jge_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJge<u64> for CodeAssembler {
	fn jge(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jge_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jge_rel8_32
			} else {
				Code::Jge_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jge_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jge_rel32_32
		} else {
			Code::Jge_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJl<CodeLabel> for CodeAssembler {
	fn jl(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jl_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jl_rel8_32
			} else {
				Code::Jl_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jl_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jl_rel32_32
		} else {
			Code::Jl_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJl<u64> for CodeAssembler {
	fn jl(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jl_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jl_rel8_32
			} else {
				Code::Jl_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jl_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jl_rel32_32
		} else {
			Code::Jl_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJle<CodeLabel> for CodeAssembler {
	fn jle(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jle_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jle_rel8_32
			} else {
				Code::Jle_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jle_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jle_rel32_32
		} else {
			Code::Jle_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJle<u64> for CodeAssembler {
	fn jle(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jle_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jle_rel8_32
			} else {
				Code::Jle_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jle_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jle_rel32_32
		} else {
			Code::Jle_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJmp<__AsmRegister16> for CodeAssembler {
	#[inline]
	fn jmp(&mut self, op0: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Jmp_rm16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJmp<__AsmRegister32> for CodeAssembler {
	#[inline]
	fn jmp(&mut self, op0: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Jmp_rm32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJmp<__AsmRegister64> for CodeAssembler {
	#[inline]
	fn jmp(&mut self, op0: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Jmp_rm64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJmp<__AsmMemoryOperand> for CodeAssembler {
	fn jmp(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Tbyte {
			Code::Jmp_m1664
		} else if op0.size() == MemoryOperandSize::Qword {
			Code::Jmp_rm64
		} else if op0.size() == MemoryOperandSize::Fword {
			Code::Jmp_m1632
		} else if op0.size() == MemoryOperandSize::Dword {
			if self.bitness() >= 32 { Code::Jmp_rm32 } else { Code::Jmp_m1616 }
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Jmp_rm16
		} else {
			return Err(IcedError::new("jmp: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmJmp<CodeLabel> for CodeAssembler {
	fn jmp(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jmp_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jmp_rel8_32
			} else {
				Code::Jmp_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jmp_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jmp_rel32_32
		} else {
			Code::Jmp_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJmp<u64> for CodeAssembler {
	fn jmp(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jmp_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jmp_rel8_32
			} else {
				Code::Jmp_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jmp_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jmp_rel32_32
		} else {
			Code::Jmp_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJmpe<__AsmRegister16> for CodeAssembler {
	#[inline]
	fn jmpe(&mut self, op0: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Jmpe_rm16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJmpe<__AsmRegister32> for CodeAssembler {
	#[inline]
	fn jmpe(&mut self, op0: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Jmpe_rm32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJmpe<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn jmpe(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Jmpe_rm32 } else { Code::Jmpe_rm16 };
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmJmpe<CodeLabel> for CodeAssembler {
	#[inline]
	fn jmpe(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Jmpe_disp32 } else { Code::Jmpe_disp16 };
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJmpe<u64> for CodeAssembler {
	#[inline]
	fn jmpe(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Jmpe_disp32 } else { Code::Jmpe_disp16 };
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJne<CodeLabel> for CodeAssembler {
	fn jne(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jne_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jne_rel8_32
			} else {
				Code::Jne_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jne_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jne_rel32_32
		} else {
			Code::Jne_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJne<u64> for CodeAssembler {
	fn jne(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jne_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jne_rel8_32
			} else {
				Code::Jne_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jne_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jne_rel32_32
		} else {
			Code::Jne_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJno<CodeLabel> for CodeAssembler {
	fn jno(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jno_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jno_rel8_32
			} else {
				Code::Jno_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jno_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jno_rel32_32
		} else {
			Code::Jno_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJno<u64> for CodeAssembler {
	fn jno(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jno_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jno_rel8_32
			} else {
				Code::Jno_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jno_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jno_rel32_32
		} else {
			Code::Jno_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJnp<CodeLabel> for CodeAssembler {
	fn jnp(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jnp_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jnp_rel8_32
			} else {
				Code::Jnp_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jnp_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jnp_rel32_32
		} else {
			Code::Jnp_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJnp<u64> for CodeAssembler {
	fn jnp(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jnp_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jnp_rel8_32
			} else {
				Code::Jnp_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jnp_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jnp_rel32_32
		} else {
			Code::Jnp_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJns<CodeLabel> for CodeAssembler {
	fn jns(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jns_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jns_rel8_32
			} else {
				Code::Jns_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jns_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jns_rel32_32
		} else {
			Code::Jns_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJns<u64> for CodeAssembler {
	fn jns(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jns_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jns_rel8_32
			} else {
				Code::Jns_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jns_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jns_rel32_32
		} else {
			Code::Jns_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJo<CodeLabel> for CodeAssembler {
	fn jo(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jo_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jo_rel8_32
			} else {
				Code::Jo_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jo_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jo_rel32_32
		} else {
			Code::Jo_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJo<u64> for CodeAssembler {
	fn jo(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jo_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jo_rel8_32
			} else {
				Code::Jo_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jo_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jo_rel32_32
		} else {
			Code::Jo_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJp<CodeLabel> for CodeAssembler {
	fn jp(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jp_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jp_rel8_32
			} else {
				Code::Jp_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jp_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jp_rel32_32
		} else {
			Code::Jp_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJp<u64> for CodeAssembler {
	fn jp(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jp_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jp_rel8_32
			} else {
				Code::Jp_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jp_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jp_rel32_32
		} else {
			Code::Jp_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJrcxz<CodeLabel> for CodeAssembler {
	#[inline]
	fn jrcxz(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_branch(Code::Jrcxz_rel8_64, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJrcxz<u64> for CodeAssembler {
	#[inline]
	fn jrcxz(&mut self, op0: u64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_branch(Code::Jrcxz_rel8_64, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJs<CodeLabel> for CodeAssembler {
	fn js(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Js_rel8_64
			} else if self.bitness() >= 32 {
				Code::Js_rel8_32
			} else {
				Code::Js_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Js_rel32_64
		} else if self.bitness() >= 32 {
			Code::Js_rel32_32
		} else {
			Code::Js_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJs<u64> for CodeAssembler {
	fn js(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Js_rel8_64
			} else if self.bitness() >= 32 {
				Code::Js_rel8_32
			} else {
				Code::Js_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Js_rel32_64
		} else if self.bitness() >= 32 {
			Code::Js_rel32_32
		} else {
			Code::Js_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmKaddb<__AsmRegisterK, __AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kaddb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kaddb_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKaddd<__AsmRegisterK, __AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kaddd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kaddd_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKaddq<__AsmRegisterK, __AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kaddq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kaddq_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKaddw<__AsmRegisterK, __AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kaddw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kaddw_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKandb<__AsmRegisterK, __AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kandb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kandb_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKandd<__AsmRegisterK, __AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kandd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kandd_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKandnb<__AsmRegisterK, __AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kandnb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kandnb_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKandnd<__AsmRegisterK, __AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kandnd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kandnd_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKandnq<__AsmRegisterK, __AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kandnq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kandnq_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKandnw<__AsmRegisterK, __AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kandnw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kandnw_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKandq<__AsmRegisterK, __AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kandq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kandq_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKandw<__AsmRegisterK, __AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kandw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kandw_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKmovb<__AsmRegisterK, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn kmovb(&mut self, op0: __AsmRegisterK, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kmovb_kr_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKmovb<__AsmRegister32, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kmovb(&mut self, op0: __AsmRegister32, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kmovb_r32_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKmovb<__AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kmovb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kmovb_kr_km8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKmovb<__AsmMemoryOperand, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kmovb(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kmovb_m8_kr, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKmovb<__AsmRegisterK, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn kmovb(&mut self, op0: __AsmRegisterK, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kmovb_kr_km8, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmKmovd<__AsmRegisterK, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn kmovd(&mut self, op0: __AsmRegisterK, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kmovd_kr_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKmovd<__AsmRegister32, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kmovd(&mut self, op0: __AsmRegister32, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kmovd_r32_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKmovd<__AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kmovd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kmovd_kr_km32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKmovd<__AsmMemoryOperand, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kmovd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kmovd_m32_kr, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKmovd<__AsmRegisterK, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn kmovd(&mut self, op0: __AsmRegisterK, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kmovd_kr_km32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmKmovq<__AsmRegisterK, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn kmovq(&mut self, op0: __AsmRegisterK, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kmovq_kr_r64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKmovq<__AsmRegister64, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kmovq(&mut self, op0: __AsmRegister64, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kmovq_r64_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKmovq<__AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kmovq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kmovq_kr_km64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKmovq<__AsmMemoryOperand, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kmovq(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kmovq_m64_kr, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKmovq<__AsmRegisterK, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn kmovq(&mut self, op0: __AsmRegisterK, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kmovq_kr_km64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmKmovw<__AsmRegisterK, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn kmovw(&mut self, op0: __AsmRegisterK, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kmovw_kr_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKmovw<__AsmRegister32, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kmovw(&mut self, op0: __AsmRegister32, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kmovw_r32_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKmovw<__AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kmovw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kmovw_kr_km16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKmovw<__AsmMemoryOperand, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kmovw(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kmovw_m16_kr, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKmovw<__AsmRegisterK, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn kmovw(&mut self, op0: __AsmRegisterK, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kmovw_kr_km16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmKnotb<__AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn knotb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Knotb_kr_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKnotd<__AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn knotd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Knotd_kr_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKnotq<__AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn knotq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Knotq_kr_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKnotw<__AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn knotw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Knotw_kr_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKorb<__AsmRegisterK, __AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn korb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Korb_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKord<__AsmRegisterK, __AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kord(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kord_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKorq<__AsmRegisterK, __AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn korq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Korq_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKortestb<__AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kortestb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kortestb_kr_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKortestd<__AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kortestd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kortestd_kr_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKortestq<__AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kortestq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kortestq_kr_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKortestw<__AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kortestw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kortestw_kr_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKorw<__AsmRegisterK, __AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn korw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Korw_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKshiftlb<__AsmRegisterK, __AsmRegisterK, i32> for CodeAssembler {
	#[inline]
	fn kshiftlb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kshiftlb_kr_kr_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmKshiftlb<__AsmRegisterK, __AsmRegisterK, u32> for CodeAssembler {
	#[inline]
	fn kshiftlb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kshiftlb_kr_kr_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmKshiftld<__AsmRegisterK, __AsmRegisterK, i32> for CodeAssembler {
	#[inline]
	fn kshiftld(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kshiftld_kr_kr_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmKshiftld<__AsmRegisterK, __AsmRegisterK, u32> for CodeAssembler {
	#[inline]
	fn kshiftld(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kshiftld_kr_kr_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmKshiftlq<__AsmRegisterK, __AsmRegisterK, i32> for CodeAssembler {
	#[inline]
	fn kshiftlq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kshiftlq_kr_kr_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmKshiftlq<__AsmRegisterK, __AsmRegisterK, u32> for CodeAssembler {
	#[inline]
	fn kshiftlq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kshiftlq_kr_kr_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmKshiftlw<__AsmRegisterK, __AsmRegisterK, i32> for CodeAssembler {
	#[inline]
	fn kshiftlw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kshiftlw_kr_kr_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmKshiftlw<__AsmRegisterK, __AsmRegisterK, u32> for CodeAssembler {
	#[inline]
	fn kshiftlw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kshiftlw_kr_kr_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmKshiftrb<__AsmRegisterK, __AsmRegisterK, i32> for CodeAssembler {
	#[inline]
	fn kshiftrb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kshiftrb_kr_kr_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmKshiftrb<__AsmRegisterK, __AsmRegisterK, u32> for CodeAssembler {
	#[inline]
	fn kshiftrb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kshiftrb_kr_kr_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmKshiftrd<__AsmRegisterK, __AsmRegisterK, i32> for CodeAssembler {
	#[inline]
	fn kshiftrd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kshiftrd_kr_kr_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmKshiftrd<__AsmRegisterK, __AsmRegisterK, u32> for CodeAssembler {
	#[inline]
	fn kshiftrd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kshiftrd_kr_kr_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmKshiftrq<__AsmRegisterK, __AsmRegisterK, i32> for CodeAssembler {
	#[inline]
	fn kshiftrq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kshiftrq_kr_kr_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmKshiftrq<__AsmRegisterK, __AsmRegisterK, u32> for CodeAssembler {
	#[inline]
	fn kshiftrq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kshiftrq_kr_kr_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmKshiftrw<__AsmRegisterK, __AsmRegisterK, i32> for CodeAssembler {
	#[inline]
	fn kshiftrw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kshiftrw_kr_kr_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmKshiftrw<__AsmRegisterK, __AsmRegisterK, u32> for CodeAssembler {
	#[inline]
	fn kshiftrw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kshiftrw_kr_kr_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmKtestb<__AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn ktestb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Ktestb_kr_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKtestd<__AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn ktestd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Ktestd_kr_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKtestq<__AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn ktestq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Ktestq_kr_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKtestw<__AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn ktestw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Ktestw_kr_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKunpckbw<__AsmRegisterK, __AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kunpckbw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kunpckbw_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKunpckdq<__AsmRegisterK, __AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kunpckdq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kunpckdq_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKunpckwd<__AsmRegisterK, __AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kunpckwd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kunpckwd_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKxnorb<__AsmRegisterK, __AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kxnorb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kxnorb_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKxnord<__AsmRegisterK, __AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kxnord(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kxnord_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKxnorq<__AsmRegisterK, __AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kxnorq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kxnorq_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKxnorw<__AsmRegisterK, __AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kxnorw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kxnorw_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKxorb<__AsmRegisterK, __AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kxorb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kxorb_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKxord<__AsmRegisterK, __AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kxord(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kxord_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKxorq<__AsmRegisterK, __AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kxorq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kxorq_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKxorw<__AsmRegisterK, __AsmRegisterK, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kxorw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterK, op2: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kxorw_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLahf for CodeAssembler {
	#[inline]
	fn lahf(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Lahf))
	}
}

#[rustfmt::skip]
impl CodeAsmLar<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn lar(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lar_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLar<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn lar(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lar_r32_r32m16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLar<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn lar(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lar_r64_r64m16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLar<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lar(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lar_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLar<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lar(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lar_r32_r32m16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLddqu<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lddqu(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lddqu_xmm_m128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLdmxcsr<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn ldmxcsr(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Ldmxcsr_m32, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLds<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lds(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lds_r16_m1616, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLds<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lds(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lds_r32_m1632, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLdtilecfg<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn ldtilecfg(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::VEX_Ldtilecfg_m512, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLea<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lea(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lea_r16_m, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLea<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lea(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lea_r32_m, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLea<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lea(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lea_r64_m, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLeave for CodeAssembler {
	fn leave(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Leaveq
		} else if self.bitness() >= 32 {
			Code::Leaved
		} else {
			Code::Leavew
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmLes<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn les(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Les_r16_m1616, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLes<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn les(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Les_r32_m1632, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLfence for CodeAssembler {
	#[inline]
	fn lfence(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Lfence))
	}
}

#[rustfmt::skip]
impl CodeAsmLfs<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lfs(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lfs_r16_m1616, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLfs<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lfs(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lfs_r32_m1632, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLfs<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lfs(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lfs_r64_m1664, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLgdt<__AsmMemoryOperand> for CodeAssembler {
	fn lgdt(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Lgdt_m1664
		} else if self.bitness() >= 32 {
			Code::Lgdt_m1632
		} else {
			Code::Lgdt_m1632_16
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLgs<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lgs(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lgs_r16_m1616, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLgs<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lgs(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lgs_r32_m1632, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLgs<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lgs(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lgs_r64_m1664, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLidt<__AsmMemoryOperand> for CodeAssembler {
	fn lidt(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Lidt_m1664
		} else if self.bitness() >= 32 {
			Code::Lidt_m1632
		} else {
			Code::Lidt_m1632_16
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLkgs<__AsmRegister16> for CodeAssembler {
	#[inline]
	fn lkgs(&mut self, op0: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Lkgs_rm16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLkgs<__AsmRegister32> for CodeAssembler {
	#[inline]
	fn lkgs(&mut self, op0: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Lkgs_r32m16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLkgs<__AsmRegister64> for CodeAssembler {
	#[inline]
	fn lkgs(&mut self, op0: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Lkgs_r64m16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLkgs<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lkgs(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Lkgs_r32m16 } else { Code::Lkgs_rm16 };
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLldt<__AsmRegister16> for CodeAssembler {
	#[inline]
	fn lldt(&mut self, op0: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Lldt_rm16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLldt<__AsmRegister32> for CodeAssembler {
	#[inline]
	fn lldt(&mut self, op0: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Lldt_r32m16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLldt<__AsmRegister64> for CodeAssembler {
	#[inline]
	fn lldt(&mut self, op0: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Lldt_r64m16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLldt<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lldt(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Lldt_r32m16 } else { Code::Lldt_rm16 };
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLlwpcb<__AsmRegister32> for CodeAssembler {
	#[inline]
	fn llwpcb(&mut self, op0: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::XOP_Llwpcb_r32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLlwpcb<__AsmRegister64> for CodeAssembler {
	#[inline]
	fn llwpcb(&mut self, op0: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::XOP_Llwpcb_r64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLmsw<__AsmRegister16> for CodeAssembler {
	#[inline]
	fn lmsw(&mut self, op0: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Lmsw_rm16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLmsw<__AsmRegister32> for CodeAssembler {
	#[inline]
	fn lmsw(&mut self, op0: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Lmsw_r32m16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLmsw<__AsmRegister64> for CodeAssembler {
	#[inline]
	fn lmsw(&mut self, op0: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Lmsw_r64m16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLmsw<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lmsw(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Lmsw_r32m16 } else { Code::Lmsw_rm16 };
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLoadall for CodeAssembler {
	#[inline]
	fn loadall(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Loadall386))
	}
}

#[rustfmt::skip]
impl CodeAsmLoadiwkey<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn loadiwkey(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Loadiwkey_xmm_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLodsb for CodeAssembler {
	#[inline]
	fn lodsb(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_lodsb(self.bitness(), Register::None, RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLodsd for CodeAssembler {
	#[inline]
	fn lodsd(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_lodsd(self.bitness(), Register::None, RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLodsq for CodeAssembler {
	#[inline]
	fn lodsq(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_lodsq(self.bitness(), Register::None, RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLodsw for CodeAssembler {
	#[inline]
	fn lodsw(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_lodsw(self.bitness(), Register::None, RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLoop<CodeLabel> for CodeAssembler {
	fn loop_(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Loop_rel8_64_RCX
		} else if self.bitness() >= 32 {
			Code::Loop_rel8_32_ECX
		} else {
			Code::Loop_rel8_16_CX
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLoop<u64> for CodeAssembler {
	fn loop_(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Loop_rel8_64_RCX
		} else if self.bitness() >= 32 {
			Code::Loop_rel8_32_ECX
		} else {
			Code::Loop_rel8_16_CX
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLoope<CodeLabel> for CodeAssembler {
	fn loope(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Loope_rel8_64_RCX
		} else if self.bitness() >= 32 {
			Code::Loope_rel8_32_ECX
		} else {
			Code::Loope_rel8_16_CX
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLoope<u64> for CodeAssembler {
	fn loope(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Loope_rel8_64_RCX
		} else if self.bitness() >= 32 {
			Code::Loope_rel8_32_ECX
		} else {
			Code::Loope_rel8_16_CX
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLoopne<CodeLabel> for CodeAssembler {
	fn loopne(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Loopne_rel8_64_RCX
		} else if self.bitness() >= 32 {
			Code::Loopne_rel8_32_ECX
		} else {
			Code::Loopne_rel8_16_CX
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLoopne<u64> for CodeAssembler {
	fn loopne(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Loopne_rel8_64_RCX
		} else if self.bitness() >= 32 {
			Code::Loopne_rel8_32_ECX
		} else {
			Code::Loopne_rel8_16_CX
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLsl<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn lsl(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lsl_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLsl<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn lsl(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lsl_r32_r32m16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLsl<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn lsl(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lsl_r64_r64m16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLsl<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lsl(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lsl_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLsl<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lsl(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lsl_r32_r32m16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLss<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lss(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lss_r16_m1616, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLss<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lss(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lss_r32_m1632, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLss<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lss(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lss_r64_m1664, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLtr<__AsmRegister16> for CodeAssembler {
	#[inline]
	fn ltr(&mut self, op0: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Ltr_rm16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLtr<__AsmRegister32> for CodeAssembler {
	#[inline]
	fn ltr(&mut self, op0: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Ltr_r32m16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLtr<__AsmRegister64> for CodeAssembler {
	#[inline]
	fn ltr(&mut self, op0: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Ltr_r64m16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLtr<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn ltr(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Ltr_r32m16 } else { Code::Ltr_rm16 };
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLwpins<__AsmRegister32, __AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn lwpins(&mut self, op0: __AsmRegister32, op1: __AsmRegister32, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Lwpins_r32_rm32_imm32, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLwpins<__AsmRegister64, __AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn lwpins(&mut self, op0: __AsmRegister64, op1: __AsmRegister32, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Lwpins_r64_rm32_imm32, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLwpins<__AsmRegister32, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn lwpins(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Lwpins_r32_rm32_imm32, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLwpins<__AsmRegister64, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn lwpins(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Lwpins_r64_rm32_imm32, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLwpins<__AsmRegister32, __AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn lwpins(&mut self, op0: __AsmRegister32, op1: __AsmRegister32, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Lwpins_r32_rm32_imm32, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLwpins<__AsmRegister64, __AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn lwpins(&mut self, op0: __AsmRegister64, op1: __AsmRegister32, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Lwpins_r64_rm32_imm32, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLwpins<__AsmRegister32, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn lwpins(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Lwpins_r32_rm32_imm32, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLwpins<__AsmRegister64, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn lwpins(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Lwpins_r64_rm32_imm32, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLwpval<__AsmRegister32, __AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn lwpval(&mut self, op0: __AsmRegister32, op1: __AsmRegister32, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Lwpval_r32_rm32_imm32, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLwpval<__AsmRegister64, __AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn lwpval(&mut self, op0: __AsmRegister64, op1: __AsmRegister32, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Lwpval_r64_rm32_imm32, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLwpval<__AsmRegister32, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn lwpval(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Lwpval_r32_rm32_imm32, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLwpval<__AsmRegister64, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn lwpval(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Lwpval_r64_rm32_imm32, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLwpval<__AsmRegister32, __AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn lwpval(&mut self, op0: __AsmRegister32, op1: __AsmRegister32, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Lwpval_r32_rm32_imm32, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLwpval<__AsmRegister64, __AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn lwpval(&mut self, op0: __AsmRegister64, op1: __AsmRegister32, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Lwpval_r64_rm32_imm32, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLwpval<__AsmRegister32, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn lwpval(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Lwpval_r32_rm32_imm32, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLwpval<__AsmRegister64, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn lwpval(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Lwpval_r64_rm32_imm32, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLzcnt<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn lzcnt(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lzcnt_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLzcnt<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn lzcnt(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lzcnt_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLzcnt<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn lzcnt(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lzcnt_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLzcnt<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lzcnt(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lzcnt_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLzcnt<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lzcnt(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lzcnt_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLzcnt<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lzcnt(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lzcnt_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMaskmovdqu<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn maskmovdqu(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_maskmovdqu(self.bitness(), op0.register(), op1.register(), Register::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmMaskmovq<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn maskmovq(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_maskmovq(self.bitness(), op0.register(), op1.register(), Register::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmMaxpd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn maxpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Maxpd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMaxpd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn maxpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Maxpd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMaxps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn maxps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Maxps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMaxps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn maxps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Maxps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMaxsd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn maxsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Maxsd_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMaxsd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn maxsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Maxsd_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMaxss<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn maxss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Maxss_xmm_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMaxss<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn maxss(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Maxss_xmm_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMcommit for CodeAssembler {
	#[inline]
	fn mcommit(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Mcommit))
	}
}

#[rustfmt::skip]
impl CodeAsmMfence for CodeAssembler {
	#[inline]
	fn mfence(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Mfence))
	}
}

#[rustfmt::skip]
impl CodeAsmMinpd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn minpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Minpd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMinpd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn minpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Minpd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMinps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn minps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Minps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMinps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn minps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Minps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMinsd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn minsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Minsd_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMinsd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn minsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Minsd_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMinss<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn minss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Minss_xmm_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMinss<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn minss(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Minss_xmm_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMonitor for CodeAssembler {
	fn monitor(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Monitorq
		} else if self.bitness() >= 32 {
			Code::Monitord
		} else {
			Code::Monitorw
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmMonitorx for CodeAssembler {
	fn monitorx(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Monitorxq
		} else if self.bitness() >= 32 {
			Code::Monitorxd
		} else {
			Code::Monitorxw
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmMontmul for CodeAssembler {
	fn montmul(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Montmul_64
		} else if self.bitness() >= 32 {
			Code::Montmul_32
		} else {
			Code::Montmul_16
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmMov<__AsmRegister8, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: __AsmRegister8, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_rm8_r8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<__AsmMemoryOperand, __AsmRegister8> for CodeAssembler {
	fn mov(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister8) -> Result<(), IcedError> {
		let code = if op1.register() == Register::AL && self.bitness() == 64 && op0.is_displacement_only() {
			Code::Mov_moffs8_AL
		} else if op1.register() == Register::AL && self.bitness() < 64 && op0.is_displacement_only() {
			Code::Mov_moffs8_AL
		} else {
			Code::Mov_rm8_r8
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_rm16_r16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<__AsmRegisterSegment, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: __AsmRegisterSegment, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_Sreg_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<__AsmMemoryOperand, __AsmRegister16> for CodeAssembler {
	fn mov(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister16) -> Result<(), IcedError> {
		let code = if op1.register() == Register::AX && self.bitness() == 64 && op0.is_displacement_only() {
			Code::Mov_moffs16_AX
		} else if op1.register() == Register::AX && self.bitness() < 64 && op0.is_displacement_only() {
			Code::Mov_moffs16_AX
		} else {
			Code::Mov_rm16_r16
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_rm32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<__AsmRegisterSegment, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: __AsmRegisterSegment, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_Sreg_r32m16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<__AsmRegisterCr, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: __AsmRegisterCr, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_cr_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<__AsmRegisterDr, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: __AsmRegisterDr, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_dr_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<__AsmRegisterTr, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: __AsmRegisterTr, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_tr_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<__AsmMemoryOperand, __AsmRegister32> for CodeAssembler {
	fn mov(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister32) -> Result<(), IcedError> {
		let code = if op1.register() == Register::EAX && self.bitness() == 64 && op0.is_displacement_only() {
			Code::Mov_moffs32_EAX
		} else if op1.register() == Register::EAX && self.bitness() < 64 && op0.is_displacement_only() {
			Code::Mov_moffs32_EAX
		} else {
			Code::Mov_rm32_r32
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_rm64_r64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<__AsmRegisterSegment, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: __AsmRegisterSegment, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_Sreg_r64m16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<__AsmRegisterCr, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: __AsmRegisterCr, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_cr_r64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<__AsmRegisterDr, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: __AsmRegisterDr, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_dr_r64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<__AsmMemoryOperand, __AsmRegister64> for CodeAssembler {
	fn mov(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister64) -> Result<(), IcedError> {
		let code = if op1.register() == Register::RAX && self.bitness() == 64 && op0.is_displacement_only() {
			Code::Mov_moffs64_RAX
		} else if op1.register() == Register::RAX && self.bitness() < 64 && op0.is_displacement_only() {
			Code::Mov_moffs64_RAX
		} else {
			Code::Mov_rm64_r64
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<__AsmRegister16, __AsmRegisterSegment> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: __AsmRegister16, op1: __AsmRegisterSegment) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_rm16_Sreg, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<__AsmRegister32, __AsmRegisterSegment> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: __AsmRegister32, op1: __AsmRegisterSegment) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_r32m16_Sreg, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<__AsmRegister64, __AsmRegisterSegment> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: __AsmRegister64, op1: __AsmRegisterSegment) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_r64m16_Sreg, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<__AsmMemoryOperand, __AsmRegisterSegment> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterSegment) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Mov_r32m16_Sreg } else { Code::Mov_rm16_Sreg };
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<__AsmRegister32, __AsmRegisterCr> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: __AsmRegister32, op1: __AsmRegisterCr) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_r32_cr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<__AsmRegister64, __AsmRegisterCr> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: __AsmRegister64, op1: __AsmRegisterCr) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_r64_cr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<__AsmRegister32, __AsmRegisterDr> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: __AsmRegister32, op1: __AsmRegisterDr) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_r32_dr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<__AsmRegister64, __AsmRegisterDr> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: __AsmRegister64, op1: __AsmRegisterDr) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_r64_dr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<__AsmRegister32, __AsmRegisterTr> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: __AsmRegister32, op1: __AsmRegisterTr) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_r32_tr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<__AsmRegister8, __AsmMemoryOperand> for CodeAssembler {
	fn mov(&mut self, op0: __AsmRegister8, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AL && self.bitness() == 64 && op1.is_displacement_only() {
			Code::Mov_AL_moffs8
		} else if op0.register() == Register::AL && self.bitness() < 64 && op1.is_displacement_only() {
			Code::Mov_AL_moffs8
		} else {
			Code::Mov_r8_rm8
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	fn mov(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AX && self.bitness() == 64 && op1.is_displacement_only() {
			Code::Mov_AX_moffs16
		} else if op0.register() == Register::AX && self.bitness() < 64 && op1.is_displacement_only() {
			Code::Mov_AX_moffs16
		} else {
			Code::Mov_r16_rm16
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	fn mov(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.register() == Register::EAX && self.bitness() == 64 && op1.is_displacement_only() {
			Code::Mov_EAX_moffs32
		} else if op0.register() == Register::EAX && self.bitness() < 64 && op1.is_displacement_only() {
			Code::Mov_EAX_moffs32
		} else {
			Code::Mov_r32_rm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	fn mov(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.register() == Register::RAX && self.bitness() == 64 && op1.is_displacement_only() {
			Code::Mov_RAX_moffs64
		} else if op0.register() == Register::RAX && self.bitness() < 64 && op1.is_displacement_only() {
			Code::Mov_RAX_moffs64
		} else {
			Code::Mov_r64_rm64
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<__AsmRegisterSegment, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: __AsmRegisterSegment, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Mov_Sreg_r32m16 } else { Code::Mov_Sreg_rm16 };
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<__AsmRegister8, i32> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: __AsmRegister8, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_r8_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<__AsmRegister16, i32> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: __AsmRegister16, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_r16_imm16, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<__AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: __AsmRegister32, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_r32_imm32, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<__AsmRegister64, i64> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: __AsmRegister64, op1: i64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_r64_imm64, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<__AsmMemoryOperand, i32> for CodeAssembler {
	fn mov(&mut self, op0: __AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Mov_rm64_imm32
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Mov_rm32_imm32
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Mov_rm16_imm16
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Mov_rm8_imm8
		} else {
			return Err(IcedError::new("mov: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<__AsmRegister8, u32> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: __AsmRegister8, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_r8_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<__AsmRegister16, u32> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: __AsmRegister16, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_r16_imm16, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<__AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: __AsmRegister32, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_r32_imm32, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<__AsmRegister64, u64> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: __AsmRegister64, op1: u64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_r64_imm64, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<__AsmMemoryOperand, u32> for CodeAssembler {
	fn mov(&mut self, op0: __AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Dword {
			Code::Mov_rm32_imm32
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Mov_rm16_imm16
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Mov_rm8_imm8
		} else {
			return Err(IcedError::new("mov: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovapd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movapd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movapd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovapd<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movapd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movapd_xmmm128_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovapd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movapd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movapd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovaps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movaps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movaps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovaps<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movaps(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movaps_xmmm128_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovaps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movaps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movaps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovbe<__AsmMemoryOperand, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn movbe(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movbe_m16_r16, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovbe<__AsmMemoryOperand, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn movbe(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movbe_m32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovbe<__AsmMemoryOperand, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn movbe(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movbe_m64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovbe<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movbe(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movbe_r16_m16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovbe<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movbe(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movbe_r32_m32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovbe<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movbe(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movbe_r64_m64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovd<__AsmRegisterMm, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn movd(&mut self, op0: __AsmRegisterMm, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movd_mm_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovd<__AsmRegisterXmm, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn movd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movd_xmm_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovd<__AsmRegister32, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn movd(&mut self, op0: __AsmRegister32, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movd_rm32_mm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovd<__AsmMemoryOperand, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn movd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movd_rm32_mm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovd<__AsmRegister32, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movd(&mut self, op0: __AsmRegister32, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movd_rm32_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovd<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movd_rm32_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovd<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movd(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movd_mm_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movd_xmm_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovddup<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movddup(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movddup_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovddup<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movddup(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movddup_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovdir64b<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movdir64b(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movdir64b_r16_m512, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovdir64b<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movdir64b(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movdir64b_r32_m512, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovdir64b<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movdir64b(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movdir64b_r64_m512, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovdiri<__AsmMemoryOperand, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn movdiri(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movdiri_m32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovdiri<__AsmMemoryOperand, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn movdiri(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movdiri_m64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovdq2q<__AsmRegisterMm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movdq2q(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movdq2q_mm_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovdqa<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movdqa(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movdqa_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovdqa<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movdqa(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movdqa_xmmm128_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovdqa<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movdqa(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movdqa_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovdqu<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movdqu(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movdqu_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovdqu<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movdqu(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movdqu_xmmm128_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovdqu<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movdqu(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movdqu_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovhlps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movhlps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movhlps_xmm_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovhpd<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movhpd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movhpd_m64_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovhpd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movhpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movhpd_xmm_m64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovhps<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movhps(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movhps_m64_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovhps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movhps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movhps_xmm_m64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovlhps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movlhps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movlhps_xmm_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovlpd<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movlpd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movlpd_m64_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovlpd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movlpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movlpd_xmm_m64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovlps<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movlps(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movlps_m64_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovlps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movlps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movlps_xmm_m64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovmskpd<__AsmRegister32, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movmskpd(&mut self, op0: __AsmRegister32, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movmskpd_r32_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovmskpd<__AsmRegister64, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movmskpd(&mut self, op0: __AsmRegister64, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movmskpd_r64_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovmskps<__AsmRegister32, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movmskps(&mut self, op0: __AsmRegister32, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movmskps_r32_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovmskps<__AsmRegister64, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movmskps(&mut self, op0: __AsmRegister64, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movmskps_r64_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovntdq<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movntdq(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movntdq_m128_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovntdqa<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movntdqa(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movntdqa_xmm_m128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovnti<__AsmMemoryOperand, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn movnti(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movnti_m32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovnti<__AsmMemoryOperand, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn movnti(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movnti_m64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovntpd<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movntpd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movntpd_m128_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovntps<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movntps(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movntps_m128_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovntq<__AsmMemoryOperand, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn movntq(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movntq_m64_mm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovntsd<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movntsd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movntsd_m64_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovntss<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movntss(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movntss_m32_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovq<__AsmRegisterMm, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn movq(&mut self, op0: __AsmRegisterMm, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movq_mm_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovq<__AsmRegisterXmm, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn movq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movq_xmm_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovq<__AsmRegister64, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn movq(&mut self, op0: __AsmRegister64, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movq_rm64_mm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovq<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn movq(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movq_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovq<__AsmMemoryOperand, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn movq(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movq_mmm64_mm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovq<__AsmRegister64, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movq(&mut self, op0: __AsmRegister64, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movq_rm64_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movq_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovq<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movq(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movq_xmmm64_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovq<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movq(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movq_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movq_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovq2dq<__AsmRegisterXmm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn movq2dq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movq2dq_xmm_mm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsb for CodeAssembler {
	#[inline]
	fn movsb(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_movsb(self.bitness(), Register::None, RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsd for CodeAssembler {
	#[inline]
	fn movsd(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_movsd(self.bitness(), Register::None, RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsd2<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movsd_2(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movsd_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsd2<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movsd_2(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movsd_xmmm64_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsd2<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movsd_2(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movsd_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovshdup<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movshdup(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movshdup_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovshdup<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movshdup(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movshdup_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsldup<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movsldup(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movsldup_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsldup<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movsldup(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movsldup_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsq for CodeAssembler {
	#[inline]
	fn movsq(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_movsq(self.bitness(), Register::None, RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovss<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movss_xmm_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovss<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movss(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movss_xmmm32_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovss<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movss(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movss_xmm_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsw for CodeAssembler {
	#[inline]
	fn movsw(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_movsw(self.bitness(), Register::None, RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsx<__AsmRegister16, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn movsx(&mut self, op0: __AsmRegister16, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movsx_r16_rm8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsx<__AsmRegister32, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn movsx(&mut self, op0: __AsmRegister32, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movsx_r32_rm8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsx<__AsmRegister64, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn movsx(&mut self, op0: __AsmRegister64, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movsx_r64_rm8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsx<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn movsx(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movsx_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsx<__AsmRegister32, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn movsx(&mut self, op0: __AsmRegister32, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movsx_r32_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsx<__AsmRegister64, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn movsx(&mut self, op0: __AsmRegister64, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movsx_r64_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsx<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	fn movsx(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.size() == MemoryOperandSize::Word {
			Code::Movsx_r16_rm16
		} else if op1.size() == MemoryOperandSize::Byte {
			Code::Movsx_r16_rm8
		} else {
			return Err(IcedError::new("movsx: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsx<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	fn movsx(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.size() == MemoryOperandSize::Word {
			Code::Movsx_r32_rm16
		} else if op1.size() == MemoryOperandSize::Byte {
			Code::Movsx_r32_rm8
		} else {
			return Err(IcedError::new("movsx: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsx<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	fn movsx(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.size() == MemoryOperandSize::Word {
			Code::Movsx_r64_rm16
		} else if op1.size() == MemoryOperandSize::Byte {
			Code::Movsx_r64_rm8
		} else {
			return Err(IcedError::new("movsx: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsxd<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn movsxd(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movsxd_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsxd<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn movsxd(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movsxd_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsxd<__AsmRegister64, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn movsxd(&mut self, op0: __AsmRegister64, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movsxd_r64_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsxd<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movsxd(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movsxd_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsxd<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movsxd(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movsxd_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsxd<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movsxd(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movsxd_r64_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovupd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movupd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movupd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovupd<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movupd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movupd_xmmm128_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovupd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movupd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movupd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovups<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movups(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movups_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovups<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movups(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movups_xmmm128_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovups<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movups(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movups_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovzx<__AsmRegister16, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn movzx(&mut self, op0: __AsmRegister16, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movzx_r16_rm8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovzx<__AsmRegister32, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn movzx(&mut self, op0: __AsmRegister32, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movzx_r32_rm8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovzx<__AsmRegister64, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn movzx(&mut self, op0: __AsmRegister64, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movzx_r64_rm8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovzx<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn movzx(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movzx_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovzx<__AsmRegister32, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn movzx(&mut self, op0: __AsmRegister32, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movzx_r32_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovzx<__AsmRegister64, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn movzx(&mut self, op0: __AsmRegister64, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movzx_r64_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovzx<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	fn movzx(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.size() == MemoryOperandSize::Word {
			Code::Movzx_r16_rm16
		} else if op1.size() == MemoryOperandSize::Byte {
			Code::Movzx_r16_rm8
		} else {
			return Err(IcedError::new("movzx: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovzx<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	fn movzx(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.size() == MemoryOperandSize::Word {
			Code::Movzx_r32_rm16
		} else if op1.size() == MemoryOperandSize::Byte {
			Code::Movzx_r32_rm8
		} else {
			return Err(IcedError::new("movzx: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovzx<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	fn movzx(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.size() == MemoryOperandSize::Word {
			Code::Movzx_r64_rm16
		} else if op1.size() == MemoryOperandSize::Byte {
			Code::Movzx_r64_rm8
		} else {
			return Err(IcedError::new("movzx: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMpsadbw<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn mpsadbw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Mpsadbw_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmMpsadbw<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn mpsadbw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Mpsadbw_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmMpsadbw<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn mpsadbw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Mpsadbw_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmMpsadbw<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn mpsadbw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Mpsadbw_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmMul<__AsmRegister8> for CodeAssembler {
	#[inline]
	fn mul(&mut self, op0: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Mul_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMul<__AsmRegister16> for CodeAssembler {
	#[inline]
	fn mul(&mut self, op0: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Mul_rm16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMul<__AsmRegister32> for CodeAssembler {
	#[inline]
	fn mul(&mut self, op0: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Mul_rm32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMul<__AsmRegister64> for CodeAssembler {
	#[inline]
	fn mul(&mut self, op0: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Mul_rm64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMul<__AsmMemoryOperand> for CodeAssembler {
	fn mul(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Mul_rm64
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Mul_rm32
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Mul_rm16
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Mul_rm8
		} else {
			return Err(IcedError::new("mul: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMulpd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn mulpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mulpd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMulpd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn mulpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mulpd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMulps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn mulps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mulps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMulps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn mulps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mulps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMulsd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn mulsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mulsd_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMulsd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn mulsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mulsd_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMulss<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn mulss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mulss_xmm_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMulss<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn mulss(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mulss_xmm_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMulx<__AsmRegister32, __AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn mulx(&mut self, op0: __AsmRegister32, op1: __AsmRegister32, op2: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Mulx_r32_r32_rm32, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMulx<__AsmRegister64, __AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn mulx(&mut self, op0: __AsmRegister64, op1: __AsmRegister64, op2: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Mulx_r64_r64_rm64, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMulx<__AsmRegister32, __AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn mulx(&mut self, op0: __AsmRegister32, op1: __AsmRegister32, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Mulx_r32_r32_rm32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMulx<__AsmRegister64, __AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn mulx(&mut self, op0: __AsmRegister64, op1: __AsmRegister64, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Mulx_r64_r64_rm64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMwait for CodeAssembler {
	#[inline]
	fn mwait(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Mwait))
	}
}

#[rustfmt::skip]
impl CodeAsmMwaitx for CodeAssembler {
	#[inline]
	fn mwaitx(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Mwaitx))
	}
}

#[rustfmt::skip]
impl CodeAsmNeg<__AsmRegister8> for CodeAssembler {
	#[inline]
	fn neg(&mut self, op0: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Neg_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmNeg<__AsmRegister16> for CodeAssembler {
	#[inline]
	fn neg(&mut self, op0: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Neg_rm16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmNeg<__AsmRegister32> for CodeAssembler {
	#[inline]
	fn neg(&mut self, op0: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Neg_rm32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmNeg<__AsmRegister64> for CodeAssembler {
	#[inline]
	fn neg(&mut self, op0: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Neg_rm64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmNeg<__AsmMemoryOperand> for CodeAssembler {
	fn neg(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Neg_rm64
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Neg_rm32
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Neg_rm16
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Neg_rm8
		} else {
			return Err(IcedError::new("neg: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmNop for CodeAssembler {
	#[inline]
	fn nop(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Nopd } else { Code::Nopw };
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmNop1<__AsmRegister16> for CodeAssembler {
	#[inline]
	fn nop_1(&mut self, op0: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Nop_rm16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmNop1<__AsmRegister32> for CodeAssembler {
	#[inline]
	fn nop_1(&mut self, op0: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Nop_rm32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmNop1<__AsmRegister64> for CodeAssembler {
	#[inline]
	fn nop_1(&mut self, op0: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Nop_rm64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmNop1<__AsmMemoryOperand> for CodeAssembler {
	fn nop_1(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Nop_rm64
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Nop_rm32
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Nop_rm16
		} else {
			return Err(IcedError::new("nop: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmNot<__AsmRegister8> for CodeAssembler {
	#[inline]
	fn not(&mut self, op0: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Not_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmNot<__AsmRegister16> for CodeAssembler {
	#[inline]
	fn not(&mut self, op0: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Not_rm16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmNot<__AsmRegister32> for CodeAssembler {
	#[inline]
	fn not(&mut self, op0: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Not_rm32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmNot<__AsmRegister64> for CodeAssembler {
	#[inline]
	fn not(&mut self, op0: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Not_rm64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmNot<__AsmMemoryOperand> for CodeAssembler {
	fn not(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Not_rm64
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Not_rm32
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Not_rm16
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Not_rm8
		} else {
			return Err(IcedError::new("not: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<__AsmRegister8, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn or(&mut self, op0: __AsmRegister8, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Or_rm8_r8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<__AsmMemoryOperand, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn or(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Or_rm8_r8, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn or(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Or_rm16_r16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<__AsmMemoryOperand, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn or(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Or_rm16_r16, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn or(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Or_rm32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<__AsmMemoryOperand, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn or(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Or_rm32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn or(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Or_rm64_r64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<__AsmMemoryOperand, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn or(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Or_rm64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<__AsmRegister8, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn or(&mut self, op0: __AsmRegister8, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Or_r8_rm8, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn or(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Or_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn or(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Or_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn or(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Or_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<__AsmRegister8, i32> for CodeAssembler {
	#[inline]
	fn or(&mut self, op0: __AsmRegister8, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AL { Code::Or_AL_imm8 } else { Code::Or_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<__AsmRegister16, i32> for CodeAssembler {
	fn or(&mut self, op0: __AsmRegister16, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AX {
			Code::Or_AX_imm16
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Or_rm16_imm8
		} else {
			Code::Or_rm16_imm16
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<__AsmRegister32, i32> for CodeAssembler {
	fn or(&mut self, op0: __AsmRegister32, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::EAX {
			Code::Or_EAX_imm32
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Or_rm32_imm8
		} else {
			Code::Or_rm32_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<__AsmRegister64, i32> for CodeAssembler {
	fn or(&mut self, op0: __AsmRegister64, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::RAX {
			Code::Or_RAX_imm32
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Or_rm64_imm8
		} else {
			Code::Or_rm64_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<__AsmMemoryOperand, i32> for CodeAssembler {
	fn or(&mut self, op0: __AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Or_rm64_imm8 } else { Code::Or_rm64_imm32 }
		} else if op0.size() == MemoryOperandSize::Dword {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Or_rm32_imm8 } else { Code::Or_rm32_imm32 }
		} else if op0.size() == MemoryOperandSize::Word {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Or_rm16_imm8 } else { Code::Or_rm16_imm16 }
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Or_rm8_imm8
		} else {
			return Err(IcedError::new("or: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<__AsmRegister8, u32> for CodeAssembler {
	#[inline]
	fn or(&mut self, op0: __AsmRegister8, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AL { Code::Or_AL_imm8 } else { Code::Or_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<__AsmRegister16, u32> for CodeAssembler {
	fn or(&mut self, op0: __AsmRegister16, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AX {
			Code::Or_AX_imm16
		} else if op1 <= i8::MAX as u32 || (0xFF80 <= op1 && op1 <= 0xFFFF) {
			Code::Or_rm16_imm8
		} else {
			Code::Or_rm16_imm16
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<__AsmRegister32, u32> for CodeAssembler {
	fn or(&mut self, op0: __AsmRegister32, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::EAX {
			Code::Or_EAX_imm32
		} else if op1 <= i8::MAX as u32 || 0xFFFF_FF80 <= op1 {
			Code::Or_rm32_imm8
		} else {
			Code::Or_rm32_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<__AsmMemoryOperand, u32> for CodeAssembler {
	fn or(&mut self, op0: __AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Dword {
			if op1 <= i8::MAX as u32 || 0xFFFF_FF80 <= op1 { Code::Or_rm32_imm8 } else { Code::Or_rm32_imm32 }
		} else if op0.size() == MemoryOperandSize::Word {
			if op1 <= i8::MAX as u32 || (0xFF80 <= op1 && op1 <= 0xFFFF) { Code::Or_rm16_imm8 } else { Code::Or_rm16_imm16 }
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Or_rm8_imm8
		} else {
			return Err(IcedError::new("or: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmOrpd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn orpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Orpd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmOrpd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn orpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Orpd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmOrps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn orps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Orps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmOrps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn orps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Orps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmOut<__AsmRegister16, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn out(&mut self, op0: __AsmRegister16, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Out_DX_AL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmOut<i32, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn out(&mut self, op0: i32, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Out_imm8_AL, op0, op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmOut<u32, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn out(&mut self, op0: u32, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Out_imm8_AL, op0, op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmOut<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn out(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Out_DX_AX, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmOut<i32, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn out(&mut self, op0: i32, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Out_imm8_AX, op0, op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmOut<u32, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn out(&mut self, op0: u32, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Out_imm8_AX, op0, op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmOut<__AsmRegister16, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn out(&mut self, op0: __AsmRegister16, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Out_DX_EAX, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmOut<i32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn out(&mut self, op0: i32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Out_imm8_EAX, op0, op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmOut<u32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn out(&mut self, op0: u32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Out_imm8_EAX, op0, op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmOutsb for CodeAssembler {
	#[inline]
	fn outsb(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_outsb(self.bitness(), Register::None, RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmOutsd for CodeAssembler {
	#[inline]
	fn outsd(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_outsd(self.bitness(), Register::None, RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmOutsw for CodeAssembler {
	#[inline]
	fn outsw(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_outsw(self.bitness(), Register::None, RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPabsb<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pabsb(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pabsb_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPabsb<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pabsb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pabsb_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPabsb<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pabsb(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pabsb_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPabsb<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pabsb(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pabsb_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPabsd<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pabsd(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pabsd_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPabsd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pabsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pabsd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPabsd<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pabsd(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pabsd_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPabsd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pabsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pabsd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPabsw<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pabsw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pabsw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPabsw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pabsw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pabsw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPabsw<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pabsw(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pabsw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPabsw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pabsw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pabsw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPackssdw<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn packssdw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Packssdw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPackssdw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn packssdw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Packssdw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPackssdw<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn packssdw(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Packssdw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPackssdw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn packssdw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Packssdw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPacksswb<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn packsswb(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Packsswb_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPacksswb<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn packsswb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Packsswb_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPacksswb<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn packsswb(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Packsswb_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPacksswb<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn packsswb(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Packsswb_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPackusdw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn packusdw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Packusdw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPackusdw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn packusdw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Packusdw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPackuswb<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn packuswb(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Packuswb_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPackuswb<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn packuswb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Packuswb_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPackuswb<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn packuswb(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Packuswb_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPackuswb<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn packuswb(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Packuswb_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddb<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn paddb(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddb_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddb<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn paddb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddb_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddb<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn paddb(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddb_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddb<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn paddb(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddb_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddd<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn paddd(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddd_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn paddd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddd<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn paddd(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddd_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn paddd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddq<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn paddq(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddq_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn paddq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddq<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn paddq(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddq_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn paddq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddsb<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn paddsb(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddsb_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddsb<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn paddsb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddsb_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddsb<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn paddsb(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddsb_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddsb<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn paddsb(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddsb_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddsiw<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn paddsiw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddsiw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddsiw<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn paddsiw(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddsiw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddsw<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn paddsw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddsw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddsw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn paddsw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddsw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddsw<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn paddsw(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddsw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddsw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn paddsw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddsw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddusb<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn paddusb(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddusb_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddusb<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn paddusb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddusb_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddusb<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn paddusb(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddusb_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddusb<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn paddusb(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddusb_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddusw<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn paddusw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddusw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddusw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn paddusw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddusw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddusw<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn paddusw(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddusw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddusw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn paddusw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddusw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddw<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn paddw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn paddw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddw<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn paddw(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn paddw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPalignr<__AsmRegisterMm, __AsmRegisterMm, i32> for CodeAssembler {
	#[inline]
	fn palignr(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Palignr_mm_mmm64_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPalignr<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn palignr(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Palignr_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPalignr<__AsmRegisterMm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn palignr(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Palignr_mm_mmm64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPalignr<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn palignr(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Palignr_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPalignr<__AsmRegisterMm, __AsmRegisterMm, u32> for CodeAssembler {
	#[inline]
	fn palignr(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Palignr_mm_mmm64_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPalignr<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn palignr(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Palignr_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPalignr<__AsmRegisterMm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn palignr(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Palignr_mm_mmm64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPalignr<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn palignr(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Palignr_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPand<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pand(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pand_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPand<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pand(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pand_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPand<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pand(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pand_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPand<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pand(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pand_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPandn<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pandn(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pandn_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPandn<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pandn(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pandn_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPandn<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pandn(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pandn_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPandn<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pandn(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pandn_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPause for CodeAssembler {
	#[inline]
	fn pause(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Pause))
	}
}

#[rustfmt::skip]
impl CodeAsmPaveb<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn paveb(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paveb_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaveb<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn paveb(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paveb_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPavgb<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pavgb(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pavgb_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPavgb<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pavgb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pavgb_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPavgb<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pavgb(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pavgb_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPavgb<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pavgb(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pavgb_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPavgusb<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pavgusb(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pavgusb_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPavgusb<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pavgusb(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pavgusb_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPavgw<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pavgw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pavgw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPavgw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pavgw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pavgw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPavgw<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pavgw(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pavgw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPavgw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pavgw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pavgw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPblendvb<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pblendvb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pblendvb_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPblendvb<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pblendvb(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pblendvb_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPblendw<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pblendw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pblendw_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPblendw<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn pblendw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pblendw_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPblendw<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pblendw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pblendw_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPblendw<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn pblendw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pblendw_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPclmulhqhqdq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pclmulhqhqdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmPclmulqdq<__AsmRegisterXmm, __AsmRegisterXmm, i32>>::pclmulqdq(self, op0, op1, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmPclmulhqhqdq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pclmulhqhqdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmPclmulqdq<__AsmRegisterXmm, __AsmMemoryOperand, i32>>::pclmulqdq(self, op0, op1, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmPclmulhqlqdq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pclmulhqlqdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmPclmulqdq<__AsmRegisterXmm, __AsmRegisterXmm, i32>>::pclmulqdq(self, op0, op1, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmPclmulhqlqdq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pclmulhqlqdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmPclmulqdq<__AsmRegisterXmm, __AsmMemoryOperand, i32>>::pclmulqdq(self, op0, op1, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmPclmullqhqdq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pclmullqhqdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmPclmulqdq<__AsmRegisterXmm, __AsmRegisterXmm, i32>>::pclmulqdq(self, op0, op1, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmPclmullqhqdq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pclmullqhqdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmPclmulqdq<__AsmRegisterXmm, __AsmMemoryOperand, i32>>::pclmulqdq(self, op0, op1, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmPclmullqlqdq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pclmullqlqdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmPclmulqdq<__AsmRegisterXmm, __AsmRegisterXmm, i32>>::pclmulqdq(self, op0, op1, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmPclmullqlqdq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pclmullqlqdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmPclmulqdq<__AsmRegisterXmm, __AsmMemoryOperand, i32>>::pclmulqdq(self, op0, op1, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmPclmulqdq<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pclmulqdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pclmulqdq_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPclmulqdq<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn pclmulqdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pclmulqdq_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPclmulqdq<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pclmulqdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pclmulqdq_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPclmulqdq<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn pclmulqdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pclmulqdq_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpeqb<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pcmpeqb(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpeqb_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpeqb<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pcmpeqb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpeqb_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpeqb<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pcmpeqb(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpeqb_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpeqb<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pcmpeqb(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpeqb_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpeqd<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pcmpeqd(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpeqd_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpeqd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pcmpeqd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpeqd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpeqd<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pcmpeqd(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpeqd_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpeqd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pcmpeqd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpeqd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpeqq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pcmpeqq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpeqq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpeqq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pcmpeqq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpeqq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpeqw<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pcmpeqw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpeqw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpeqw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pcmpeqw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpeqw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpeqw<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pcmpeqw(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpeqw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpeqw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pcmpeqw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpeqw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpestri<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pcmpestri(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpestri_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpestri<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn pcmpestri(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpestri_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpestri<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pcmpestri(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpestri_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpestri<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn pcmpestri(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpestri_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpestri64<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pcmpestri64(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpestri64_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpestri64<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn pcmpestri64(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpestri64_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpestri64<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pcmpestri64(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpestri64_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpestri64<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn pcmpestri64(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpestri64_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpestrm<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pcmpestrm(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpestrm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpestrm<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn pcmpestrm(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpestrm_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpestrm<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pcmpestrm(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpestrm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpestrm<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn pcmpestrm(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpestrm_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpestrm64<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pcmpestrm64(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpestrm64_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpestrm64<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn pcmpestrm64(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpestrm64_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpestrm64<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pcmpestrm64(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpestrm64_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpestrm64<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn pcmpestrm64(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpestrm64_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpgtb<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pcmpgtb(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpgtb_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpgtb<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pcmpgtb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpgtb_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpgtb<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pcmpgtb(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpgtb_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpgtb<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pcmpgtb(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpgtb_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpgtd<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pcmpgtd(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpgtd_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpgtd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pcmpgtd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpgtd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpgtd<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pcmpgtd(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpgtd_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpgtd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pcmpgtd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpgtd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpgtq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pcmpgtq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpgtq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpgtq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pcmpgtq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpgtq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpgtw<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pcmpgtw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpgtw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpgtw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pcmpgtw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpgtw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpgtw<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pcmpgtw(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpgtw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpgtw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pcmpgtw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpgtw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpistri<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pcmpistri(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpistri_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpistri<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn pcmpistri(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpistri_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpistri<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pcmpistri(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpistri_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpistri<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn pcmpistri(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpistri_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpistrm<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pcmpistrm(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpistrm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpistrm<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn pcmpistrm(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpistrm_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpistrm<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pcmpistrm(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpistrm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpistrm<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn pcmpistrm(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpistrm_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcommit for CodeAssembler {
	#[inline]
	fn pcommit(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Pcommit))
	}
}

#[rustfmt::skip]
impl CodeAsmPconfig for CodeAssembler {
	#[inline]
	fn pconfig(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Pconfig))
	}
}

#[rustfmt::skip]
impl CodeAsmPdep<__AsmRegister32, __AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn pdep(&mut self, op0: __AsmRegister32, op1: __AsmRegister32, op2: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Pdep_r32_r32_rm32, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPdep<__AsmRegister64, __AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn pdep(&mut self, op0: __AsmRegister64, op1: __AsmRegister64, op2: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Pdep_r64_r64_rm64, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPdep<__AsmRegister32, __AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pdep(&mut self, op0: __AsmRegister32, op1: __AsmRegister32, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Pdep_r32_r32_rm32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPdep<__AsmRegister64, __AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pdep(&mut self, op0: __AsmRegister64, op1: __AsmRegister64, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Pdep_r64_r64_rm64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPdistib<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pdistib(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pdistib_mm_m64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPext<__AsmRegister32, __AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn pext(&mut self, op0: __AsmRegister32, op1: __AsmRegister32, op2: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Pext_r32_r32_rm32, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPext<__AsmRegister64, __AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn pext(&mut self, op0: __AsmRegister64, op1: __AsmRegister64, op2: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Pext_r64_r64_rm64, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPext<__AsmRegister32, __AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pext(&mut self, op0: __AsmRegister32, op1: __AsmRegister32, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Pext_r32_r32_rm32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPext<__AsmRegister64, __AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pext(&mut self, op0: __AsmRegister64, op1: __AsmRegister64, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Pext_r64_r64_rm64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrb<__AsmRegister32, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pextrb(&mut self, op0: __AsmRegister32, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrb_r32m8_xmm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrb<__AsmRegister64, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pextrb(&mut self, op0: __AsmRegister64, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrb_r64m8_xmm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrb<__AsmMemoryOperand, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pextrb(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrb_r32m8_xmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrb<__AsmRegister32, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pextrb(&mut self, op0: __AsmRegister32, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrb_r32m8_xmm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrb<__AsmRegister64, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pextrb(&mut self, op0: __AsmRegister64, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrb_r64m8_xmm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrb<__AsmMemoryOperand, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pextrb(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrb_r32m8_xmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrd<__AsmRegister32, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pextrd(&mut self, op0: __AsmRegister32, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrd_rm32_xmm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrd<__AsmMemoryOperand, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pextrd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrd_rm32_xmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrd<__AsmRegister32, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pextrd(&mut self, op0: __AsmRegister32, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrd_rm32_xmm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrd<__AsmMemoryOperand, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pextrd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrd_rm32_xmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrq<__AsmRegister64, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pextrq(&mut self, op0: __AsmRegister64, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrq_rm64_xmm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrq<__AsmMemoryOperand, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pextrq(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrq_rm64_xmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrq<__AsmRegister64, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pextrq(&mut self, op0: __AsmRegister64, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrq_rm64_xmm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrq<__AsmMemoryOperand, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pextrq(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrq_rm64_xmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrw<__AsmRegister32, __AsmRegisterMm, i32> for CodeAssembler {
	#[inline]
	fn pextrw(&mut self, op0: __AsmRegister32, op1: __AsmRegisterMm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrw_r32_mm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrw<__AsmRegister64, __AsmRegisterMm, i32> for CodeAssembler {
	#[inline]
	fn pextrw(&mut self, op0: __AsmRegister64, op1: __AsmRegisterMm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrw_r64_mm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrw<__AsmRegister32, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pextrw(&mut self, op0: __AsmRegister32, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrw_r32_xmm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrw<__AsmRegister64, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pextrw(&mut self, op0: __AsmRegister64, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrw_r64_xmm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrw<__AsmMemoryOperand, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pextrw(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrw_r32m16_xmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrw<__AsmRegister32, __AsmRegisterMm, u32> for CodeAssembler {
	#[inline]
	fn pextrw(&mut self, op0: __AsmRegister32, op1: __AsmRegisterMm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrw_r32_mm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrw<__AsmRegister64, __AsmRegisterMm, u32> for CodeAssembler {
	#[inline]
	fn pextrw(&mut self, op0: __AsmRegister64, op1: __AsmRegisterMm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrw_r64_mm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrw<__AsmRegister32, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pextrw(&mut self, op0: __AsmRegister32, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrw_r32_xmm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrw<__AsmRegister64, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pextrw(&mut self, op0: __AsmRegister64, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrw_r64_xmm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrw<__AsmMemoryOperand, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pextrw(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrw_r32m16_xmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPf2id<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pf2id(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pf2id_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPf2id<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pf2id(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pf2id_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPf2iw<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pf2iw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pf2iw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPf2iw<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pf2iw(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pf2iw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfacc<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pfacc(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfacc_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfacc<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pfacc(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfacc_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfadd<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pfadd(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfadd_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfadd<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pfadd(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfadd_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfcmpeq<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pfcmpeq(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfcmpeq_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfcmpeq<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pfcmpeq(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfcmpeq_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfcmpge<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pfcmpge(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfcmpge_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfcmpge<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pfcmpge(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfcmpge_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfcmpgt<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pfcmpgt(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfcmpgt_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfcmpgt<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pfcmpgt(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfcmpgt_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfmax<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pfmax(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfmax_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfmax<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pfmax(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfmax_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfmin<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pfmin(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfmin_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfmin<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pfmin(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfmin_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfmul<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pfmul(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfmul_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfmul<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pfmul(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfmul_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfnacc<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pfnacc(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfnacc_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfnacc<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pfnacc(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfnacc_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfpnacc<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pfpnacc(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfpnacc_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfpnacc<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pfpnacc(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfpnacc_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfrcp<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pfrcp(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfrcp_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfrcp<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pfrcp(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfrcp_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfrcpit1<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pfrcpit1(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfrcpit1_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfrcpit1<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pfrcpit1(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfrcpit1_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfrcpit2<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pfrcpit2(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfrcpit2_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfrcpit2<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pfrcpit2(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfrcpit2_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfrcpv<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pfrcpv(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfrcpv_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfrcpv<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pfrcpv(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfrcpv_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfrsqit1<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pfrsqit1(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfrsqit1_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfrsqit1<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pfrsqit1(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfrsqit1_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfrsqrt<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pfrsqrt(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfrsqrt_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfrsqrt<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pfrsqrt(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfrsqrt_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfrsqrtv<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pfrsqrtv(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfrsqrtv_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfrsqrtv<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pfrsqrtv(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfrsqrtv_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfsub<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pfsub(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfsub_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfsub<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pfsub(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfsub_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfsubr<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pfsubr(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfsubr_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfsubr<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pfsubr(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfsubr_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhaddd<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn phaddd(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phaddd_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhaddd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn phaddd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phaddd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhaddd<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn phaddd(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phaddd_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhaddd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn phaddd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phaddd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhaddsw<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn phaddsw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phaddsw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhaddsw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn phaddsw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phaddsw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhaddsw<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn phaddsw(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phaddsw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhaddsw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn phaddsw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phaddsw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhaddw<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn phaddw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phaddw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhaddw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn phaddw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phaddw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhaddw<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn phaddw(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phaddw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhaddw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn phaddw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phaddw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhminposuw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn phminposuw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phminposuw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhminposuw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn phminposuw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phminposuw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhsubd<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn phsubd(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phsubd_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhsubd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn phsubd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phsubd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhsubd<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn phsubd(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phsubd_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhsubd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn phsubd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phsubd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhsubsw<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn phsubsw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phsubsw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhsubsw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn phsubsw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phsubsw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhsubsw<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn phsubsw(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phsubsw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhsubsw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn phsubsw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phsubsw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhsubw<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn phsubw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phsubw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhsubw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn phsubw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phsubw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhsubw<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn phsubw(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phsubw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhsubw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn phsubw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phsubw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPi2fd<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pi2fd(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pi2fd_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPi2fd<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pi2fd(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pi2fd_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPi2fw<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pi2fw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pi2fw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPi2fw<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pi2fw(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pi2fw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrb<__AsmRegisterXmm, __AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn pinsrb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegister32, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrb_xmm_r32m8_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrb<__AsmRegisterXmm, __AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn pinsrb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegister64, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrb_xmm_r64m8_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrb<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn pinsrb(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrb_xmm_r32m8_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrb<__AsmRegisterXmm, __AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn pinsrb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegister32, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrb_xmm_r32m8_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrb<__AsmRegisterXmm, __AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn pinsrb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegister64, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrb_xmm_r64m8_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrb<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn pinsrb(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrb_xmm_r32m8_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrd<__AsmRegisterXmm, __AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn pinsrd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegister32, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrd_xmm_rm32_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrd<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn pinsrd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrd_xmm_rm32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrd<__AsmRegisterXmm, __AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn pinsrd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegister32, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrd_xmm_rm32_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrd<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn pinsrd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrd_xmm_rm32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrq<__AsmRegisterXmm, __AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn pinsrq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegister64, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrq_xmm_rm64_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrq<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn pinsrq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrq_xmm_rm64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrq<__AsmRegisterXmm, __AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn pinsrq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegister64, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrq_xmm_rm64_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrq<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn pinsrq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrq_xmm_rm64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrw<__AsmRegisterMm, __AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn pinsrw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegister32, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrw_mm_r32m16_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrw<__AsmRegisterXmm, __AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn pinsrw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegister32, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrw_xmm_r32m16_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrw<__AsmRegisterMm, __AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn pinsrw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegister64, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrw_mm_r64m16_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrw<__AsmRegisterXmm, __AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn pinsrw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegister64, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrw_xmm_r64m16_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrw<__AsmRegisterMm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn pinsrw(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrw_mm_r32m16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrw<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn pinsrw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrw_xmm_r32m16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrw<__AsmRegisterMm, __AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn pinsrw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegister32, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrw_mm_r32m16_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrw<__AsmRegisterXmm, __AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn pinsrw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegister32, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrw_xmm_r32m16_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrw<__AsmRegisterMm, __AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn pinsrw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegister64, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrw_mm_r64m16_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrw<__AsmRegisterXmm, __AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn pinsrw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegister64, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrw_xmm_r64m16_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrw<__AsmRegisterMm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn pinsrw(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrw_mm_r32m16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrw<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn pinsrw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrw_xmm_r32m16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmachriw<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmachriw(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmachriw_mm_m64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaddubsw<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pmaddubsw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaddubsw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaddubsw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmaddubsw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaddubsw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaddubsw<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmaddubsw(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaddubsw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaddubsw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmaddubsw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaddubsw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaddwd<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pmaddwd(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaddwd_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaddwd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmaddwd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaddwd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaddwd<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmaddwd(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaddwd_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaddwd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmaddwd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaddwd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmagw<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pmagw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmagw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmagw<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmagw(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmagw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaxsb<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmaxsb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaxsb_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaxsb<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmaxsb(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaxsb_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaxsd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmaxsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaxsd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaxsd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmaxsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaxsd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaxsw<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pmaxsw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaxsw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaxsw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmaxsw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaxsw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaxsw<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmaxsw(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaxsw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaxsw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmaxsw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaxsw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaxub<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pmaxub(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaxub_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaxub<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmaxub(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaxub_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaxub<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmaxub(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaxub_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaxub<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmaxub(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaxub_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaxud<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmaxud(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaxud_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaxud<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmaxud(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaxud_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaxuw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmaxuw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaxuw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaxuw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmaxuw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaxuw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPminsb<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pminsb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pminsb_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPminsb<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pminsb(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pminsb_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPminsd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pminsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pminsd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPminsd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pminsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pminsd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPminsw<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pminsw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pminsw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPminsw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pminsw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pminsw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPminsw<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pminsw(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pminsw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPminsw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pminsw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pminsw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPminub<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pminub(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pminub_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPminub<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pminub(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pminub_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPminub<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pminub(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pminub_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPminub<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pminub(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pminub_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPminud<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pminud(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pminud_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPminud<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pminud(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pminud_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPminuw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pminuw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pminuw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPminuw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pminuw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pminuw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovmskb<__AsmRegister32, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pmovmskb(&mut self, op0: __AsmRegister32, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovmskb_r32_mm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovmskb<__AsmRegister64, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pmovmskb(&mut self, op0: __AsmRegister64, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovmskb_r64_mm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovmskb<__AsmRegister32, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmovmskb(&mut self, op0: __AsmRegister32, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovmskb_r32_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovmskb<__AsmRegister64, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmovmskb(&mut self, op0: __AsmRegister64, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovmskb_r64_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovsxbd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmovsxbd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovsxbd_xmm_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovsxbd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmovsxbd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovsxbd_xmm_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovsxbq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmovsxbq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovsxbq_xmm_xmmm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovsxbq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmovsxbq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovsxbq_xmm_xmmm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovsxbw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmovsxbw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovsxbw_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovsxbw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmovsxbw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovsxbw_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovsxdq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmovsxdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovsxdq_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovsxdq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmovsxdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovsxdq_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovsxwd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmovsxwd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovsxwd_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovsxwd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmovsxwd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovsxwd_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovsxwq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmovsxwq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovsxwq_xmm_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovsxwq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmovsxwq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovsxwq_xmm_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovzxbd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmovzxbd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovzxbd_xmm_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovzxbd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmovzxbd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovzxbd_xmm_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovzxbq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmovzxbq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovzxbq_xmm_xmmm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovzxbq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmovzxbq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovzxbq_xmm_xmmm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovzxbw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmovzxbw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovzxbw_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovzxbw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmovzxbw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovzxbw_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovzxdq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmovzxdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovzxdq_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovzxdq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmovzxdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovzxdq_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovzxwd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmovzxwd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovzxwd_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovzxwd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmovzxwd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovzxwd_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovzxwq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmovzxwq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovzxwq_xmm_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovzxwq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmovzxwq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovzxwq_xmm_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmuldq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmuldq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmuldq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmuldq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmuldq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmuldq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmulhriw<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pmulhriw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmulhriw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmulhriw<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmulhriw(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmulhriw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmulhrsw<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pmulhrsw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmulhrsw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmulhrsw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmulhrsw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmulhrsw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmulhrsw<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmulhrsw(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmulhrsw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmulhrsw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmulhrsw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmulhrsw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmulhrw<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pmulhrw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pmulhrw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmulhrw<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmulhrw(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pmulhrw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmulhrw_cyrix<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pmulhrw_cyrix(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmulhrw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmulhrw_cyrix<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmulhrw_cyrix(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmulhrw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmulhuw<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pmulhuw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmulhuw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmulhuw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmulhuw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmulhuw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmulhuw<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmulhuw(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmulhuw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmulhuw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmulhuw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmulhuw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmulhw<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pmulhw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmulhw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmulhw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmulhw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmulhw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmulhw<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmulhw(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmulhw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmulhw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmulhw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmulhw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmulld<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmulld(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmulld_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmulld<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmulld(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmulld_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmullw<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pmullw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmullw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmullw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmullw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmullw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmullw<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmullw(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmullw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmullw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmullw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmullw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmuludq<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pmuludq(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmuludq_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmuludq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmuludq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmuludq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmuludq<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmuludq(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmuludq_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmuludq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmuludq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmuludq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmvgezb<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmvgezb(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmvgezb_mm_m64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmvlzb<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmvlzb(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmvlzb_mm_m64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmvnzb<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmvnzb(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmvnzb_mm_m64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmvzb<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmvzb(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmvzb_mm_m64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPop<__AsmRegister16> for CodeAssembler {
	#[inline]
	fn pop(&mut self, op0: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Pop_r16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPop<__AsmRegister32> for CodeAssembler {
	#[inline]
	fn pop(&mut self, op0: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Pop_r32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPop<__AsmRegister64> for CodeAssembler {
	#[inline]
	fn pop(&mut self, op0: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Pop_r64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPop<__AsmRegisterSegment> for CodeAssembler {
	fn pop(&mut self, op0: __AsmRegisterSegment) -> Result<(), IcedError> {
		let code = if op0.register() == Register::FS {
			if self.bitness() == 64 {
				Code::Popq_FS
			} else if self.bitness() >= 32 {
				Code::Popd_FS
			} else {
				Code::Popw_FS
			}
		} else if op0.register() == Register::GS {
			if self.bitness() == 64 {
				Code::Popq_GS
			} else if self.bitness() >= 32 {
				Code::Popd_GS
			} else {
				Code::Popw_GS
			}
		} else if op0.register() == Register::ES {
			if self.bitness() >= 32 { Code::Popd_ES } else { Code::Popw_ES }
		} else if op0.register() == Register::SS {
			if self.bitness() >= 32 { Code::Popd_SS } else { Code::Popw_SS }
		} else if op0.register() == Register::DS {
			if self.bitness() >= 32 { Code::Popd_DS } else { Code::Popw_DS }
		} else {
			return Err(IcedError::new("pop: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPop<__AsmMemoryOperand> for CodeAssembler {
	fn pop(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Pop_rm64
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Pop_rm32
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Pop_rm16
		} else {
			return Err(IcedError::new("pop: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPopa for CodeAssembler {
	#[inline]
	fn popa(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Popaw))
	}
}

#[rustfmt::skip]
impl CodeAsmPopad for CodeAssembler {
	#[inline]
	fn popad(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Popad))
	}
}

#[rustfmt::skip]
impl CodeAsmPopcnt<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn popcnt(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Popcnt_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPopcnt<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn popcnt(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Popcnt_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPopcnt<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn popcnt(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Popcnt_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPopcnt<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn popcnt(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Popcnt_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPopcnt<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn popcnt(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Popcnt_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPopcnt<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn popcnt(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Popcnt_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPopf for CodeAssembler {
	#[inline]
	fn popf(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Popfw))
	}
}

#[rustfmt::skip]
impl CodeAsmPopfd for CodeAssembler {
	#[inline]
	fn popfd(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Popfd))
	}
}

#[rustfmt::skip]
impl CodeAsmPopfq for CodeAssembler {
	#[inline]
	fn popfq(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Popfq))
	}
}

#[rustfmt::skip]
impl CodeAsmPor<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn por(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Por_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPor<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn por(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Por_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPor<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn por(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Por_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPor<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn por(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Por_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPrefetch<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn prefetch(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Prefetch_m8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPrefetchnta<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn prefetchnta(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Prefetchnta_m8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPrefetcht0<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn prefetcht0(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Prefetcht0_m8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPrefetcht1<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn prefetcht1(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Prefetcht1_m8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPrefetcht2<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn prefetcht2(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Prefetcht2_m8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPrefetchw<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn prefetchw(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Prefetchw_m8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPrefetchwt1<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn prefetchwt1(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Prefetchwt1_m8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsadbw<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn psadbw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psadbw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsadbw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn psadbw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psadbw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsadbw<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psadbw(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psadbw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsadbw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psadbw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psadbw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPshufb<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pshufb(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pshufb_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPshufb<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pshufb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pshufb_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPshufb<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pshufb(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pshufb_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPshufb<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pshufb(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pshufb_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPshufd<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pshufd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pshufd_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPshufd<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn pshufd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pshufd_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPshufd<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pshufd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pshufd_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPshufd<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn pshufd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pshufd_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPshufhw<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pshufhw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pshufhw_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPshufhw<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn pshufhw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pshufhw_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPshufhw<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pshufhw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pshufhw_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPshufhw<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn pshufhw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pshufhw_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPshuflw<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pshuflw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pshuflw_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPshuflw<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn pshuflw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pshuflw_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPshuflw<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pshuflw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pshuflw_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPshuflw<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn pshuflw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pshuflw_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPshufw<__AsmRegisterMm, __AsmRegisterMm, i32> for CodeAssembler {
	#[inline]
	fn pshufw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pshufw_mm_mmm64_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPshufw<__AsmRegisterMm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn pshufw(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pshufw_mm_mmm64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPshufw<__AsmRegisterMm, __AsmRegisterMm, u32> for CodeAssembler {
	#[inline]
	fn pshufw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pshufw_mm_mmm64_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPshufw<__AsmRegisterMm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn pshufw(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pshufw_mm_mmm64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsignb<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn psignb(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psignb_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsignb<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn psignb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psignb_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsignb<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psignb(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psignb_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsignb<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psignb(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psignb_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsignd<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn psignd(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psignd_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsignd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn psignd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psignd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsignd<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psignd(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psignd_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsignd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psignd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psignd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsignw<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn psignw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psignw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsignw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn psignw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psignw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsignw<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psignw(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psignw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsignw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psignw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psignw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPslld<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pslld(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pslld_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPslld<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pslld(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pslld_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPslld<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pslld(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pslld_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPslld<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pslld(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pslld_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPslld<__AsmRegisterMm, i32> for CodeAssembler {
	#[inline]
	fn pslld(&mut self, op0: __AsmRegisterMm, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pslld_mm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPslld<__AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pslld(&mut self, op0: __AsmRegisterXmm, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pslld_xmm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPslld<__AsmRegisterMm, u32> for CodeAssembler {
	#[inline]
	fn pslld(&mut self, op0: __AsmRegisterMm, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pslld_mm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPslld<__AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pslld(&mut self, op0: __AsmRegisterXmm, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pslld_xmm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPslldq<__AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pslldq(&mut self, op0: __AsmRegisterXmm, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pslldq_xmm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPslldq<__AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pslldq(&mut self, op0: __AsmRegisterXmm, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pslldq_xmm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsllq<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn psllq(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psllq_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsllq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn psllq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psllq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsllq<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psllq(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psllq_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsllq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psllq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psllq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsllq<__AsmRegisterMm, i32> for CodeAssembler {
	#[inline]
	fn psllq(&mut self, op0: __AsmRegisterMm, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psllq_mm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsllq<__AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn psllq(&mut self, op0: __AsmRegisterXmm, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psllq_xmm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsllq<__AsmRegisterMm, u32> for CodeAssembler {
	#[inline]
	fn psllq(&mut self, op0: __AsmRegisterMm, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psllq_mm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsllq<__AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn psllq(&mut self, op0: __AsmRegisterXmm, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psllq_xmm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsllw<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn psllw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psllw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsllw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn psllw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psllw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsllw<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psllw(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psllw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsllw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psllw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psllw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsllw<__AsmRegisterMm, i32> for CodeAssembler {
	#[inline]
	fn psllw(&mut self, op0: __AsmRegisterMm, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psllw_mm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsllw<__AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn psllw(&mut self, op0: __AsmRegisterXmm, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psllw_xmm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsllw<__AsmRegisterMm, u32> for CodeAssembler {
	#[inline]
	fn psllw(&mut self, op0: __AsmRegisterMm, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psllw_mm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsllw<__AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn psllw(&mut self, op0: __AsmRegisterXmm, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psllw_xmm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsmash for CodeAssembler {
	#[inline]
	fn psmash(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Psmash))
	}
}

#[rustfmt::skip]
impl CodeAsmPsrad<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn psrad(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrad_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrad<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn psrad(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrad_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrad<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psrad(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrad_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrad<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psrad(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrad_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrad<__AsmRegisterMm, i32> for CodeAssembler {
	#[inline]
	fn psrad(&mut self, op0: __AsmRegisterMm, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrad_mm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrad<__AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn psrad(&mut self, op0: __AsmRegisterXmm, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrad_xmm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrad<__AsmRegisterMm, u32> for CodeAssembler {
	#[inline]
	fn psrad(&mut self, op0: __AsmRegisterMm, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrad_mm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrad<__AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn psrad(&mut self, op0: __AsmRegisterXmm, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrad_xmm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsraw<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn psraw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psraw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsraw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn psraw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psraw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsraw<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psraw(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psraw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsraw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psraw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psraw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsraw<__AsmRegisterMm, i32> for CodeAssembler {
	#[inline]
	fn psraw(&mut self, op0: __AsmRegisterMm, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psraw_mm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsraw<__AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn psraw(&mut self, op0: __AsmRegisterXmm, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psraw_xmm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsraw<__AsmRegisterMm, u32> for CodeAssembler {
	#[inline]
	fn psraw(&mut self, op0: __AsmRegisterMm, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psraw_mm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsraw<__AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn psraw(&mut self, op0: __AsmRegisterXmm, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psraw_xmm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrld<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn psrld(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrld_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrld<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn psrld(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrld_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrld<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psrld(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrld_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrld<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psrld(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrld_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrld<__AsmRegisterMm, i32> for CodeAssembler {
	#[inline]
	fn psrld(&mut self, op0: __AsmRegisterMm, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrld_mm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrld<__AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn psrld(&mut self, op0: __AsmRegisterXmm, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrld_xmm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrld<__AsmRegisterMm, u32> for CodeAssembler {
	#[inline]
	fn psrld(&mut self, op0: __AsmRegisterMm, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrld_mm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrld<__AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn psrld(&mut self, op0: __AsmRegisterXmm, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrld_xmm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrldq<__AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn psrldq(&mut self, op0: __AsmRegisterXmm, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrldq_xmm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrldq<__AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn psrldq(&mut self, op0: __AsmRegisterXmm, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrldq_xmm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrlq<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn psrlq(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrlq_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrlq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn psrlq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrlq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrlq<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psrlq(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrlq_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrlq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psrlq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrlq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrlq<__AsmRegisterMm, i32> for CodeAssembler {
	#[inline]
	fn psrlq(&mut self, op0: __AsmRegisterMm, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrlq_mm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrlq<__AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn psrlq(&mut self, op0: __AsmRegisterXmm, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrlq_xmm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrlq<__AsmRegisterMm, u32> for CodeAssembler {
	#[inline]
	fn psrlq(&mut self, op0: __AsmRegisterMm, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrlq_mm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrlq<__AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn psrlq(&mut self, op0: __AsmRegisterXmm, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrlq_xmm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrlw<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn psrlw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrlw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrlw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn psrlw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrlw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrlw<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psrlw(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrlw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrlw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psrlw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrlw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrlw<__AsmRegisterMm, i32> for CodeAssembler {
	#[inline]
	fn psrlw(&mut self, op0: __AsmRegisterMm, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrlw_mm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrlw<__AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn psrlw(&mut self, op0: __AsmRegisterXmm, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrlw_xmm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrlw<__AsmRegisterMm, u32> for CodeAssembler {
	#[inline]
	fn psrlw(&mut self, op0: __AsmRegisterMm, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrlw_mm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrlw<__AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn psrlw(&mut self, op0: __AsmRegisterXmm, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrlw_xmm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubb<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn psubb(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubb_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubb<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn psubb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubb_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubb<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psubb(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubb_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubb<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psubb(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubb_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubd<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn psubd(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubd_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn psubd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubd<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psubd(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubd_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psubd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubq<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn psubq(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubq_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn psubq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubq<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psubq(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubq_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psubq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubsb<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn psubsb(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubsb_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubsb<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn psubsb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubsb_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubsb<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psubsb(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubsb_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubsb<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psubsb(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubsb_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubsiw<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn psubsiw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubsiw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubsiw<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psubsiw(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubsiw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubsw<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn psubsw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubsw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubsw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn psubsw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubsw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubsw<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psubsw(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubsw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubsw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psubsw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubsw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubusb<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn psubusb(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubusb_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubusb<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn psubusb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubusb_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubusb<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psubusb(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubusb_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubusb<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psubusb(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubusb_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubusw<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn psubusw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubusw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubusw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn psubusw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubusw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubusw<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psubusw(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubusw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubusw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psubusw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubusw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubw<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn psubw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn psubw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubw<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psubw(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psubw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPswapd<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pswapd(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pswapd_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPswapd<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pswapd(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pswapd_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPtest<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn ptest(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ptest_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPtest<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn ptest(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ptest_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPtwrite<__AsmRegister32> for CodeAssembler {
	#[inline]
	fn ptwrite(&mut self, op0: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Ptwrite_rm32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPtwrite<__AsmRegister64> for CodeAssembler {
	#[inline]
	fn ptwrite(&mut self, op0: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Ptwrite_rm64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPtwrite<__AsmMemoryOperand> for CodeAssembler {
	fn ptwrite(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Ptwrite_rm64
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Ptwrite_rm32
		} else {
			return Err(IcedError::new("ptwrite: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpckhbw<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn punpckhbw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpckhbw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpckhbw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn punpckhbw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpckhbw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpckhbw<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn punpckhbw(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpckhbw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpckhbw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn punpckhbw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpckhbw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpckhdq<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn punpckhdq(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpckhdq_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpckhdq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn punpckhdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpckhdq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpckhdq<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn punpckhdq(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpckhdq_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpckhdq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn punpckhdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpckhdq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpckhqdq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn punpckhqdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpckhqdq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpckhqdq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn punpckhqdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpckhqdq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpckhwd<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn punpckhwd(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpckhwd_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpckhwd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn punpckhwd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpckhwd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpckhwd<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn punpckhwd(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpckhwd_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpckhwd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn punpckhwd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpckhwd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpcklbw<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn punpcklbw(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpcklbw_mm_mmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpcklbw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn punpcklbw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpcklbw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpcklbw<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn punpcklbw(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpcklbw_mm_mmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpcklbw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn punpcklbw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpcklbw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpckldq<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn punpckldq(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpckldq_mm_mmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpckldq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn punpckldq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpckldq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpckldq<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn punpckldq(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpckldq_mm_mmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpckldq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn punpckldq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpckldq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpcklqdq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn punpcklqdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpcklqdq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpcklqdq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn punpcklqdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpcklqdq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpcklwd<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn punpcklwd(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpcklwd_mm_mmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpcklwd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn punpcklwd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpcklwd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpcklwd<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn punpcklwd(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpcklwd_mm_mmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpcklwd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn punpcklwd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpcklwd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPush<__AsmRegister16> for CodeAssembler {
	#[inline]
	fn push(&mut self, op0: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Push_r16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPush<__AsmRegister32> for CodeAssembler {
	#[inline]
	fn push(&mut self, op0: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Push_r32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPush<__AsmRegister64> for CodeAssembler {
	#[inline]
	fn push(&mut self, op0: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Push_r64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPush<__AsmRegisterSegment> for CodeAssembler {
	fn push(&mut self, op0: __AsmRegisterSegment) -> Result<(), IcedError> {
		let code = if op0.register() == Register::FS {
			if self.bitness() == 64 {
				Code::Pushq_FS
			} else if self.bitness() >= 32 {
				Code::Pushd_FS
			} else {
				Code::Pushw_FS
			}
		} else if op0.register() == Register::GS {
			if self.bitness() == 64 {
				Code::Pushq_GS
			} else if self.bitness() >= 32 {
				Code::Pushd_GS
			} else {
				Code::Pushw_GS
			}
		} else if op0.register() == Register::ES {
			if self.bitness() >= 32 { Code::Pushd_ES } else { Code::Pushw_ES }
		} else if op0.register() == Register::CS {
			if self.bitness() >= 32 { Code::Pushd_CS } else { Code::Pushw_CS }
		} else if op0.register() == Register::SS {
			if self.bitness() >= 32 { Code::Pushd_SS } else { Code::Pushw_SS }
		} else if op0.register() == Register::DS {
			if self.bitness() >= 32 { Code::Pushd_DS } else { Code::Pushw_DS }
		} else {
			return Err(IcedError::new("push: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPush<__AsmMemoryOperand> for CodeAssembler {
	fn push(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Push_rm64
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Push_rm32
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Push_rm16
		} else {
			return Err(IcedError::new("push: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPush<i32> for CodeAssembler {
	fn push(&mut self, op0: i32) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			if op0 >= i8::MIN as i32 && op0 <= i8::MAX as i32 { Code::Pushq_imm8 } else { Code::Pushq_imm32 }
		} else if self.bitness() >= 32 {
			if op0 >= i8::MIN as i32 && op0 <= i8::MAX as i32 { Code::Pushd_imm8 } else { Code::Pushd_imm32 }
		} else if self.bitness() >= 16 {
			if op0 >= i8::MIN as i32 && op0 <= i8::MAX as i32 { Code::Pushw_imm8 } else { Code::Push_imm16 }
		} else {
			return Err(IcedError::new("push: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPush<u32> for CodeAssembler {
	fn push(&mut self, op0: u32) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 {
			if op0 <= i8::MAX as u32 || 0xFFFF_FF80 <= op0 { Code::Pushd_imm8 } else { Code::Pushd_imm32 }
		} else if self.bitness() >= 16 {
			if op0 <= i8::MAX as u32 || (0xFF80 <= op0 && op0 <= 0xFFFF) { Code::Pushw_imm8 } else { Code::Push_imm16 }
		} else {
			return Err(IcedError::new("push: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPusha for CodeAssembler {
	#[inline]
	fn pusha(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Pushaw))
	}
}

#[rustfmt::skip]
impl CodeAsmPushad for CodeAssembler {
	#[inline]
	fn pushad(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Pushad))
	}
}

#[rustfmt::skip]
impl CodeAsmPushf for CodeAssembler {
	#[inline]
	fn pushf(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Pushfw))
	}
}

#[rustfmt::skip]
impl CodeAsmPushfd for CodeAssembler {
	#[inline]
	fn pushfd(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Pushfd))
	}
}

#[rustfmt::skip]
impl CodeAsmPushfq for CodeAssembler {
	#[inline]
	fn pushfq(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Pushfq))
	}
}

#[rustfmt::skip]
impl CodeAsmPvalidate for CodeAssembler {
	fn pvalidate(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Pvalidateq
		} else if self.bitness() >= 32 {
			Code::Pvalidated
		} else {
			Code::Pvalidatew
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmPxor<__AsmRegisterMm, __AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pxor(&mut self, op0: __AsmRegisterMm, op1: __AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pxor_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPxor<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pxor(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pxor_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPxor<__AsmRegisterMm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pxor(&mut self, op0: __AsmRegisterMm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pxor_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPxor<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pxor(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pxor_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcl<__AsmRegister8, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn rcl(&mut self, op0: __AsmRegister8, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rcl_rm8_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcl<__AsmRegister16, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn rcl(&mut self, op0: __AsmRegister16, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rcl_rm16_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcl<__AsmRegister32, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn rcl(&mut self, op0: __AsmRegister32, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rcl_rm32_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcl<__AsmRegister64, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn rcl(&mut self, op0: __AsmRegister64, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rcl_rm64_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcl<__AsmMemoryOperand, __AsmRegister8> for CodeAssembler {
	fn rcl(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister8) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Rcl_rm64_CL
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Rcl_rm32_CL
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Rcl_rm16_CL
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Rcl_rm8_CL
		} else {
			return Err(IcedError::new("rcl: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcl<__AsmRegister8, i32> for CodeAssembler {
	#[inline]
	fn rcl(&mut self, op0: __AsmRegister8, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rcl_rm8_1 } else { Code::Rcl_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcl<__AsmRegister16, i32> for CodeAssembler {
	#[inline]
	fn rcl(&mut self, op0: __AsmRegister16, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rcl_rm16_1 } else { Code::Rcl_rm16_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcl<__AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn rcl(&mut self, op0: __AsmRegister32, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rcl_rm32_1 } else { Code::Rcl_rm32_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcl<__AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn rcl(&mut self, op0: __AsmRegister64, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rcl_rm64_1 } else { Code::Rcl_rm64_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcl<__AsmMemoryOperand, i32> for CodeAssembler {
	fn rcl(&mut self, op0: __AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 {
			if op0.size() == MemoryOperandSize::Qword {
				Code::Rcl_rm64_1
			} else if op0.size() == MemoryOperandSize::Dword {
				Code::Rcl_rm32_1
			} else if op0.size() == MemoryOperandSize::Word {
				Code::Rcl_rm16_1
			} else if op0.size() == MemoryOperandSize::Byte {
				Code::Rcl_rm8_1
			} else {
				return Err(IcedError::new("rcl: invalid operands"));
			}
		} else if op0.size() == MemoryOperandSize::Qword {
			Code::Rcl_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Rcl_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Rcl_rm16_imm8
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Rcl_rm8_imm8
		} else {
			return Err(IcedError::new("rcl: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcl<__AsmRegister8, u32> for CodeAssembler {
	#[inline]
	fn rcl(&mut self, op0: __AsmRegister8, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rcl_rm8_1 } else { Code::Rcl_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcl<__AsmRegister16, u32> for CodeAssembler {
	#[inline]
	fn rcl(&mut self, op0: __AsmRegister16, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rcl_rm16_1 } else { Code::Rcl_rm16_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcl<__AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn rcl(&mut self, op0: __AsmRegister32, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rcl_rm32_1 } else { Code::Rcl_rm32_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcl<__AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn rcl(&mut self, op0: __AsmRegister64, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rcl_rm64_1 } else { Code::Rcl_rm64_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcl<__AsmMemoryOperand, u32> for CodeAssembler {
	fn rcl(&mut self, op0: __AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 {
			if op0.size() == MemoryOperandSize::Qword {
				Code::Rcl_rm64_1
			} else if op0.size() == MemoryOperandSize::Dword {
				Code::Rcl_rm32_1
			} else if op0.size() == MemoryOperandSize::Word {
				Code::Rcl_rm16_1
			} else if op0.size() == MemoryOperandSize::Byte {
				Code::Rcl_rm8_1
			} else {
				return Err(IcedError::new("rcl: invalid operands"));
			}
		} else if op0.size() == MemoryOperandSize::Qword {
			Code::Rcl_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Rcl_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Rcl_rm16_imm8
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Rcl_rm8_imm8
		} else {
			return Err(IcedError::new("rcl: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcpps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn rcpps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rcpps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcpps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn rcpps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rcpps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcpss<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn rcpss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rcpss_xmm_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcpss<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn rcpss(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rcpss_xmm_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcr<__AsmRegister8, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn rcr(&mut self, op0: __AsmRegister8, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rcr_rm8_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcr<__AsmRegister16, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn rcr(&mut self, op0: __AsmRegister16, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rcr_rm16_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcr<__AsmRegister32, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn rcr(&mut self, op0: __AsmRegister32, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rcr_rm32_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcr<__AsmRegister64, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn rcr(&mut self, op0: __AsmRegister64, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rcr_rm64_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcr<__AsmMemoryOperand, __AsmRegister8> for CodeAssembler {
	fn rcr(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister8) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Rcr_rm64_CL
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Rcr_rm32_CL
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Rcr_rm16_CL
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Rcr_rm8_CL
		} else {
			return Err(IcedError::new("rcr: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcr<__AsmRegister8, i32> for CodeAssembler {
	#[inline]
	fn rcr(&mut self, op0: __AsmRegister8, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rcr_rm8_1 } else { Code::Rcr_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcr<__AsmRegister16, i32> for CodeAssembler {
	#[inline]
	fn rcr(&mut self, op0: __AsmRegister16, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rcr_rm16_1 } else { Code::Rcr_rm16_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcr<__AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn rcr(&mut self, op0: __AsmRegister32, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rcr_rm32_1 } else { Code::Rcr_rm32_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcr<__AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn rcr(&mut self, op0: __AsmRegister64, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rcr_rm64_1 } else { Code::Rcr_rm64_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcr<__AsmMemoryOperand, i32> for CodeAssembler {
	fn rcr(&mut self, op0: __AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 {
			if op0.size() == MemoryOperandSize::Qword {
				Code::Rcr_rm64_1
			} else if op0.size() == MemoryOperandSize::Dword {
				Code::Rcr_rm32_1
			} else if op0.size() == MemoryOperandSize::Word {
				Code::Rcr_rm16_1
			} else if op0.size() == MemoryOperandSize::Byte {
				Code::Rcr_rm8_1
			} else {
				return Err(IcedError::new("rcr: invalid operands"));
			}
		} else if op0.size() == MemoryOperandSize::Qword {
			Code::Rcr_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Rcr_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Rcr_rm16_imm8
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Rcr_rm8_imm8
		} else {
			return Err(IcedError::new("rcr: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcr<__AsmRegister8, u32> for CodeAssembler {
	#[inline]
	fn rcr(&mut self, op0: __AsmRegister8, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rcr_rm8_1 } else { Code::Rcr_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcr<__AsmRegister16, u32> for CodeAssembler {
	#[inline]
	fn rcr(&mut self, op0: __AsmRegister16, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rcr_rm16_1 } else { Code::Rcr_rm16_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcr<__AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn rcr(&mut self, op0: __AsmRegister32, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rcr_rm32_1 } else { Code::Rcr_rm32_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcr<__AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn rcr(&mut self, op0: __AsmRegister64, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rcr_rm64_1 } else { Code::Rcr_rm64_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcr<__AsmMemoryOperand, u32> for CodeAssembler {
	fn rcr(&mut self, op0: __AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 {
			if op0.size() == MemoryOperandSize::Qword {
				Code::Rcr_rm64_1
			} else if op0.size() == MemoryOperandSize::Dword {
				Code::Rcr_rm32_1
			} else if op0.size() == MemoryOperandSize::Word {
				Code::Rcr_rm16_1
			} else if op0.size() == MemoryOperandSize::Byte {
				Code::Rcr_rm8_1
			} else {
				return Err(IcedError::new("rcr: invalid operands"));
			}
		} else if op0.size() == MemoryOperandSize::Qword {
			Code::Rcr_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Rcr_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Rcr_rm16_imm8
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Rcr_rm8_imm8
		} else {
			return Err(IcedError::new("rcr: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRdfsbase<__AsmRegister32> for CodeAssembler {
	#[inline]
	fn rdfsbase(&mut self, op0: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Rdfsbase_r32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRdfsbase<__AsmRegister64> for CodeAssembler {
	#[inline]
	fn rdfsbase(&mut self, op0: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Rdfsbase_r64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRdgsbase<__AsmRegister32> for CodeAssembler {
	#[inline]
	fn rdgsbase(&mut self, op0: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Rdgsbase_r32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRdgsbase<__AsmRegister64> for CodeAssembler {
	#[inline]
	fn rdgsbase(&mut self, op0: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Rdgsbase_r64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRdm for CodeAssembler {
	#[inline]
	fn rdm(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Rdm))
	}
}

#[rustfmt::skip]
impl CodeAsmRdmsr for CodeAssembler {
	#[inline]
	fn rdmsr(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Rdmsr))
	}
}

#[rustfmt::skip]
impl CodeAsmRdpid<__AsmRegister32> for CodeAssembler {
	#[inline]
	fn rdpid(&mut self, op0: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Rdpid_r32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRdpid<__AsmRegister64> for CodeAssembler {
	#[inline]
	fn rdpid(&mut self, op0: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Rdpid_r64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRdpkru for CodeAssembler {
	#[inline]
	fn rdpkru(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Rdpkru))
	}
}

#[rustfmt::skip]
impl CodeAsmRdpmc for CodeAssembler {
	#[inline]
	fn rdpmc(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Rdpmc))
	}
}

#[rustfmt::skip]
impl CodeAsmRdpru for CodeAssembler {
	#[inline]
	fn rdpru(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Rdpru))
	}
}

#[rustfmt::skip]
impl CodeAsmRdrand<__AsmRegister16> for CodeAssembler {
	#[inline]
	fn rdrand(&mut self, op0: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Rdrand_r16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRdrand<__AsmRegister32> for CodeAssembler {
	#[inline]
	fn rdrand(&mut self, op0: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Rdrand_r32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRdrand<__AsmRegister64> for CodeAssembler {
	#[inline]
	fn rdrand(&mut self, op0: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Rdrand_r64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRdseed<__AsmRegister16> for CodeAssembler {
	#[inline]
	fn rdseed(&mut self, op0: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Rdseed_r16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRdseed<__AsmRegister32> for CodeAssembler {
	#[inline]
	fn rdseed(&mut self, op0: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Rdseed_r32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRdseed<__AsmRegister64> for CodeAssembler {
	#[inline]
	fn rdseed(&mut self, op0: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Rdseed_r64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRdshr<__AsmRegister32> for CodeAssembler {
	#[inline]
	fn rdshr(&mut self, op0: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Rdshr_rm32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRdshr<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn rdshr(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Rdshr_rm32, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmRdsspd<__AsmRegister32> for CodeAssembler {
	#[inline]
	fn rdsspd(&mut self, op0: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Rdsspd_r32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRdsspq<__AsmRegister64> for CodeAssembler {
	#[inline]
	fn rdsspq(&mut self, op0: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Rdsspq_r64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRdtsc for CodeAssembler {
	#[inline]
	fn rdtsc(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Rdtsc))
	}
}

#[rustfmt::skip]
impl CodeAsmRdtscp for CodeAssembler {
	#[inline]
	fn rdtscp(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Rdtscp))
	}
}

#[rustfmt::skip]
impl CodeAsmRdudbg for CodeAssembler {
	#[inline]
	fn rdudbg(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Rdudbg))
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f0d<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn reservednop_0f0d(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm16_r16_0F0D, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f0d<__AsmMemoryOperand, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn reservednop_0f0d(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm16_r16_0F0D, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f0d<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn reservednop_0f0d(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm32_r32_0F0D, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f0d<__AsmMemoryOperand, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn reservednop_0f0d(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm32_r32_0F0D, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f0d<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn reservednop_0f0d(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm64_r64_0F0D, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f0d<__AsmMemoryOperand, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn reservednop_0f0d(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm64_r64_0F0D, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f18<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn reservednop_0f18(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm16_r16_0F18, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f18<__AsmMemoryOperand, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn reservednop_0f18(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm16_r16_0F18, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f18<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn reservednop_0f18(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm32_r32_0F18, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f18<__AsmMemoryOperand, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn reservednop_0f18(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm32_r32_0F18, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f18<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn reservednop_0f18(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm64_r64_0F18, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f18<__AsmMemoryOperand, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn reservednop_0f18(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm64_r64_0F18, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f19<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn reservednop_0f19(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm16_r16_0F19, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f19<__AsmMemoryOperand, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn reservednop_0f19(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm16_r16_0F19, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f19<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn reservednop_0f19(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm32_r32_0F19, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f19<__AsmMemoryOperand, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn reservednop_0f19(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm32_r32_0F19, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f19<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn reservednop_0f19(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm64_r64_0F19, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f19<__AsmMemoryOperand, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn reservednop_0f19(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm64_r64_0F19, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1a<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn reservednop_0f1a(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm16_r16_0F1A, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1a<__AsmMemoryOperand, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn reservednop_0f1a(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm16_r16_0F1A, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1a<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn reservednop_0f1a(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm32_r32_0F1A, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1a<__AsmMemoryOperand, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn reservednop_0f1a(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm32_r32_0F1A, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1a<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn reservednop_0f1a(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm64_r64_0F1A, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1a<__AsmMemoryOperand, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn reservednop_0f1a(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm64_r64_0F1A, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1b<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn reservednop_0f1b(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm16_r16_0F1B, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1b<__AsmMemoryOperand, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn reservednop_0f1b(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm16_r16_0F1B, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1b<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn reservednop_0f1b(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm32_r32_0F1B, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1b<__AsmMemoryOperand, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn reservednop_0f1b(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm32_r32_0F1B, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1b<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn reservednop_0f1b(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm64_r64_0F1B, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1b<__AsmMemoryOperand, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn reservednop_0f1b(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm64_r64_0F1B, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1c<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn reservednop_0f1c(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm16_r16_0F1C, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1c<__AsmMemoryOperand, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn reservednop_0f1c(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm16_r16_0F1C, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1c<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn reservednop_0f1c(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm32_r32_0F1C, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1c<__AsmMemoryOperand, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn reservednop_0f1c(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm32_r32_0F1C, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1c<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn reservednop_0f1c(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm64_r64_0F1C, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1c<__AsmMemoryOperand, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn reservednop_0f1c(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm64_r64_0F1C, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1d<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn reservednop_0f1d(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm16_r16_0F1D, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1d<__AsmMemoryOperand, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn reservednop_0f1d(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm16_r16_0F1D, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1d<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn reservednop_0f1d(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm32_r32_0F1D, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1d<__AsmMemoryOperand, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn reservednop_0f1d(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm32_r32_0F1D, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1d<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn reservednop_0f1d(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm64_r64_0F1D, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1d<__AsmMemoryOperand, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn reservednop_0f1d(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm64_r64_0F1D, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1e<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn reservednop_0f1e(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm16_r16_0F1E, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1e<__AsmMemoryOperand, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn reservednop_0f1e(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm16_r16_0F1E, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1e<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn reservednop_0f1e(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm32_r32_0F1E, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1e<__AsmMemoryOperand, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn reservednop_0f1e(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm32_r32_0F1E, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1e<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn reservednop_0f1e(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm64_r64_0F1E, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1e<__AsmMemoryOperand, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn reservednop_0f1e(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm64_r64_0F1E, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1f<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn reservednop_0f1f(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm16_r16_0F1F, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1f<__AsmMemoryOperand, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn reservednop_0f1f(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm16_r16_0F1F, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1f<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn reservednop_0f1f(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm32_r32_0F1F, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1f<__AsmMemoryOperand, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn reservednop_0f1f(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm32_r32_0F1F, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1f<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn reservednop_0f1f(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm64_r64_0F1F, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1f<__AsmMemoryOperand, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn reservednop_0f1f(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm64_r64_0F1F, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRet for CodeAssembler {
	fn ret(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Retnq
		} else if self.bitness() >= 32 {
			Code::Retnd
		} else {
			Code::Retnw
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmRet1<i32> for CodeAssembler {
	fn ret_1(&mut self, op0: i32) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Retnq_imm16
		} else if self.bitness() >= 32 {
			Code::Retnd_imm16
		} else {
			Code::Retnw_imm16
		};
		self.add_instr(Instruction::with1(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRet1<u32> for CodeAssembler {
	fn ret_1(&mut self, op0: u32) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Retnq_imm16
		} else if self.bitness() >= 32 {
			Code::Retnd_imm16
		} else {
			Code::Retnw_imm16
		};
		self.add_instr(Instruction::with1(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRetf for CodeAssembler {
	fn retf(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Retfq
		} else if self.bitness() >= 32 {
			Code::Retfd
		} else {
			Code::Retfw
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmRetf1<i32> for CodeAssembler {
	fn retf_1(&mut self, op0: i32) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Retfq_imm16
		} else if self.bitness() >= 32 {
			Code::Retfd_imm16
		} else {
			Code::Retfw_imm16
		};
		self.add_instr(Instruction::with1(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRetf1<u32> for CodeAssembler {
	fn retf_1(&mut self, op0: u32) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Retfq_imm16
		} else if self.bitness() >= 32 {
			Code::Retfd_imm16
		} else {
			Code::Retfw_imm16
		};
		self.add_instr(Instruction::with1(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRmpadjust for CodeAssembler {
	#[inline]
	fn rmpadjust(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Rmpadjust))
	}
}

#[rustfmt::skip]
impl CodeAsmRmpupdate for CodeAssembler {
	#[inline]
	fn rmpupdate(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Rmpupdate))
	}
}

#[rustfmt::skip]
impl CodeAsmRol<__AsmRegister8, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn rol(&mut self, op0: __AsmRegister8, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rol_rm8_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRol<__AsmRegister16, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn rol(&mut self, op0: __AsmRegister16, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rol_rm16_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRol<__AsmRegister32, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn rol(&mut self, op0: __AsmRegister32, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rol_rm32_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRol<__AsmRegister64, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn rol(&mut self, op0: __AsmRegister64, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rol_rm64_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRol<__AsmMemoryOperand, __AsmRegister8> for CodeAssembler {
	fn rol(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister8) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Rol_rm64_CL
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Rol_rm32_CL
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Rol_rm16_CL
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Rol_rm8_CL
		} else {
			return Err(IcedError::new("rol: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRol<__AsmRegister8, i32> for CodeAssembler {
	#[inline]
	fn rol(&mut self, op0: __AsmRegister8, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rol_rm8_1 } else { Code::Rol_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRol<__AsmRegister16, i32> for CodeAssembler {
	#[inline]
	fn rol(&mut self, op0: __AsmRegister16, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rol_rm16_1 } else { Code::Rol_rm16_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRol<__AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn rol(&mut self, op0: __AsmRegister32, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rol_rm32_1 } else { Code::Rol_rm32_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRol<__AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn rol(&mut self, op0: __AsmRegister64, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rol_rm64_1 } else { Code::Rol_rm64_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRol<__AsmMemoryOperand, i32> for CodeAssembler {
	fn rol(&mut self, op0: __AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 {
			if op0.size() == MemoryOperandSize::Qword {
				Code::Rol_rm64_1
			} else if op0.size() == MemoryOperandSize::Dword {
				Code::Rol_rm32_1
			} else if op0.size() == MemoryOperandSize::Word {
				Code::Rol_rm16_1
			} else if op0.size() == MemoryOperandSize::Byte {
				Code::Rol_rm8_1
			} else {
				return Err(IcedError::new("rol: invalid operands"));
			}
		} else if op0.size() == MemoryOperandSize::Qword {
			Code::Rol_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Rol_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Rol_rm16_imm8
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Rol_rm8_imm8
		} else {
			return Err(IcedError::new("rol: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRol<__AsmRegister8, u32> for CodeAssembler {
	#[inline]
	fn rol(&mut self, op0: __AsmRegister8, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rol_rm8_1 } else { Code::Rol_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRol<__AsmRegister16, u32> for CodeAssembler {
	#[inline]
	fn rol(&mut self, op0: __AsmRegister16, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rol_rm16_1 } else { Code::Rol_rm16_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRol<__AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn rol(&mut self, op0: __AsmRegister32, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rol_rm32_1 } else { Code::Rol_rm32_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRol<__AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn rol(&mut self, op0: __AsmRegister64, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rol_rm64_1 } else { Code::Rol_rm64_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRol<__AsmMemoryOperand, u32> for CodeAssembler {
	fn rol(&mut self, op0: __AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 {
			if op0.size() == MemoryOperandSize::Qword {
				Code::Rol_rm64_1
			} else if op0.size() == MemoryOperandSize::Dword {
				Code::Rol_rm32_1
			} else if op0.size() == MemoryOperandSize::Word {
				Code::Rol_rm16_1
			} else if op0.size() == MemoryOperandSize::Byte {
				Code::Rol_rm8_1
			} else {
				return Err(IcedError::new("rol: invalid operands"));
			}
		} else if op0.size() == MemoryOperandSize::Qword {
			Code::Rol_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Rol_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Rol_rm16_imm8
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Rol_rm8_imm8
		} else {
			return Err(IcedError::new("rol: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRor<__AsmRegister8, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn ror(&mut self, op0: __AsmRegister8, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ror_rm8_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRor<__AsmRegister16, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn ror(&mut self, op0: __AsmRegister16, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ror_rm16_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRor<__AsmRegister32, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn ror(&mut self, op0: __AsmRegister32, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ror_rm32_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRor<__AsmRegister64, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn ror(&mut self, op0: __AsmRegister64, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ror_rm64_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRor<__AsmMemoryOperand, __AsmRegister8> for CodeAssembler {
	fn ror(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister8) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Ror_rm64_CL
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Ror_rm32_CL
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Ror_rm16_CL
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Ror_rm8_CL
		} else {
			return Err(IcedError::new("ror: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRor<__AsmRegister8, i32> for CodeAssembler {
	#[inline]
	fn ror(&mut self, op0: __AsmRegister8, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Ror_rm8_1 } else { Code::Ror_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRor<__AsmRegister16, i32> for CodeAssembler {
	#[inline]
	fn ror(&mut self, op0: __AsmRegister16, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Ror_rm16_1 } else { Code::Ror_rm16_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRor<__AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn ror(&mut self, op0: __AsmRegister32, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Ror_rm32_1 } else { Code::Ror_rm32_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRor<__AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn ror(&mut self, op0: __AsmRegister64, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Ror_rm64_1 } else { Code::Ror_rm64_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRor<__AsmMemoryOperand, i32> for CodeAssembler {
	fn ror(&mut self, op0: __AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 {
			if op0.size() == MemoryOperandSize::Qword {
				Code::Ror_rm64_1
			} else if op0.size() == MemoryOperandSize::Dword {
				Code::Ror_rm32_1
			} else if op0.size() == MemoryOperandSize::Word {
				Code::Ror_rm16_1
			} else if op0.size() == MemoryOperandSize::Byte {
				Code::Ror_rm8_1
			} else {
				return Err(IcedError::new("ror: invalid operands"));
			}
		} else if op0.size() == MemoryOperandSize::Qword {
			Code::Ror_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Ror_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Ror_rm16_imm8
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Ror_rm8_imm8
		} else {
			return Err(IcedError::new("ror: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRor<__AsmRegister8, u32> for CodeAssembler {
	#[inline]
	fn ror(&mut self, op0: __AsmRegister8, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Ror_rm8_1 } else { Code::Ror_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRor<__AsmRegister16, u32> for CodeAssembler {
	#[inline]
	fn ror(&mut self, op0: __AsmRegister16, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Ror_rm16_1 } else { Code::Ror_rm16_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRor<__AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn ror(&mut self, op0: __AsmRegister32, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Ror_rm32_1 } else { Code::Ror_rm32_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRor<__AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn ror(&mut self, op0: __AsmRegister64, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Ror_rm64_1 } else { Code::Ror_rm64_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRor<__AsmMemoryOperand, u32> for CodeAssembler {
	fn ror(&mut self, op0: __AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 {
			if op0.size() == MemoryOperandSize::Qword {
				Code::Ror_rm64_1
			} else if op0.size() == MemoryOperandSize::Dword {
				Code::Ror_rm32_1
			} else if op0.size() == MemoryOperandSize::Word {
				Code::Ror_rm16_1
			} else if op0.size() == MemoryOperandSize::Byte {
				Code::Ror_rm8_1
			} else {
				return Err(IcedError::new("ror: invalid operands"));
			}
		} else if op0.size() == MemoryOperandSize::Qword {
			Code::Ror_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Ror_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Ror_rm16_imm8
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Ror_rm8_imm8
		} else {
			return Err(IcedError::new("ror: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRorx<__AsmRegister32, __AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn rorx(&mut self, op0: __AsmRegister32, op1: __AsmRegister32, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Rorx_r32_rm32_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRorx<__AsmRegister64, __AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn rorx(&mut self, op0: __AsmRegister64, op1: __AsmRegister64, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Rorx_r64_rm64_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRorx<__AsmRegister32, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn rorx(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Rorx_r32_rm32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRorx<__AsmRegister64, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn rorx(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Rorx_r64_rm64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRorx<__AsmRegister32, __AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn rorx(&mut self, op0: __AsmRegister32, op1: __AsmRegister32, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Rorx_r32_rm32_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRorx<__AsmRegister64, __AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn rorx(&mut self, op0: __AsmRegister64, op1: __AsmRegister64, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Rorx_r64_rm64_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRorx<__AsmRegister32, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn rorx(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Rorx_r32_rm32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRorx<__AsmRegister64, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn rorx(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Rorx_r64_rm64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRoundpd<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn roundpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Roundpd_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRoundpd<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn roundpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Roundpd_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRoundpd<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn roundpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Roundpd_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRoundpd<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn roundpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Roundpd_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRoundps<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn roundps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Roundps_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRoundps<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn roundps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Roundps_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRoundps<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn roundps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Roundps_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRoundps<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn roundps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Roundps_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRoundsd<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn roundsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Roundsd_xmm_xmmm64_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRoundsd<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn roundsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Roundsd_xmm_xmmm64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRoundsd<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn roundsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Roundsd_xmm_xmmm64_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRoundsd<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn roundsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Roundsd_xmm_xmmm64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRoundss<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn roundss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Roundss_xmm_xmmm32_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRoundss<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn roundss(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Roundss_xmm_xmmm32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRoundss<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn roundss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Roundss_xmm_xmmm32_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRoundss<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn roundss(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Roundss_xmm_xmmm32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRsdc<__AsmRegisterSegment, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn rsdc(&mut self, op0: __AsmRegisterSegment, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rsdc_Sreg_m80, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmRsldt<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn rsldt(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Rsldt_m80, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmRsm for CodeAssembler {
	#[inline]
	fn rsm(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Rsm))
	}
}

#[rustfmt::skip]
impl CodeAsmRsqrtps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn rsqrtps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rsqrtps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRsqrtps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn rsqrtps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rsqrtps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmRsqrtss<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn rsqrtss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rsqrtss_xmm_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRsqrtss<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn rsqrtss(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rsqrtss_xmm_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmRstorssp<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn rstorssp(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Rstorssp_m64, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmRsts<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn rsts(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Rsts_m80, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSahf for CodeAssembler {
	#[inline]
	fn sahf(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Sahf))
	}
}

#[rustfmt::skip]
impl CodeAsmSal<__AsmRegister8, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn sal(&mut self, op0: __AsmRegister8, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sal_rm8_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSal<__AsmRegister16, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn sal(&mut self, op0: __AsmRegister16, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sal_rm16_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSal<__AsmRegister32, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn sal(&mut self, op0: __AsmRegister32, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sal_rm32_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSal<__AsmRegister64, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn sal(&mut self, op0: __AsmRegister64, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sal_rm64_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSal<__AsmMemoryOperand, __AsmRegister8> for CodeAssembler {
	fn sal(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister8) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Sal_rm64_CL
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Sal_rm32_CL
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Sal_rm16_CL
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Sal_rm8_CL
		} else {
			return Err(IcedError::new("sal: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSal<__AsmRegister8, i32> for CodeAssembler {
	#[inline]
	fn sal(&mut self, op0: __AsmRegister8, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Sal_rm8_1 } else { Code::Sal_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSal<__AsmRegister16, i32> for CodeAssembler {
	#[inline]
	fn sal(&mut self, op0: __AsmRegister16, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Sal_rm16_1 } else { Code::Sal_rm16_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSal<__AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn sal(&mut self, op0: __AsmRegister32, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Sal_rm32_1 } else { Code::Sal_rm32_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSal<__AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn sal(&mut self, op0: __AsmRegister64, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Sal_rm64_1 } else { Code::Sal_rm64_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSal<__AsmMemoryOperand, i32> for CodeAssembler {
	fn sal(&mut self, op0: __AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 {
			if op0.size() == MemoryOperandSize::Qword {
				Code::Sal_rm64_1
			} else if op0.size() == MemoryOperandSize::Dword {
				Code::Sal_rm32_1
			} else if op0.size() == MemoryOperandSize::Word {
				Code::Sal_rm16_1
			} else if op0.size() == MemoryOperandSize::Byte {
				Code::Sal_rm8_1
			} else {
				return Err(IcedError::new("sal: invalid operands"));
			}
		} else if op0.size() == MemoryOperandSize::Qword {
			Code::Sal_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Sal_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Sal_rm16_imm8
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Sal_rm8_imm8
		} else {
			return Err(IcedError::new("sal: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSal<__AsmRegister8, u32> for CodeAssembler {
	#[inline]
	fn sal(&mut self, op0: __AsmRegister8, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Sal_rm8_1 } else { Code::Sal_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSal<__AsmRegister16, u32> for CodeAssembler {
	#[inline]
	fn sal(&mut self, op0: __AsmRegister16, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Sal_rm16_1 } else { Code::Sal_rm16_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSal<__AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn sal(&mut self, op0: __AsmRegister32, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Sal_rm32_1 } else { Code::Sal_rm32_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSal<__AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn sal(&mut self, op0: __AsmRegister64, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Sal_rm64_1 } else { Code::Sal_rm64_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSal<__AsmMemoryOperand, u32> for CodeAssembler {
	fn sal(&mut self, op0: __AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 {
			if op0.size() == MemoryOperandSize::Qword {
				Code::Sal_rm64_1
			} else if op0.size() == MemoryOperandSize::Dword {
				Code::Sal_rm32_1
			} else if op0.size() == MemoryOperandSize::Word {
				Code::Sal_rm16_1
			} else if op0.size() == MemoryOperandSize::Byte {
				Code::Sal_rm8_1
			} else {
				return Err(IcedError::new("sal: invalid operands"));
			}
		} else if op0.size() == MemoryOperandSize::Qword {
			Code::Sal_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Sal_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Sal_rm16_imm8
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Sal_rm8_imm8
		} else {
			return Err(IcedError::new("sal: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSalc for CodeAssembler {
	#[inline]
	fn salc(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Salc))
	}
}

#[rustfmt::skip]
impl CodeAsmSar<__AsmRegister8, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn sar(&mut self, op0: __AsmRegister8, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sar_rm8_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSar<__AsmRegister16, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn sar(&mut self, op0: __AsmRegister16, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sar_rm16_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSar<__AsmRegister32, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn sar(&mut self, op0: __AsmRegister32, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sar_rm32_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSar<__AsmRegister64, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn sar(&mut self, op0: __AsmRegister64, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sar_rm64_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSar<__AsmMemoryOperand, __AsmRegister8> for CodeAssembler {
	fn sar(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister8) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Sar_rm64_CL
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Sar_rm32_CL
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Sar_rm16_CL
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Sar_rm8_CL
		} else {
			return Err(IcedError::new("sar: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSar<__AsmRegister8, i32> for CodeAssembler {
	#[inline]
	fn sar(&mut self, op0: __AsmRegister8, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Sar_rm8_1 } else { Code::Sar_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSar<__AsmRegister16, i32> for CodeAssembler {
	#[inline]
	fn sar(&mut self, op0: __AsmRegister16, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Sar_rm16_1 } else { Code::Sar_rm16_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSar<__AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn sar(&mut self, op0: __AsmRegister32, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Sar_rm32_1 } else { Code::Sar_rm32_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSar<__AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn sar(&mut self, op0: __AsmRegister64, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Sar_rm64_1 } else { Code::Sar_rm64_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSar<__AsmMemoryOperand, i32> for CodeAssembler {
	fn sar(&mut self, op0: __AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 {
			if op0.size() == MemoryOperandSize::Qword {
				Code::Sar_rm64_1
			} else if op0.size() == MemoryOperandSize::Dword {
				Code::Sar_rm32_1
			} else if op0.size() == MemoryOperandSize::Word {
				Code::Sar_rm16_1
			} else if op0.size() == MemoryOperandSize::Byte {
				Code::Sar_rm8_1
			} else {
				return Err(IcedError::new("sar: invalid operands"));
			}
		} else if op0.size() == MemoryOperandSize::Qword {
			Code::Sar_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Sar_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Sar_rm16_imm8
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Sar_rm8_imm8
		} else {
			return Err(IcedError::new("sar: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSar<__AsmRegister8, u32> for CodeAssembler {
	#[inline]
	fn sar(&mut self, op0: __AsmRegister8, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Sar_rm8_1 } else { Code::Sar_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSar<__AsmRegister16, u32> for CodeAssembler {
	#[inline]
	fn sar(&mut self, op0: __AsmRegister16, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Sar_rm16_1 } else { Code::Sar_rm16_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSar<__AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn sar(&mut self, op0: __AsmRegister32, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Sar_rm32_1 } else { Code::Sar_rm32_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSar<__AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn sar(&mut self, op0: __AsmRegister64, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Sar_rm64_1 } else { Code::Sar_rm64_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSar<__AsmMemoryOperand, u32> for CodeAssembler {
	fn sar(&mut self, op0: __AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 {
			if op0.size() == MemoryOperandSize::Qword {
				Code::Sar_rm64_1
			} else if op0.size() == MemoryOperandSize::Dword {
				Code::Sar_rm32_1
			} else if op0.size() == MemoryOperandSize::Word {
				Code::Sar_rm16_1
			} else if op0.size() == MemoryOperandSize::Byte {
				Code::Sar_rm8_1
			} else {
				return Err(IcedError::new("sar: invalid operands"));
			}
		} else if op0.size() == MemoryOperandSize::Qword {
			Code::Sar_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Sar_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Sar_rm16_imm8
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Sar_rm8_imm8
		} else {
			return Err(IcedError::new("sar: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSarx<__AsmRegister32, __AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn sarx(&mut self, op0: __AsmRegister32, op1: __AsmRegister32, op2: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Sarx_r32_rm32_r32, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSarx<__AsmRegister32, __AsmMemoryOperand, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn sarx(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand, op2: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Sarx_r32_rm32_r32, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSarx<__AsmRegister64, __AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn sarx(&mut self, op0: __AsmRegister64, op1: __AsmRegister64, op2: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Sarx_r64_rm64_r64, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSarx<__AsmRegister64, __AsmMemoryOperand, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn sarx(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand, op2: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Sarx_r64_rm64_r64, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSaveprevssp for CodeAssembler {
	#[inline]
	fn saveprevssp(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Saveprevssp))
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<__AsmRegister8, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn sbb(&mut self, op0: __AsmRegister8, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sbb_rm8_r8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<__AsmMemoryOperand, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn sbb(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sbb_rm8_r8, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn sbb(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sbb_rm16_r16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<__AsmMemoryOperand, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn sbb(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sbb_rm16_r16, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn sbb(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sbb_rm32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<__AsmMemoryOperand, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn sbb(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sbb_rm32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn sbb(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sbb_rm64_r64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<__AsmMemoryOperand, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn sbb(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sbb_rm64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<__AsmRegister8, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sbb(&mut self, op0: __AsmRegister8, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sbb_r8_rm8, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sbb(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sbb_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sbb(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sbb_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sbb(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sbb_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<__AsmRegister8, i32> for CodeAssembler {
	#[inline]
	fn sbb(&mut self, op0: __AsmRegister8, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AL { Code::Sbb_AL_imm8 } else { Code::Sbb_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<__AsmRegister16, i32> for CodeAssembler {
	fn sbb(&mut self, op0: __AsmRegister16, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AX {
			Code::Sbb_AX_imm16
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Sbb_rm16_imm8
		} else {
			Code::Sbb_rm16_imm16
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<__AsmRegister32, i32> for CodeAssembler {
	fn sbb(&mut self, op0: __AsmRegister32, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::EAX {
			Code::Sbb_EAX_imm32
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Sbb_rm32_imm8
		} else {
			Code::Sbb_rm32_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<__AsmRegister64, i32> for CodeAssembler {
	fn sbb(&mut self, op0: __AsmRegister64, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::RAX {
			Code::Sbb_RAX_imm32
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Sbb_rm64_imm8
		} else {
			Code::Sbb_rm64_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<__AsmMemoryOperand, i32> for CodeAssembler {
	fn sbb(&mut self, op0: __AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Sbb_rm64_imm8 } else { Code::Sbb_rm64_imm32 }
		} else if op0.size() == MemoryOperandSize::Dword {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Sbb_rm32_imm8 } else { Code::Sbb_rm32_imm32 }
		} else if op0.size() == MemoryOperandSize::Word {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Sbb_rm16_imm8 } else { Code::Sbb_rm16_imm16 }
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Sbb_rm8_imm8
		} else {
			return Err(IcedError::new("sbb: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<__AsmRegister8, u32> for CodeAssembler {
	#[inline]
	fn sbb(&mut self, op0: __AsmRegister8, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AL { Code::Sbb_AL_imm8 } else { Code::Sbb_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<__AsmRegister16, u32> for CodeAssembler {
	fn sbb(&mut self, op0: __AsmRegister16, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AX {
			Code::Sbb_AX_imm16
		} else if op1 <= i8::MAX as u32 || (0xFF80 <= op1 && op1 <= 0xFFFF) {
			Code::Sbb_rm16_imm8
		} else {
			Code::Sbb_rm16_imm16
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<__AsmRegister32, u32> for CodeAssembler {
	fn sbb(&mut self, op0: __AsmRegister32, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::EAX {
			Code::Sbb_EAX_imm32
		} else if op1 <= i8::MAX as u32 || 0xFFFF_FF80 <= op1 {
			Code::Sbb_rm32_imm8
		} else {
			Code::Sbb_rm32_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<__AsmMemoryOperand, u32> for CodeAssembler {
	fn sbb(&mut self, op0: __AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Dword {
			if op1 <= i8::MAX as u32 || 0xFFFF_FF80 <= op1 { Code::Sbb_rm32_imm8 } else { Code::Sbb_rm32_imm32 }
		} else if op0.size() == MemoryOperandSize::Word {
			if op1 <= i8::MAX as u32 || (0xFF80 <= op1 && op1 <= 0xFFFF) { Code::Sbb_rm16_imm8 } else { Code::Sbb_rm16_imm16 }
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Sbb_rm8_imm8
		} else {
			return Err(IcedError::new("sbb: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmScasb for CodeAssembler {
	#[inline]
	fn scasb(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_scasb(self.bitness(), RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmScasd for CodeAssembler {
	#[inline]
	fn scasd(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_scasd(self.bitness(), RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmScasq for CodeAssembler {
	#[inline]
	fn scasq(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_scasq(self.bitness(), RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmScasw for CodeAssembler {
	#[inline]
	fn scasw(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_scasw(self.bitness(), RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSeamcall for CodeAssembler {
	#[inline]
	fn seamcall(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Seamcall))
	}
}

#[rustfmt::skip]
impl CodeAsmSeamops for CodeAssembler {
	#[inline]
	fn seamops(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Seamops))
	}
}

#[rustfmt::skip]
impl CodeAsmSeamret for CodeAssembler {
	#[inline]
	fn seamret(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Seamret))
	}
}

#[rustfmt::skip]
impl CodeAsmSenduipi<__AsmRegister64> for CodeAssembler {
	#[inline]
	fn senduipi(&mut self, op0: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Senduipi_r64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSerialize for CodeAssembler {
	#[inline]
	fn serialize(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Serialize))
	}
}

#[rustfmt::skip]
impl CodeAsmSeta<__AsmRegister8> for CodeAssembler {
	#[inline]
	fn seta(&mut self, op0: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Seta_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSeta<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn seta(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Seta_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetae<__AsmRegister8> for CodeAssembler {
	#[inline]
	fn setae(&mut self, op0: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setae_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetae<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn setae(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setae_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetb<__AsmRegister8> for CodeAssembler {
	#[inline]
	fn setb(&mut self, op0: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setb_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetb<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn setb(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setb_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetbe<__AsmRegister8> for CodeAssembler {
	#[inline]
	fn setbe(&mut self, op0: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setbe_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetbe<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn setbe(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setbe_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSete<__AsmRegister8> for CodeAssembler {
	#[inline]
	fn sete(&mut self, op0: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Sete_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSete<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sete(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Sete_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetg<__AsmRegister8> for CodeAssembler {
	#[inline]
	fn setg(&mut self, op0: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setg_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetg<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn setg(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setg_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetge<__AsmRegister8> for CodeAssembler {
	#[inline]
	fn setge(&mut self, op0: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setge_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetge<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn setge(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setge_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetl<__AsmRegister8> for CodeAssembler {
	#[inline]
	fn setl(&mut self, op0: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setl_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetl<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn setl(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setl_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetle<__AsmRegister8> for CodeAssembler {
	#[inline]
	fn setle(&mut self, op0: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setle_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetle<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn setle(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setle_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetne<__AsmRegister8> for CodeAssembler {
	#[inline]
	fn setne(&mut self, op0: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setne_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetne<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn setne(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setne_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetno<__AsmRegister8> for CodeAssembler {
	#[inline]
	fn setno(&mut self, op0: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setno_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetno<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn setno(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setno_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetnp<__AsmRegister8> for CodeAssembler {
	#[inline]
	fn setnp(&mut self, op0: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setnp_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetnp<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn setnp(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setnp_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetns<__AsmRegister8> for CodeAssembler {
	#[inline]
	fn setns(&mut self, op0: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setns_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetns<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn setns(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setns_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSeto<__AsmRegister8> for CodeAssembler {
	#[inline]
	fn seto(&mut self, op0: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Seto_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSeto<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn seto(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Seto_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetp<__AsmRegister8> for CodeAssembler {
	#[inline]
	fn setp(&mut self, op0: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setp_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetp<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn setp(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setp_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSets<__AsmRegister8> for CodeAssembler {
	#[inline]
	fn sets(&mut self, op0: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Sets_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSets<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sets(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Sets_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetssbsy for CodeAssembler {
	#[inline]
	fn setssbsy(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Setssbsy))
	}
}

#[rustfmt::skip]
impl CodeAsmSfence for CodeAssembler {
	#[inline]
	fn sfence(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Sfence))
	}
}

#[rustfmt::skip]
impl CodeAsmSgdt<__AsmMemoryOperand> for CodeAssembler {
	fn sgdt(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Sgdt_m1664
		} else if self.bitness() >= 32 {
			Code::Sgdt_m1632
		} else {
			Code::Sgdt_m1632_16
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSha1msg1<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn sha1msg1(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sha1msg1_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSha1msg1<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sha1msg1(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sha1msg1_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSha1msg2<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn sha1msg2(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sha1msg2_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSha1msg2<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sha1msg2(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sha1msg2_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSha1nexte<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn sha1nexte(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sha1nexte_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSha1nexte<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sha1nexte(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sha1nexte_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSha1rnds4<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn sha1rnds4(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Sha1rnds4_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSha1rnds4<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn sha1rnds4(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Sha1rnds4_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSha1rnds4<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn sha1rnds4(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Sha1rnds4_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSha1rnds4<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn sha1rnds4(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Sha1rnds4_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSha256msg1<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn sha256msg1(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sha256msg1_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSha256msg1<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sha256msg1(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sha256msg1_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSha256msg2<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn sha256msg2(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sha256msg2_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSha256msg2<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sha256msg2(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sha256msg2_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSha256rnds2<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn sha256rnds2(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sha256rnds2_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSha256rnds2<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sha256rnds2(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sha256rnds2_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmShl<__AsmRegister8, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn shl(&mut self, op0: __AsmRegister8, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Shl_rm8_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShl<__AsmRegister16, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn shl(&mut self, op0: __AsmRegister16, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Shl_rm16_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShl<__AsmRegister32, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn shl(&mut self, op0: __AsmRegister32, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Shl_rm32_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShl<__AsmRegister64, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn shl(&mut self, op0: __AsmRegister64, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Shl_rm64_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShl<__AsmMemoryOperand, __AsmRegister8> for CodeAssembler {
	fn shl(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister8) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Shl_rm64_CL
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Shl_rm32_CL
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Shl_rm16_CL
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Shl_rm8_CL
		} else {
			return Err(IcedError::new("shl: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShl<__AsmRegister8, i32> for CodeAssembler {
	#[inline]
	fn shl(&mut self, op0: __AsmRegister8, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Shl_rm8_1 } else { Code::Shl_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShl<__AsmRegister16, i32> for CodeAssembler {
	#[inline]
	fn shl(&mut self, op0: __AsmRegister16, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Shl_rm16_1 } else { Code::Shl_rm16_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShl<__AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn shl(&mut self, op0: __AsmRegister32, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Shl_rm32_1 } else { Code::Shl_rm32_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShl<__AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn shl(&mut self, op0: __AsmRegister64, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Shl_rm64_1 } else { Code::Shl_rm64_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShl<__AsmMemoryOperand, i32> for CodeAssembler {
	fn shl(&mut self, op0: __AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 {
			if op0.size() == MemoryOperandSize::Qword {
				Code::Shl_rm64_1
			} else if op0.size() == MemoryOperandSize::Dword {
				Code::Shl_rm32_1
			} else if op0.size() == MemoryOperandSize::Word {
				Code::Shl_rm16_1
			} else if op0.size() == MemoryOperandSize::Byte {
				Code::Shl_rm8_1
			} else {
				return Err(IcedError::new("shl: invalid operands"));
			}
		} else if op0.size() == MemoryOperandSize::Qword {
			Code::Shl_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Shl_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Shl_rm16_imm8
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Shl_rm8_imm8
		} else {
			return Err(IcedError::new("shl: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShl<__AsmRegister8, u32> for CodeAssembler {
	#[inline]
	fn shl(&mut self, op0: __AsmRegister8, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Shl_rm8_1 } else { Code::Shl_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShl<__AsmRegister16, u32> for CodeAssembler {
	#[inline]
	fn shl(&mut self, op0: __AsmRegister16, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Shl_rm16_1 } else { Code::Shl_rm16_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShl<__AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn shl(&mut self, op0: __AsmRegister32, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Shl_rm32_1 } else { Code::Shl_rm32_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShl<__AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn shl(&mut self, op0: __AsmRegister64, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Shl_rm64_1 } else { Code::Shl_rm64_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShl<__AsmMemoryOperand, u32> for CodeAssembler {
	fn shl(&mut self, op0: __AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 {
			if op0.size() == MemoryOperandSize::Qword {
				Code::Shl_rm64_1
			} else if op0.size() == MemoryOperandSize::Dword {
				Code::Shl_rm32_1
			} else if op0.size() == MemoryOperandSize::Word {
				Code::Shl_rm16_1
			} else if op0.size() == MemoryOperandSize::Byte {
				Code::Shl_rm8_1
			} else {
				return Err(IcedError::new("shl: invalid operands"));
			}
		} else if op0.size() == MemoryOperandSize::Qword {
			Code::Shl_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Shl_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Shl_rm16_imm8
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Shl_rm8_imm8
		} else {
			return Err(IcedError::new("shl: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShld<__AsmRegister16, __AsmRegister16, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn shld(&mut self, op0: __AsmRegister16, op1: __AsmRegister16, op2: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shld_rm16_r16_CL, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShld<__AsmMemoryOperand, __AsmRegister16, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn shld(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister16, op2: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shld_rm16_r16_CL, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShld<__AsmRegister32, __AsmRegister32, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn shld(&mut self, op0: __AsmRegister32, op1: __AsmRegister32, op2: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shld_rm32_r32_CL, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShld<__AsmMemoryOperand, __AsmRegister32, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn shld(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister32, op2: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shld_rm32_r32_CL, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShld<__AsmRegister64, __AsmRegister64, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn shld(&mut self, op0: __AsmRegister64, op1: __AsmRegister64, op2: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shld_rm64_r64_CL, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShld<__AsmMemoryOperand, __AsmRegister64, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn shld(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister64, op2: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shld_rm64_r64_CL, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShld<__AsmRegister16, __AsmRegister16, i32> for CodeAssembler {
	#[inline]
	fn shld(&mut self, op0: __AsmRegister16, op1: __AsmRegister16, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shld_rm16_r16_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShld<__AsmMemoryOperand, __AsmRegister16, i32> for CodeAssembler {
	#[inline]
	fn shld(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister16, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shld_rm16_r16_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShld<__AsmRegister32, __AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn shld(&mut self, op0: __AsmRegister32, op1: __AsmRegister32, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shld_rm32_r32_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShld<__AsmMemoryOperand, __AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn shld(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister32, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shld_rm32_r32_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShld<__AsmRegister64, __AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn shld(&mut self, op0: __AsmRegister64, op1: __AsmRegister64, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shld_rm64_r64_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShld<__AsmMemoryOperand, __AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn shld(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister64, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shld_rm64_r64_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShld<__AsmRegister16, __AsmRegister16, u32> for CodeAssembler {
	#[inline]
	fn shld(&mut self, op0: __AsmRegister16, op1: __AsmRegister16, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shld_rm16_r16_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShld<__AsmMemoryOperand, __AsmRegister16, u32> for CodeAssembler {
	#[inline]
	fn shld(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister16, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shld_rm16_r16_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShld<__AsmRegister32, __AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn shld(&mut self, op0: __AsmRegister32, op1: __AsmRegister32, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shld_rm32_r32_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShld<__AsmMemoryOperand, __AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn shld(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister32, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shld_rm32_r32_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShld<__AsmRegister64, __AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn shld(&mut self, op0: __AsmRegister64, op1: __AsmRegister64, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shld_rm64_r64_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShld<__AsmMemoryOperand, __AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn shld(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister64, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shld_rm64_r64_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShlx<__AsmRegister32, __AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn shlx(&mut self, op0: __AsmRegister32, op1: __AsmRegister32, op2: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Shlx_r32_rm32_r32, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShlx<__AsmRegister32, __AsmMemoryOperand, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn shlx(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand, op2: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Shlx_r32_rm32_r32, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShlx<__AsmRegister64, __AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn shlx(&mut self, op0: __AsmRegister64, op1: __AsmRegister64, op2: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Shlx_r64_rm64_r64, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShlx<__AsmRegister64, __AsmMemoryOperand, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn shlx(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand, op2: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Shlx_r64_rm64_r64, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShr<__AsmRegister8, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn shr(&mut self, op0: __AsmRegister8, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Shr_rm8_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShr<__AsmRegister16, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn shr(&mut self, op0: __AsmRegister16, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Shr_rm16_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShr<__AsmRegister32, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn shr(&mut self, op0: __AsmRegister32, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Shr_rm32_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShr<__AsmRegister64, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn shr(&mut self, op0: __AsmRegister64, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Shr_rm64_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShr<__AsmMemoryOperand, __AsmRegister8> for CodeAssembler {
	fn shr(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister8) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Shr_rm64_CL
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Shr_rm32_CL
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Shr_rm16_CL
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Shr_rm8_CL
		} else {
			return Err(IcedError::new("shr: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShr<__AsmRegister8, i32> for CodeAssembler {
	#[inline]
	fn shr(&mut self, op0: __AsmRegister8, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Shr_rm8_1 } else { Code::Shr_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShr<__AsmRegister16, i32> for CodeAssembler {
	#[inline]
	fn shr(&mut self, op0: __AsmRegister16, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Shr_rm16_1 } else { Code::Shr_rm16_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShr<__AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn shr(&mut self, op0: __AsmRegister32, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Shr_rm32_1 } else { Code::Shr_rm32_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShr<__AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn shr(&mut self, op0: __AsmRegister64, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Shr_rm64_1 } else { Code::Shr_rm64_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShr<__AsmMemoryOperand, i32> for CodeAssembler {
	fn shr(&mut self, op0: __AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 {
			if op0.size() == MemoryOperandSize::Qword {
				Code::Shr_rm64_1
			} else if op0.size() == MemoryOperandSize::Dword {
				Code::Shr_rm32_1
			} else if op0.size() == MemoryOperandSize::Word {
				Code::Shr_rm16_1
			} else if op0.size() == MemoryOperandSize::Byte {
				Code::Shr_rm8_1
			} else {
				return Err(IcedError::new("shr: invalid operands"));
			}
		} else if op0.size() == MemoryOperandSize::Qword {
			Code::Shr_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Shr_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Shr_rm16_imm8
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Shr_rm8_imm8
		} else {
			return Err(IcedError::new("shr: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShr<__AsmRegister8, u32> for CodeAssembler {
	#[inline]
	fn shr(&mut self, op0: __AsmRegister8, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Shr_rm8_1 } else { Code::Shr_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShr<__AsmRegister16, u32> for CodeAssembler {
	#[inline]
	fn shr(&mut self, op0: __AsmRegister16, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Shr_rm16_1 } else { Code::Shr_rm16_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShr<__AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn shr(&mut self, op0: __AsmRegister32, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Shr_rm32_1 } else { Code::Shr_rm32_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShr<__AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn shr(&mut self, op0: __AsmRegister64, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Shr_rm64_1 } else { Code::Shr_rm64_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShr<__AsmMemoryOperand, u32> for CodeAssembler {
	fn shr(&mut self, op0: __AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 {
			if op0.size() == MemoryOperandSize::Qword {
				Code::Shr_rm64_1
			} else if op0.size() == MemoryOperandSize::Dword {
				Code::Shr_rm32_1
			} else if op0.size() == MemoryOperandSize::Word {
				Code::Shr_rm16_1
			} else if op0.size() == MemoryOperandSize::Byte {
				Code::Shr_rm8_1
			} else {
				return Err(IcedError::new("shr: invalid operands"));
			}
		} else if op0.size() == MemoryOperandSize::Qword {
			Code::Shr_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Shr_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Shr_rm16_imm8
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Shr_rm8_imm8
		} else {
			return Err(IcedError::new("shr: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrd<__AsmRegister16, __AsmRegister16, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn shrd(&mut self, op0: __AsmRegister16, op1: __AsmRegister16, op2: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shrd_rm16_r16_CL, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrd<__AsmMemoryOperand, __AsmRegister16, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn shrd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister16, op2: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shrd_rm16_r16_CL, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrd<__AsmRegister32, __AsmRegister32, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn shrd(&mut self, op0: __AsmRegister32, op1: __AsmRegister32, op2: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shrd_rm32_r32_CL, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrd<__AsmMemoryOperand, __AsmRegister32, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn shrd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister32, op2: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shrd_rm32_r32_CL, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrd<__AsmRegister64, __AsmRegister64, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn shrd(&mut self, op0: __AsmRegister64, op1: __AsmRegister64, op2: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shrd_rm64_r64_CL, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrd<__AsmMemoryOperand, __AsmRegister64, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn shrd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister64, op2: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shrd_rm64_r64_CL, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrd<__AsmRegister16, __AsmRegister16, i32> for CodeAssembler {
	#[inline]
	fn shrd(&mut self, op0: __AsmRegister16, op1: __AsmRegister16, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shrd_rm16_r16_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrd<__AsmMemoryOperand, __AsmRegister16, i32> for CodeAssembler {
	#[inline]
	fn shrd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister16, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shrd_rm16_r16_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrd<__AsmRegister32, __AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn shrd(&mut self, op0: __AsmRegister32, op1: __AsmRegister32, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shrd_rm32_r32_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrd<__AsmMemoryOperand, __AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn shrd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister32, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shrd_rm32_r32_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrd<__AsmRegister64, __AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn shrd(&mut self, op0: __AsmRegister64, op1: __AsmRegister64, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shrd_rm64_r64_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrd<__AsmMemoryOperand, __AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn shrd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister64, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shrd_rm64_r64_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrd<__AsmRegister16, __AsmRegister16, u32> for CodeAssembler {
	#[inline]
	fn shrd(&mut self, op0: __AsmRegister16, op1: __AsmRegister16, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shrd_rm16_r16_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrd<__AsmMemoryOperand, __AsmRegister16, u32> for CodeAssembler {
	#[inline]
	fn shrd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister16, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shrd_rm16_r16_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrd<__AsmRegister32, __AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn shrd(&mut self, op0: __AsmRegister32, op1: __AsmRegister32, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shrd_rm32_r32_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrd<__AsmMemoryOperand, __AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn shrd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister32, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shrd_rm32_r32_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrd<__AsmRegister64, __AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn shrd(&mut self, op0: __AsmRegister64, op1: __AsmRegister64, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shrd_rm64_r64_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrd<__AsmMemoryOperand, __AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn shrd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister64, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shrd_rm64_r64_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrx<__AsmRegister32, __AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn shrx(&mut self, op0: __AsmRegister32, op1: __AsmRegister32, op2: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Shrx_r32_rm32_r32, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrx<__AsmRegister32, __AsmMemoryOperand, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn shrx(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand, op2: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Shrx_r32_rm32_r32, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrx<__AsmRegister64, __AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn shrx(&mut self, op0: __AsmRegister64, op1: __AsmRegister64, op2: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Shrx_r64_rm64_r64, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrx<__AsmRegister64, __AsmMemoryOperand, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn shrx(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand, op2: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Shrx_r64_rm64_r64, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShufpd<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn shufpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shufpd_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShufpd<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn shufpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shufpd_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShufpd<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn shufpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shufpd_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShufpd<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn shufpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shufpd_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShufps<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn shufps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shufps_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShufps<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn shufps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shufps_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShufps<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn shufps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shufps_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShufps<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn shufps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shufps_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSidt<__AsmMemoryOperand> for CodeAssembler {
	fn sidt(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Sidt_m1664
		} else if self.bitness() >= 32 {
			Code::Sidt_m1632
		} else {
			Code::Sidt_m1632_16
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSkinit for CodeAssembler {
	#[inline]
	fn skinit(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Skinit))
	}
}

#[rustfmt::skip]
impl CodeAsmSldt<__AsmRegister16> for CodeAssembler {
	#[inline]
	fn sldt(&mut self, op0: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Sldt_rm16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSldt<__AsmRegister32> for CodeAssembler {
	#[inline]
	fn sldt(&mut self, op0: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Sldt_r32m16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSldt<__AsmRegister64> for CodeAssembler {
	#[inline]
	fn sldt(&mut self, op0: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Sldt_r64m16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSldt<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sldt(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Sldt_r32m16 } else { Code::Sldt_rm16 };
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSlwpcb<__AsmRegister32> for CodeAssembler {
	#[inline]
	fn slwpcb(&mut self, op0: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::XOP_Slwpcb_r32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSlwpcb<__AsmRegister64> for CodeAssembler {
	#[inline]
	fn slwpcb(&mut self, op0: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::XOP_Slwpcb_r64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSmint for CodeAssembler {
	#[inline]
	fn smint(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Smint))
	}
}

#[rustfmt::skip]
impl CodeAsmSmint_0f7e for CodeAssembler {
	#[inline]
	fn smint_0f7e(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Smint_0F7E))
	}
}

#[rustfmt::skip]
impl CodeAsmSmsw<__AsmRegister16> for CodeAssembler {
	#[inline]
	fn smsw(&mut self, op0: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Smsw_rm16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSmsw<__AsmRegister32> for CodeAssembler {
	#[inline]
	fn smsw(&mut self, op0: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Smsw_r32m16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSmsw<__AsmRegister64> for CodeAssembler {
	#[inline]
	fn smsw(&mut self, op0: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Smsw_r64m16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSmsw<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn smsw(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Smsw_r32m16 } else { Code::Smsw_rm16 };
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSqrtpd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn sqrtpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sqrtpd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSqrtpd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sqrtpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sqrtpd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSqrtps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn sqrtps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sqrtps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSqrtps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sqrtps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sqrtps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSqrtsd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn sqrtsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sqrtsd_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSqrtsd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sqrtsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sqrtsd_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSqrtss<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn sqrtss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sqrtss_xmm_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSqrtss<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sqrtss(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sqrtss_xmm_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmStac for CodeAssembler {
	#[inline]
	fn stac(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Stac))
	}
}

#[rustfmt::skip]
impl CodeAsmStc for CodeAssembler {
	#[inline]
	fn stc(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Stc))
	}
}

#[rustfmt::skip]
impl CodeAsmStd for CodeAssembler {
	#[inline]
	fn std(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Std))
	}
}

#[rustfmt::skip]
impl CodeAsmStgi for CodeAssembler {
	#[inline]
	fn stgi(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Stgi))
	}
}

#[rustfmt::skip]
impl CodeAsmSti for CodeAssembler {
	#[inline]
	fn sti(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Sti))
	}
}

#[rustfmt::skip]
impl CodeAsmStmxcsr<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn stmxcsr(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Stmxcsr_m32, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmStosb for CodeAssembler {
	#[inline]
	fn stosb(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_stosb(self.bitness(), RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmStosd for CodeAssembler {
	#[inline]
	fn stosd(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_stosd(self.bitness(), RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmStosq for CodeAssembler {
	#[inline]
	fn stosq(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_stosq(self.bitness(), RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmStosw for CodeAssembler {
	#[inline]
	fn stosw(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_stosw(self.bitness(), RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmStr<__AsmRegister16> for CodeAssembler {
	#[inline]
	fn str(&mut self, op0: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Str_rm16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmStr<__AsmRegister32> for CodeAssembler {
	#[inline]
	fn str(&mut self, op0: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Str_r32m16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmStr<__AsmRegister64> for CodeAssembler {
	#[inline]
	fn str(&mut self, op0: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Str_r64m16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmStr<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn str(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Str_r32m16 } else { Code::Str_rm16 };
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSttilecfg<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sttilecfg(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::VEX_Sttilecfg_m512, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmStui for CodeAssembler {
	#[inline]
	fn stui(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Stui))
	}
}

#[rustfmt::skip]
impl CodeAsmSub<__AsmRegister8, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn sub(&mut self, op0: __AsmRegister8, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sub_rm8_r8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSub<__AsmMemoryOperand, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn sub(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sub_rm8_r8, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSub<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn sub(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sub_rm16_r16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSub<__AsmMemoryOperand, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn sub(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sub_rm16_r16, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSub<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn sub(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sub_rm32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSub<__AsmMemoryOperand, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn sub(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sub_rm32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSub<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn sub(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sub_rm64_r64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSub<__AsmMemoryOperand, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn sub(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sub_rm64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSub<__AsmRegister8, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sub(&mut self, op0: __AsmRegister8, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sub_r8_rm8, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSub<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sub(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sub_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSub<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sub(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sub_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSub<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sub(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sub_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSub<__AsmRegister8, i32> for CodeAssembler {
	#[inline]
	fn sub(&mut self, op0: __AsmRegister8, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AL { Code::Sub_AL_imm8 } else { Code::Sub_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSub<__AsmRegister16, i32> for CodeAssembler {
	fn sub(&mut self, op0: __AsmRegister16, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AX {
			Code::Sub_AX_imm16
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Sub_rm16_imm8
		} else {
			Code::Sub_rm16_imm16
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSub<__AsmRegister32, i32> for CodeAssembler {
	fn sub(&mut self, op0: __AsmRegister32, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::EAX {
			Code::Sub_EAX_imm32
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Sub_rm32_imm8
		} else {
			Code::Sub_rm32_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSub<__AsmRegister64, i32> for CodeAssembler {
	fn sub(&mut self, op0: __AsmRegister64, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::RAX {
			Code::Sub_RAX_imm32
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Sub_rm64_imm8
		} else {
			Code::Sub_rm64_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSub<__AsmMemoryOperand, i32> for CodeAssembler {
	fn sub(&mut self, op0: __AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Sub_rm64_imm8 } else { Code::Sub_rm64_imm32 }
		} else if op0.size() == MemoryOperandSize::Dword {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Sub_rm32_imm8 } else { Code::Sub_rm32_imm32 }
		} else if op0.size() == MemoryOperandSize::Word {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Sub_rm16_imm8 } else { Code::Sub_rm16_imm16 }
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Sub_rm8_imm8
		} else {
			return Err(IcedError::new("sub: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSub<__AsmRegister8, u32> for CodeAssembler {
	#[inline]
	fn sub(&mut self, op0: __AsmRegister8, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AL { Code::Sub_AL_imm8 } else { Code::Sub_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSub<__AsmRegister16, u32> for CodeAssembler {
	fn sub(&mut self, op0: __AsmRegister16, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AX {
			Code::Sub_AX_imm16
		} else if op1 <= i8::MAX as u32 || (0xFF80 <= op1 && op1 <= 0xFFFF) {
			Code::Sub_rm16_imm8
		} else {
			Code::Sub_rm16_imm16
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSub<__AsmRegister32, u32> for CodeAssembler {
	fn sub(&mut self, op0: __AsmRegister32, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::EAX {
			Code::Sub_EAX_imm32
		} else if op1 <= i8::MAX as u32 || 0xFFFF_FF80 <= op1 {
			Code::Sub_rm32_imm8
		} else {
			Code::Sub_rm32_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSub<__AsmMemoryOperand, u32> for CodeAssembler {
	fn sub(&mut self, op0: __AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Dword {
			if op1 <= i8::MAX as u32 || 0xFFFF_FF80 <= op1 { Code::Sub_rm32_imm8 } else { Code::Sub_rm32_imm32 }
		} else if op0.size() == MemoryOperandSize::Word {
			if op1 <= i8::MAX as u32 || (0xFF80 <= op1 && op1 <= 0xFFFF) { Code::Sub_rm16_imm8 } else { Code::Sub_rm16_imm16 }
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Sub_rm8_imm8
		} else {
			return Err(IcedError::new("sub: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSubpd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn subpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Subpd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSubpd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn subpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Subpd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSubps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn subps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Subps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSubps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn subps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Subps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSubsd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn subsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Subsd_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSubsd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn subsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Subsd_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSubss<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn subss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Subss_xmm_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSubss<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn subss(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Subss_xmm_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSvdc<__AsmMemoryOperand, __AsmRegisterSegment> for CodeAssembler {
	#[inline]
	fn svdc(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterSegment) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Svdc_m80_Sreg, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSvldt<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn svldt(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Svldt_m80, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSvts<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn svts(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Svts_m80, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSwapgs for CodeAssembler {
	#[inline]
	fn swapgs(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Swapgs))
	}
}

#[rustfmt::skip]
impl CodeAsmSyscall for CodeAssembler {
	#[inline]
	fn syscall(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Syscall))
	}
}

#[rustfmt::skip]
impl CodeAsmSysenter for CodeAssembler {
	#[inline]
	fn sysenter(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Sysenter))
	}
}

#[rustfmt::skip]
impl CodeAsmSysexit for CodeAssembler {
	#[inline]
	fn sysexit(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Sysexitd))
	}
}

#[rustfmt::skip]
impl CodeAsmSysexitq for CodeAssembler {
	#[inline]
	fn sysexitq(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Sysexitq))
	}
}

#[rustfmt::skip]
impl CodeAsmSysret for CodeAssembler {
	#[inline]
	fn sysret(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Sysretd))
	}
}

#[rustfmt::skip]
impl CodeAsmSysretq for CodeAssembler {
	#[inline]
	fn sysretq(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Sysretq))
	}
}

#[rustfmt::skip]
impl CodeAsmT1mskc<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn t1mskc(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_T1mskc_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmT1mskc<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn t1mskc(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_T1mskc_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmT1mskc<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn t1mskc(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_T1mskc_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmT1mskc<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn t1mskc(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_T1mskc_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmTdcall for CodeAssembler {
	#[inline]
	fn tdcall(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Tdcall))
	}
}

#[rustfmt::skip]
impl CodeAsmTdpbf16ps<__AsmRegisterTmm, __AsmRegisterTmm, __AsmRegisterTmm> for CodeAssembler {
	#[inline]
	fn tdpbf16ps(&mut self, op0: __AsmRegisterTmm, op1: __AsmRegisterTmm, op2: __AsmRegisterTmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Tdpbf16ps_tmm_tmm_tmm, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTdpbssd<__AsmRegisterTmm, __AsmRegisterTmm, __AsmRegisterTmm> for CodeAssembler {
	#[inline]
	fn tdpbssd(&mut self, op0: __AsmRegisterTmm, op1: __AsmRegisterTmm, op2: __AsmRegisterTmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Tdpbssd_tmm_tmm_tmm, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTdpbsud<__AsmRegisterTmm, __AsmRegisterTmm, __AsmRegisterTmm> for CodeAssembler {
	#[inline]
	fn tdpbsud(&mut self, op0: __AsmRegisterTmm, op1: __AsmRegisterTmm, op2: __AsmRegisterTmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Tdpbsud_tmm_tmm_tmm, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTdpbusd<__AsmRegisterTmm, __AsmRegisterTmm, __AsmRegisterTmm> for CodeAssembler {
	#[inline]
	fn tdpbusd(&mut self, op0: __AsmRegisterTmm, op1: __AsmRegisterTmm, op2: __AsmRegisterTmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Tdpbusd_tmm_tmm_tmm, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTdpbuud<__AsmRegisterTmm, __AsmRegisterTmm, __AsmRegisterTmm> for CodeAssembler {
	#[inline]
	fn tdpbuud(&mut self, op0: __AsmRegisterTmm, op1: __AsmRegisterTmm, op2: __AsmRegisterTmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Tdpbuud_tmm_tmm_tmm, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTest<__AsmRegister8, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn test(&mut self, op0: __AsmRegister8, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Test_rm8_r8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTest<__AsmMemoryOperand, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn test(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Test_rm8_r8, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTest<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn test(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Test_rm16_r16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTest<__AsmMemoryOperand, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn test(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Test_rm16_r16, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTest<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn test(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Test_rm32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTest<__AsmMemoryOperand, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn test(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Test_rm32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTest<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn test(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Test_rm64_r64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTest<__AsmMemoryOperand, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn test(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Test_rm64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTest<__AsmRegister8, i32> for CodeAssembler {
	#[inline]
	fn test(&mut self, op0: __AsmRegister8, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AL { Code::Test_AL_imm8 } else { Code::Test_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmTest<__AsmRegister16, i32> for CodeAssembler {
	#[inline]
	fn test(&mut self, op0: __AsmRegister16, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AX { Code::Test_AX_imm16 } else { Code::Test_rm16_imm16 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmTest<__AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn test(&mut self, op0: __AsmRegister32, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::EAX { Code::Test_EAX_imm32 } else { Code::Test_rm32_imm32 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmTest<__AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn test(&mut self, op0: __AsmRegister64, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::RAX { Code::Test_RAX_imm32 } else { Code::Test_rm64_imm32 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmTest<__AsmMemoryOperand, i32> for CodeAssembler {
	fn test(&mut self, op0: __AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Test_rm64_imm32
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Test_rm32_imm32
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Test_rm16_imm16
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Test_rm8_imm8
		} else {
			return Err(IcedError::new("test: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmTest<__AsmRegister8, u32> for CodeAssembler {
	#[inline]
	fn test(&mut self, op0: __AsmRegister8, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AL { Code::Test_AL_imm8 } else { Code::Test_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmTest<__AsmRegister16, u32> for CodeAssembler {
	#[inline]
	fn test(&mut self, op0: __AsmRegister16, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AX { Code::Test_AX_imm16 } else { Code::Test_rm16_imm16 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmTest<__AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn test(&mut self, op0: __AsmRegister32, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::EAX { Code::Test_EAX_imm32 } else { Code::Test_rm32_imm32 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmTest<__AsmMemoryOperand, u32> for CodeAssembler {
	fn test(&mut self, op0: __AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Dword {
			Code::Test_rm32_imm32
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Test_rm16_imm16
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Test_rm8_imm8
		} else {
			return Err(IcedError::new("test: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmTestui for CodeAssembler {
	#[inline]
	fn testui(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Testui))
	}
}

#[rustfmt::skip]
impl CodeAsmTileloadd<__AsmRegisterTmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn tileloadd(&mut self, op0: __AsmRegisterTmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Tileloadd_tmm_sibmem, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmTileloaddt1<__AsmRegisterTmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn tileloaddt1(&mut self, op0: __AsmRegisterTmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Tileloaddt1_tmm_sibmem, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmTilerelease for CodeAssembler {
	#[inline]
	fn tilerelease(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::VEX_Tilerelease))
	}
}

#[rustfmt::skip]
impl CodeAsmTilestored<__AsmMemoryOperand, __AsmRegisterTmm> for CodeAssembler {
	#[inline]
	fn tilestored(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterTmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Tilestored_sibmem_tmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTilezero<__AsmRegisterTmm> for CodeAssembler {
	#[inline]
	fn tilezero(&mut self, op0: __AsmRegisterTmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::VEX_Tilezero_tmm, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTlbsync for CodeAssembler {
	#[inline]
	fn tlbsync(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Tlbsync))
	}
}

#[rustfmt::skip]
impl CodeAsmTpause<__AsmRegister32> for CodeAssembler {
	#[inline]
	fn tpause(&mut self, op0: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Tpause_r32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTpause<__AsmRegister64> for CodeAssembler {
	#[inline]
	fn tpause(&mut self, op0: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Tpause_r64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTzcnt<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn tzcnt(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Tzcnt_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTzcnt<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn tzcnt(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Tzcnt_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTzcnt<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn tzcnt(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Tzcnt_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTzcnt<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn tzcnt(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Tzcnt_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmTzcnt<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn tzcnt(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Tzcnt_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmTzcnt<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn tzcnt(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Tzcnt_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmTzmsk<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn tzmsk(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Tzmsk_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTzmsk<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn tzmsk(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Tzmsk_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTzmsk<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn tzmsk(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Tzmsk_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmTzmsk<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn tzmsk(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Tzmsk_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmUcomisd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn ucomisd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ucomisd_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUcomisd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn ucomisd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ucomisd_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmUcomiss<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn ucomiss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ucomiss_xmm_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUcomiss<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn ucomiss(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ucomiss_xmm_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmUd0 for CodeAssembler {
	#[inline]
	fn ud0(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Ud0))
	}
}

#[rustfmt::skip]
impl CodeAsmUd02<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn ud0_2(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ud0_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUd02<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn ud0_2(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ud0_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUd02<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn ud0_2(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ud0_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUd02<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn ud0_2(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ud0_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmUd02<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn ud0_2(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ud0_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmUd02<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn ud0_2(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ud0_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmUd1<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn ud1(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ud1_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUd1<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn ud1(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ud1_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUd1<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn ud1(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ud1_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUd1<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn ud1(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ud1_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmUd1<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn ud1(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ud1_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmUd1<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn ud1(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ud1_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmUd2 for CodeAssembler {
	#[inline]
	fn ud2(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Ud2))
	}
}

#[rustfmt::skip]
impl CodeAsmUiret for CodeAssembler {
	#[inline]
	fn uiret(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Uiret))
	}
}

#[rustfmt::skip]
impl CodeAsmUmonitor<__AsmRegister16> for CodeAssembler {
	#[inline]
	fn umonitor(&mut self, op0: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Umonitor_r16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUmonitor<__AsmRegister32> for CodeAssembler {
	#[inline]
	fn umonitor(&mut self, op0: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Umonitor_r32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUmonitor<__AsmRegister64> for CodeAssembler {
	#[inline]
	fn umonitor(&mut self, op0: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Umonitor_r64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUmov<__AsmRegister8, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn umov(&mut self, op0: __AsmRegister8, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Umov_rm8_r8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUmov<__AsmMemoryOperand, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn umov(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Umov_rm8_r8, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUmov<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn umov(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Umov_rm16_r16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUmov<__AsmMemoryOperand, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn umov(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Umov_rm16_r16, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUmov<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn umov(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Umov_rm32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUmov<__AsmMemoryOperand, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn umov(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Umov_rm32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUmov<__AsmRegister8, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn umov(&mut self, op0: __AsmRegister8, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Umov_r8_rm8, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmUmov<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn umov(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Umov_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmUmov<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn umov(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Umov_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmUmwait<__AsmRegister32> for CodeAssembler {
	#[inline]
	fn umwait(&mut self, op0: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Umwait_r32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUmwait<__AsmRegister64> for CodeAssembler {
	#[inline]
	fn umwait(&mut self, op0: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Umwait_r64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUnpckhpd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn unpckhpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Unpckhpd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUnpckhpd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn unpckhpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Unpckhpd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmUnpckhps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn unpckhps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Unpckhps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUnpckhps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn unpckhps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Unpckhps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmUnpcklpd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn unpcklpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Unpcklpd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUnpcklpd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn unpcklpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Unpcklpd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmUnpcklps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn unpcklps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Unpcklps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUnpcklps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn unpcklps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Unpcklps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmV4fmaddps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn v4fmaddps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_V4fmaddps_zmm_k1z_zmmp3_m128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmV4fmaddss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn v4fmaddss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_V4fmaddss_xmm_k1z_xmmp3_m128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmV4fnmaddps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn v4fnmaddps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_V4fnmaddps_zmm_k1z_zmmp3_m128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmV4fnmaddss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn v4fnmaddss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_V4fnmaddss_xmm_k1z_xmmp3_m128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVaddpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vaddpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vaddpd_xmm_xmm_xmmm128 } else { Code::EVEX_Vaddpd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVaddpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vaddpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vaddpd_ymm_ymm_ymmm256 } else { Code::EVEX_Vaddpd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVaddpd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vaddpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vaddpd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVaddpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vaddpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vaddpd_xmm_k1z_xmm_xmmm128b64
		} else if self.prefer_vex() {
			Code::VEX_Vaddpd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vaddpd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVaddpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vaddpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vaddpd_ymm_k1z_ymm_ymmm256b64
		} else if self.prefer_vex() {
			Code::VEX_Vaddpd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vaddpd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVaddpd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaddpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vaddpd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVaddph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vaddph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vaddph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVaddph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vaddph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vaddph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVaddph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vaddph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vaddph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVaddph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaddph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vaddph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVaddph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaddph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vaddph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVaddph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaddph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vaddph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVaddps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vaddps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vaddps_xmm_xmm_xmmm128 } else { Code::EVEX_Vaddps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVaddps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vaddps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vaddps_ymm_ymm_ymmm256 } else { Code::EVEX_Vaddps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVaddps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vaddps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vaddps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVaddps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vaddps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vaddps_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vaddps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vaddps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVaddps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vaddps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vaddps_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vaddps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vaddps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVaddps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaddps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vaddps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVaddsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vaddsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vaddsd_xmm_xmm_xmmm64 } else { Code::EVEX_Vaddsd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVaddsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaddsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vaddsd_xmm_xmm_xmmm64 } else { Code::EVEX_Vaddsd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVaddsh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vaddsh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vaddsh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVaddsh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaddsh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vaddsh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVaddss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vaddss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vaddss_xmm_xmm_xmmm32 } else { Code::EVEX_Vaddss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVaddss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaddss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vaddss_xmm_xmm_xmmm32 } else { Code::EVEX_Vaddss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVaddsubpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vaddsubpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vaddsubpd_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaddsubpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vaddsubpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vaddsubpd_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaddsubpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaddsubpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vaddsubpd_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaddsubpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaddsubpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vaddsubpd_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaddsubps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vaddsubps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vaddsubps_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaddsubps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vaddsubps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vaddsubps_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaddsubps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaddsubps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vaddsubps_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaddsubps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaddsubps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vaddsubps_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesdec<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vaesdec(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vaesdec_xmm_xmm_xmmm128 } else { Code::EVEX_Vaesdec_xmm_xmm_xmmm128 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesdec<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vaesdec(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vaesdec_ymm_ymm_ymmm256 } else { Code::EVEX_Vaesdec_ymm_ymm_ymmm256 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesdec<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vaesdec(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vaesdec_zmm_zmm_zmmm512, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesdec<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaesdec(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vaesdec_xmm_xmm_xmmm128 } else { Code::EVEX_Vaesdec_xmm_xmm_xmmm128 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesdec<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaesdec(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vaesdec_ymm_ymm_ymmm256 } else { Code::EVEX_Vaesdec_ymm_ymm_ymmm256 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesdec<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaesdec(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vaesdec_zmm_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesdeclast<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vaesdeclast(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vaesdeclast_xmm_xmm_xmmm128 } else { Code::EVEX_Vaesdeclast_xmm_xmm_xmmm128 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesdeclast<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vaesdeclast(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vaesdeclast_ymm_ymm_ymmm256 } else { Code::EVEX_Vaesdeclast_ymm_ymm_ymmm256 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesdeclast<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vaesdeclast(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vaesdeclast_zmm_zmm_zmmm512, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesdeclast<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaesdeclast(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vaesdeclast_xmm_xmm_xmmm128 } else { Code::EVEX_Vaesdeclast_xmm_xmm_xmmm128 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesdeclast<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaesdeclast(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vaesdeclast_ymm_ymm_ymmm256 } else { Code::EVEX_Vaesdeclast_ymm_ymm_ymmm256 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesdeclast<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaesdeclast(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vaesdeclast_zmm_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesenc<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vaesenc(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vaesenc_xmm_xmm_xmmm128 } else { Code::EVEX_Vaesenc_xmm_xmm_xmmm128 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesenc<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vaesenc(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vaesenc_ymm_ymm_ymmm256 } else { Code::EVEX_Vaesenc_ymm_ymm_ymmm256 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesenc<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vaesenc(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vaesenc_zmm_zmm_zmmm512, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesenc<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaesenc(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vaesenc_xmm_xmm_xmmm128 } else { Code::EVEX_Vaesenc_xmm_xmm_xmmm128 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesenc<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaesenc(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vaesenc_ymm_ymm_ymmm256 } else { Code::EVEX_Vaesenc_ymm_ymm_ymmm256 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesenc<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaesenc(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vaesenc_zmm_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesenclast<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vaesenclast(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vaesenclast_xmm_xmm_xmmm128 } else { Code::EVEX_Vaesenclast_xmm_xmm_xmmm128 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesenclast<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vaesenclast(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vaesenclast_ymm_ymm_ymmm256 } else { Code::EVEX_Vaesenclast_ymm_ymm_ymmm256 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesenclast<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vaesenclast(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vaesenclast_zmm_zmm_zmmm512, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesenclast<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaesenclast(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vaesenclast_xmm_xmm_xmmm128 } else { Code::EVEX_Vaesenclast_xmm_xmm_xmmm128 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesenclast<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaesenclast(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vaesenclast_ymm_ymm_ymmm256 } else { Code::EVEX_Vaesenclast_ymm_ymm_ymmm256 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesenclast<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaesenclast(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vaesenclast_zmm_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesimc<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vaesimc(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vaesimc_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesimc<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaesimc(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vaesimc_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaeskeygenassist<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vaeskeygenassist(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vaeskeygenassist_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaeskeygenassist<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vaeskeygenassist(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vaeskeygenassist_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaeskeygenassist<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vaeskeygenassist(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vaeskeygenassist_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaeskeygenassist<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vaeskeygenassist(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vaeskeygenassist_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmValignd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn valignd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignd_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmValignd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn valignd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignd_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmValignd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn valignd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignd_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmValignd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn valignd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignd_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmValignd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn valignd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignd_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmValignd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn valignd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignd_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmValignd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn valignd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignd_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmValignd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn valignd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignd_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmValignd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn valignd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignd_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmValignd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn valignd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignd_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmValignd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn valignd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignd_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmValignd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn valignd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignd_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmValignq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn valignq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignq_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmValignq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn valignq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignq_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmValignq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn valignq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignq_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmValignq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn valignq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignq_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmValignq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn valignq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignq_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmValignq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn valignq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignq_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmValignq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn valignq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignq_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmValignq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn valignq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignq_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmValignq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn valignq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignq_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmValignq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn valignq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignq_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmValignq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn valignq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignq_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmValignq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn valignq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignq_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVandnpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vandnpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vandnpd_xmm_xmm_xmmm128 } else { Code::EVEX_Vandnpd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVandnpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vandnpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vandnpd_ymm_ymm_ymmm256 } else { Code::EVEX_Vandnpd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVandnpd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vandnpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vandnpd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVandnpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vandnpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vandnpd_xmm_k1z_xmm_xmmm128b64
		} else if self.prefer_vex() {
			Code::VEX_Vandnpd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vandnpd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVandnpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vandnpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vandnpd_ymm_k1z_ymm_ymmm256b64
		} else if self.prefer_vex() {
			Code::VEX_Vandnpd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vandnpd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVandnpd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vandnpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vandnpd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVandnps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vandnps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vandnps_xmm_xmm_xmmm128 } else { Code::EVEX_Vandnps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVandnps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vandnps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vandnps_ymm_ymm_ymmm256 } else { Code::EVEX_Vandnps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVandnps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vandnps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vandnps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVandnps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vandnps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vandnps_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vandnps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vandnps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVandnps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vandnps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vandnps_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vandnps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vandnps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVandnps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vandnps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vandnps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVandpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vandpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vandpd_xmm_xmm_xmmm128 } else { Code::EVEX_Vandpd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVandpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vandpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vandpd_ymm_ymm_ymmm256 } else { Code::EVEX_Vandpd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVandpd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vandpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vandpd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVandpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vandpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vandpd_xmm_k1z_xmm_xmmm128b64
		} else if self.prefer_vex() {
			Code::VEX_Vandpd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vandpd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVandpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vandpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vandpd_ymm_k1z_ymm_ymmm256b64
		} else if self.prefer_vex() {
			Code::VEX_Vandpd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vandpd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVandpd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vandpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vandpd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVandps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vandps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vandps_xmm_xmm_xmmm128 } else { Code::EVEX_Vandps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVandps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vandps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vandps_ymm_ymm_ymmm256 } else { Code::EVEX_Vandps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVandps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vandps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vandps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVandps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vandps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vandps_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vandps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vandps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVandps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vandps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vandps_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vandps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vandps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVandps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vandps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vandps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVblendmpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vblendmpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vblendmpd_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVblendmpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vblendmpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vblendmpd_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVblendmpd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vblendmpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vblendmpd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVblendmpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vblendmpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vblendmpd_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVblendmpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vblendmpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vblendmpd_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVblendmpd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vblendmpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vblendmpd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVblendmps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vblendmps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vblendmps_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVblendmps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vblendmps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vblendmps_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVblendmps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vblendmps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vblendmps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVblendmps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vblendmps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vblendmps_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVblendmps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vblendmps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vblendmps_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVblendmps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vblendmps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vblendmps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVblendpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vblendpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendpd_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vblendpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendpd_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vblendpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendpd_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vblendpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendpd_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vblendpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendpd_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vblendpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendpd_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vblendpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendpd_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vblendpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendpd_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vblendps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendps_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vblendps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendps_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vblendps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendps_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vblendps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendps_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vblendps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendps_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vblendps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendps_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vblendps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendps_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vblendps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendps_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendvpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vblendvpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendvpd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendvpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vblendvpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendvpd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendvpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vblendvpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendvpd_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendvpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vblendvpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendvpd_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendvps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vblendvps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendvps_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendvps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vblendvps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendvps_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendvps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vblendvps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendvps_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendvps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vblendvps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendvps_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastf128<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcastf128(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vbroadcastf128_ymm_m128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastf32x2<__AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vbroadcastf32x2(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcastf32x2_ymm_k1z_xmmm64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastf32x2<__AsmRegisterZmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vbroadcastf32x2(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcastf32x2_zmm_k1z_xmmm64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastf32x2<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcastf32x2(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcastf32x2_ymm_k1z_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastf32x2<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcastf32x2(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcastf32x2_zmm_k1z_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastf32x4<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcastf32x4(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcastf32x4_ymm_k1z_m128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastf32x4<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcastf32x4(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcastf32x4_zmm_k1z_m128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastf32x8<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcastf32x8(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcastf32x8_zmm_k1z_m256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastf64x2<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcastf64x2(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcastf64x2_ymm_k1z_m128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastf64x2<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcastf64x2(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcastf64x2_zmm_k1z_m128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastf64x4<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcastf64x4(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcastf64x4_zmm_k1z_m256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcasti128<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcasti128(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vbroadcasti128_ymm_m128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcasti32x2<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vbroadcasti32x2(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcasti32x2_xmm_k1z_xmmm64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcasti32x2<__AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vbroadcasti32x2(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcasti32x2_ymm_k1z_xmmm64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcasti32x2<__AsmRegisterZmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vbroadcasti32x2(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcasti32x2_zmm_k1z_xmmm64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcasti32x2<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcasti32x2(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcasti32x2_xmm_k1z_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcasti32x2<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcasti32x2(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcasti32x2_ymm_k1z_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcasti32x2<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcasti32x2(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcasti32x2_zmm_k1z_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcasti32x4<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcasti32x4(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcasti32x4_ymm_k1z_m128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcasti32x4<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcasti32x4(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcasti32x4_zmm_k1z_m128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcasti32x8<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcasti32x8(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcasti32x8_zmm_k1z_m256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcasti64x2<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcasti64x2(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcasti64x2_ymm_k1z_m128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcasti64x2<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcasti64x2(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcasti64x2_zmm_k1z_m128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcasti64x4<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcasti64x4(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcasti64x4_zmm_k1z_m256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastsd<__AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vbroadcastsd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vbroadcastsd_ymm_xmm } else { Code::EVEX_Vbroadcastsd_ymm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastsd<__AsmRegisterZmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vbroadcastsd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcastsd_zmm_k1z_xmmm64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastsd<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcastsd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vbroadcastsd_ymm_m64 } else { Code::EVEX_Vbroadcastsd_ymm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastsd<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcastsd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcastsd_zmm_k1z_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastss<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vbroadcastss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vbroadcastss_xmm_xmm } else { Code::EVEX_Vbroadcastss_xmm_k1z_xmmm32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastss<__AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vbroadcastss(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vbroadcastss_ymm_xmm } else { Code::EVEX_Vbroadcastss_ymm_k1z_xmmm32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastss<__AsmRegisterZmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vbroadcastss(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcastss_zmm_k1z_xmmm32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastss<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcastss(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vbroadcastss_xmm_m32 } else { Code::EVEX_Vbroadcastss_xmm_k1z_xmmm32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastss<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcastss(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vbroadcastss_ymm_m32 } else { Code::EVEX_Vbroadcastss_ymm_k1z_xmmm32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastss<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcastss(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcastss_zmm_k1z_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ospd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_ospd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ospd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_ospd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ospd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_ospd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ospd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_ospd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ospd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_ospd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ospd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_ospd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ospd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_ospd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ospd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_ospd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ospd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_ospd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ospd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_ospd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_osph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_osph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_osph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_osph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_osph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_osph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_osph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_osph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_osph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_osph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_osph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_osph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_osps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_osps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_osps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_osps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_osps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_osps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_osps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_osps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_osps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_osps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_osps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_osps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_osps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_osps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_osps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_osps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_osps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_osps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_osps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_osps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ossd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_ossd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ossd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_ossd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ossd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_ossd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ossd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_ossd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ossh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_ossh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ossh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_ossh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_osss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_osss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_osss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_osss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_osss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_osss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_osss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_osss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqpd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqpd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqpd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqpd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqpd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqpd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqsd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqsd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqsh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqsh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uspd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uspd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uspd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uspd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uspd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uspd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uspd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uspd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uspd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uspd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uspd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uspd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uspd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uspd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uspd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uspd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uspd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uspd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uspd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uspd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_usph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_usph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_usph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_usph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_usph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_usph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_usph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_usph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_usph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_usph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_usph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_usph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_usps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_usps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_usps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_usps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_usps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_usps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_usps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_usps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_usps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_usps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_usps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_usps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_usps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_usps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_usps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_usps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_usps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_usps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_usps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_usps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ussd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_ussd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ussd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_ussd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ussd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_ussd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ussd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_ussd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ussh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_ussh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ussh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_ussh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_usss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_usss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_usss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_usss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_usss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_usss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_usss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_usss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqpd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeqpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqpd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpeqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpeqpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqpd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpeqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqpd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeqpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqpd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeqpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqpd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpeqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpeqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeqps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpeqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpeqps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpeqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeqps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeqps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeqsd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeqsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeqsd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeqsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeqsh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeqsh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeqss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeqss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeqss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeqss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_ospd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpfalse_ospd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_ospd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpfalse_ospd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_ospd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpfalse_ospd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_ospd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpfalse_ospd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_ospd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpfalse_ospd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_ospd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalse_ospd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_ospd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalse_ospd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_ospd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalse_ospd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_ospd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalse_ospd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_ospd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalse_ospd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_osph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpfalse_osph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_osph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpfalse_osph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_osph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpfalse_osph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_osph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalse_osph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_osph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalse_osph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_osph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalse_osph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_osps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpfalse_osps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_osps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpfalse_osps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_osps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpfalse_osps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_osps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpfalse_osps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_osps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpfalse_osps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_osps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalse_osps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_osps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalse_osps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_osps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalse_osps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_osps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalse_osps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_osps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalse_osps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_ossd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpfalse_ossd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_ossd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpfalse_ossd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_ossd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalse_ossd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_ossd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalse_ossd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_ossh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpfalse_ossh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_ossh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalse_ossh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_osss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpfalse_osss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_osss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpfalse_osss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_osss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalse_osss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_osss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalse_osss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalsepd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpfalsepd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalsepd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpfalsepd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalsepd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpfalsepd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalsepd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpfalsepd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalsepd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpfalsepd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalsepd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalsepd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalsepd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalsepd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalsepd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalsepd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalsepd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalsepd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalsepd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalsepd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalseph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpfalseph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalseph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpfalseph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalseph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpfalseph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalseph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalseph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalseph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalseph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalseph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalseph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalseps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpfalseps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalseps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpfalseps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalseps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpfalseps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalseps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpfalseps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalseps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpfalseps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalseps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalseps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalseps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalseps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalseps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalseps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalseps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalseps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalseps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalseps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalsesd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpfalsesd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalsesd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpfalsesd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalsesd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalsesd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalsesd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalsesd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalsesh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpfalsesh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalsesh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalsesh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalsess<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpfalsess(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalsess<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpfalsess(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalsess<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalsess(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalsess<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalsess(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqpd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpge_oqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpge_oqpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqpd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpge_oqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpge_oqpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqpd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpge_oqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqpd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpge_oqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpge_oqpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqpd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpge_oqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpge_oqpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqpd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpge_oqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpge_oqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpge_oqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpge_oqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpge_oqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpge_oqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpge_oqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpge_oqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpge_oqps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpge_oqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpge_oqps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpge_oqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpge_oqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpge_oqps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpge_oqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpge_oqps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpge_oqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpge_oqsd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpge_oqsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpge_oqsd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpge_oqsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpge_oqsh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpge_oqsh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpge_oqss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpge_oqss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpge_oqss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpge_oqss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgepd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgepd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgepd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgepd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgepd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpgepd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgepd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpgepd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgepd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpgepd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgepd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgepd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgepd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgepd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgepd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgepd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgepd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgepd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgepd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgepd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgeph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgeph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgeph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpgeph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgeph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpgeph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgeph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgeph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgeph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgeph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgeph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgeph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgeps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgeps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgeps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgeps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgeps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpgeps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgeps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpgeps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgeps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpgeps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgeps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgeps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgeps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgeps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgeps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgeps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgeps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgeps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgeps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgeps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgesd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgesd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgesd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgesd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgesd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgesd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgesd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgesd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgesh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgesh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgesh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgesh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgess<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgess(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgess<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgess(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgess<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgess(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgess<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgess(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqpd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqpd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqpd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqpd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqpd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqpd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqsd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqsd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqsh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqsh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtpd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgtpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgtpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtpd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpgtpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpgtpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtpd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpgtpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtpd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgtpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgtpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtpd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgtpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgtpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtpd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgtpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgtph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpgtph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpgtph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgtph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgtph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgtph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgtps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgtps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpgtps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpgtps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpgtps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgtps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgtps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgtps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgtps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgtps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgtsd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgtsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgtsd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgtsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgtsh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgtsh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgtss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgtss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgtss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgtss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqpd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmple_oqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmple_oqpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqpd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmple_oqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmple_oqpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqpd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmple_oqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqpd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmple_oqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmple_oqpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqpd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmple_oqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmple_oqpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqpd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmple_oqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmple_oqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmple_oqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmple_oqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmple_oqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmple_oqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmple_oqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmple_oqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmple_oqps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmple_oqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmple_oqps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmple_oqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmple_oqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmple_oqps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmple_oqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmple_oqps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmple_oqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmple_oqsd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmple_oqsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmple_oqsd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmple_oqsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmple_oqsh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmple_oqsh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmple_oqss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmple_oqss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmple_oqss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmple_oqss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplepd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmplepd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplepd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmplepd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplepd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmplepd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplepd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmplepd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplepd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmplepd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplepd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplepd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplepd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplepd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplepd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplepd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplepd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplepd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplepd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplepd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpleph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpleph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpleph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpleph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpleph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpleph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpleph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpleph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpleph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpleph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpleph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpleph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpleps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpleps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpleps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpleps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpleps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpleps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpleps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpleps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpleps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpleps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpleps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpleps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpleps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpleps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpleps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpleps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpleps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpleps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpleps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpleps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplesd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmplesd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplesd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmplesd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplesd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplesd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplesd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplesd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplesh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmplesh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplesh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplesh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpless<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpless(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpless<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpless(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpless<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpless(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpless<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpless(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqpd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmplt_oqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmplt_oqpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqpd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmplt_oqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmplt_oqpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqpd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmplt_oqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqpd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplt_oqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplt_oqpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqpd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplt_oqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplt_oqpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqpd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplt_oqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmplt_oqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmplt_oqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmplt_oqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplt_oqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplt_oqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplt_oqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmplt_oqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmplt_oqps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmplt_oqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmplt_oqps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmplt_oqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplt_oqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplt_oqps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplt_oqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplt_oqps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplt_oqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmplt_oqsd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmplt_oqsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplt_oqsd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplt_oqsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmplt_oqsh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplt_oqsh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmplt_oqss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmplt_oqss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplt_oqss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplt_oqss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltpd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpltpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpltpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltpd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpltpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpltpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltpd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpltpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltpd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpltpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpltpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltpd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpltpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpltpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltpd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpltpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpltph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpltph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpltph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpltph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpltph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpltph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpltps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpltps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpltps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpltps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpltps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpltps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpltps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpltps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpltps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpltps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpltsd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpltsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpltsd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpltsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpltsh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpltsh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpltss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpltss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpltss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpltss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqpd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqpd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqpd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqpd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqpd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqpd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqsd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqsd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqsh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqsh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ospd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_ospd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ospd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_ospd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ospd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_ospd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ospd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_ospd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ospd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_ospd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ospd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_ospd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ospd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_ospd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ospd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_ospd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ospd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_ospd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ospd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_ospd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_osph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_osph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_osph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_osph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_osph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_osph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_osph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_osph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_osph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_osph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_osph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_osph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_osps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_osps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_osps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_osps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_osps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_osps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_osps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_osps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_osps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_osps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_osps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_osps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_osps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_osps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_osps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_osps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_osps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_osps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_osps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_osps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ossd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_ossd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ossd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_ossd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ossd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_ossd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ossd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_ossd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ossh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_ossh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ossh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_ossh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_osss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_osss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_osss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_osss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_osss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_osss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_osss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_osss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_uspd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_uspd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_uspd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_uspd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_uspd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_uspd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_uspd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_uspd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_uspd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_uspd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_uspd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_uspd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_uspd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_uspd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_uspd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_uspd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_uspd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_uspd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_uspd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_uspd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_usph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_usph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_usph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_usph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_usph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_usph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_usph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_usph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_usph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_usph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_usph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_usph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_usps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_usps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_usps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_usps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_usps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_usps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_usps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_usps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_usps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_usps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_usps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_usps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_usps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_usps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_usps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_usps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_usps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_usps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_usps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_usps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ussd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_ussd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ussd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_ussd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ussd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_ussd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ussd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_ussd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ussh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_ussh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ussh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_ussh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_usss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_usss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_usss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_usss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_usss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_usss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_usss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_usss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqpd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneqpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqpd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpneqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpneqpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqpd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpneqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqpd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneqpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqpd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneqpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqpd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpneqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpneqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneqps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpneqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpneqps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpneqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneqps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneqps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneqsd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneqsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneqsd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneqsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneqsh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneqsh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneqss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneqss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneqss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneqss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqpd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqpd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqpd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqpd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqpd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqpd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqsd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqsd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqsh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqsh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngepd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngepd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngepd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngepd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngepd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpngepd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngepd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpngepd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngepd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpngepd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngepd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngepd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngepd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngepd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngepd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngepd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngepd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngepd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngepd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngepd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngeph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngeph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngeph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpngeph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngeph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpngeph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngeph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngeph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngeph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngeph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngeph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngeph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngeps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngeps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngeps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngeps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngeps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpngeps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngeps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpngeps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngeps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpngeps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngeps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngeps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngeps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngeps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngeps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngeps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngeps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngeps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngeps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngeps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngesd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngesd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngesd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngesd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngesd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngesd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngesd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngesd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngesh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngesh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngesh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngesh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngess<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngess(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngess<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngess(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngess<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngess(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngess<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngess(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqpd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqpd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqpd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqpd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqpd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqpd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqsd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqsd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqsh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqsh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtpd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngtpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngtpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtpd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpngtpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpngtpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtpd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpngtpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtpd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngtpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngtpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtpd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngtpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngtpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtpd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngtpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngtph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpngtph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpngtph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngtph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngtph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngtph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngtps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngtps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpngtps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpngtps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpngtps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngtps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngtps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngtps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngtps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngtps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngtsd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngtsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngtsd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngtsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngtsh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngtsh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngtss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngtss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngtss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngtss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqpd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqpd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqpd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqpd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqpd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqpd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqsd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqsd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqsh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqsh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlepd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnlepd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlepd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnlepd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlepd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnlepd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlepd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnlepd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlepd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpnlepd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlepd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlepd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlepd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlepd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlepd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlepd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlepd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlepd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlepd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlepd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnleph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnleph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnleph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnleph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnleph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpnleph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnleph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnleph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnleph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnleph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnleph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnleph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnleps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnleps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnleps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnleps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnleps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnleps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnleps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnleps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnleps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpnleps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnleps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnleps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnleps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnleps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnleps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnleps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnleps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnleps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnleps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnleps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlesd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnlesd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlesd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnlesd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlesd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlesd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlesd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlesd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlesh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnlesh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlesh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlesh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnless<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnless(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnless<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnless(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnless<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnless(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnless<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnless(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqpd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqpd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqpd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqpd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqpd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqpd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqsd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqsd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqsh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqsh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltpd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnltpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnltpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltpd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnltpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnltpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltpd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpnltpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltpd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnltpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnltpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltpd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnltpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnltpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltpd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnltpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnltph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnltph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpnltph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnltph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnltph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnltph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnltps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnltps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnltps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnltps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpnltps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnltps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnltps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnltps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnltps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnltps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnltsd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnltsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnltsd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnltsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnltsh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnltsh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnltss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnltss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnltss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnltss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_spd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpord_spd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_spd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpord_spd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_spd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpord_spd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_spd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpord_spd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_spd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpord_spd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_spd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpord_spd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_spd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpord_spd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_spd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpord_spd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_spd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpord_spd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_spd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpord_spd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_sph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpord_sph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_sph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpord_sph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_sph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpord_sph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_sph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpord_sph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_sph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpord_sph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_sph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpord_sph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_sps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpord_sps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_sps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpord_sps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_sps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpord_sps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_sps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpord_sps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_sps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpord_sps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_sps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpord_sps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_sps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpord_sps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_sps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpord_sps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_sps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpord_sps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_sps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpord_sps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_ssd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpord_ssd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_ssd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpord_ssd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_ssd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpord_ssd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_ssd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpord_ssd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_ssh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpord_ssh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_ssh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpord_ssh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_sss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpord_sss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_sss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpord_sss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_sss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpord_sss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_sss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpord_sss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordpd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpordpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpordpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordpd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpordpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpordpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordpd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpordpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordpd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpordpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpordpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordpd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpordpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpordpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordpd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpordpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpordph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpordph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpordph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpordph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpordph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpordph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpordps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpordps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpordps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpordps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpordps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpordps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpordps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpordps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpordps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpordps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpordsd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpordsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpordsd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpordsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpordsh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpordsh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpordss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpordss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpordss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpordss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vcmppd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmppd_kr_k1_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vcmppd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmppd_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vcmppd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmppd_kr_k1_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vcmppd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmppd_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vcmppd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmppd_kr_k1_zmm_zmmm512b64_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vcmppd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmppd_kr_k1_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vcmppd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmppd_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vcmppd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmppd_kr_k1_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vcmppd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmppd_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vcmppd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmppd_kr_k1_zmm_zmmm512b64_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vcmppd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmppd_kr_k1_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vcmppd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmppd_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vcmppd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmppd_kr_k1_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vcmppd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmppd_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vcmppd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmppd_kr_k1_zmm_zmmm512b64_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vcmppd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmppd_kr_k1_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vcmppd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmppd_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vcmppd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmppd_kr_k1_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vcmppd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmppd_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vcmppd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmppd_kr_k1_zmm_zmmm512b64_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vcmpph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpph_kr_k1_xmm_xmmm128b16_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vcmpph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpph_kr_k1_ymm_ymmm256b16_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vcmpph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpph_kr_k1_zmm_zmmm512b16_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vcmpph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpph_kr_k1_xmm_xmmm128b16_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vcmpph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpph_kr_k1_ymm_ymmm256b16_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vcmpph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpph_kr_k1_zmm_zmmm512b16_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vcmpph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpph_kr_k1_xmm_xmmm128b16_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vcmpph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpph_kr_k1_ymm_ymmm256b16_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vcmpph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpph_kr_k1_zmm_zmmm512b16_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vcmpph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpph_kr_k1_xmm_xmmm128b16_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vcmpph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpph_kr_k1_ymm_ymmm256b16_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vcmpph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpph_kr_k1_zmm_zmmm512b16_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vcmpps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpps_kr_k1_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vcmpps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmpps_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vcmpps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpps_kr_k1_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vcmpps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmpps_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vcmpps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpps_kr_k1_zmm_zmmm512b32_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vcmpps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpps_kr_k1_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vcmpps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmpps_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vcmpps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpps_kr_k1_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vcmpps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmpps_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vcmpps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpps_kr_k1_zmm_zmmm512b32_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vcmpps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpps_kr_k1_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vcmpps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmpps_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vcmpps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpps_kr_k1_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vcmpps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmpps_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vcmpps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpps_kr_k1_zmm_zmmm512b32_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vcmpps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpps_kr_k1_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vcmpps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmpps_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vcmpps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpps_kr_k1_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vcmpps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmpps_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vcmpps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpps_kr_k1_zmm_zmmm512b32_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vcmpsd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpsd_kr_k1_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vcmpsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmpsd_xmm_xmm_xmmm64_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vcmpsd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpsd_kr_k1_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vcmpsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmpsd_xmm_xmm_xmmm64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vcmpsd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpsd_kr_k1_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vcmpsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmpsd_xmm_xmm_xmmm64_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vcmpsd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpsd_kr_k1_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vcmpsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmpsd_xmm_xmm_xmmm64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vcmpsh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpsh_kr_k1_xmm_xmmm16_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vcmpsh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpsh_kr_k1_xmm_xmmm16_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vcmpsh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpsh_kr_k1_xmm_xmmm16_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vcmpsh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpsh_kr_k1_xmm_xmmm16_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vcmpss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpss_kr_k1_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vcmpss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmpss_xmm_xmm_xmmm32_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vcmpss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpss_kr_k1_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vcmpss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmpss_xmm_xmm_xmmm32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vcmpss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpss_kr_k1_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vcmpss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmpss_xmm_xmm_xmmm32_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vcmpss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpss_kr_k1_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vcmpss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmpss_xmm_xmm_xmmm32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_uspd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmptrue_uspd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_uspd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmptrue_uspd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_uspd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmptrue_uspd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_uspd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmptrue_uspd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_uspd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmptrue_uspd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_uspd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrue_uspd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_uspd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrue_uspd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_uspd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrue_uspd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_uspd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrue_uspd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_uspd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrue_uspd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_usph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmptrue_usph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_usph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmptrue_usph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_usph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmptrue_usph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_usph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrue_usph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_usph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrue_usph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_usph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrue_usph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_usps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmptrue_usps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_usps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmptrue_usps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_usps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmptrue_usps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_usps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmptrue_usps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_usps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmptrue_usps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_usps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrue_usps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_usps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrue_usps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_usps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrue_usps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_usps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrue_usps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_usps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrue_usps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_ussd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmptrue_ussd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_ussd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmptrue_ussd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_ussd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrue_ussd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_ussd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrue_ussd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_ussh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmptrue_ussh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_ussh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrue_ussh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_usss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmptrue_usss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_usss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmptrue_usss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_usss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrue_usss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_usss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrue_usss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptruepd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmptruepd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptruepd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmptruepd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptruepd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmptruepd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptruepd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmptruepd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptruepd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmptruepd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptruepd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptruepd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptruepd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptruepd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptruepd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptruepd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptruepd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptruepd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptruepd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptruepd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrueph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmptrueph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrueph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmptrueph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrueph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmptrueph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrueph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrueph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrueph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrueph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrueph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrueph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrueps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmptrueps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrueps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmptrueps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrueps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmptrueps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrueps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmptrueps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrueps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmptrueps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrueps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrueps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrueps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrueps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrueps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrueps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrueps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrueps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrueps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrueps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptruesd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmptruesd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptruesd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmptruesd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptruesd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptruesd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptruesd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptruesd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptruesh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmptruesh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptruesh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptruesh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptruess<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmptruess(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptruess<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmptruess(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptruess<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptruess(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptruess<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptruess(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_spd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpunord_spd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_spd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpunord_spd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_spd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpunord_spd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_spd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpunord_spd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_spd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpunord_spd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_spd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunord_spd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_spd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunord_spd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_spd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunord_spd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_spd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunord_spd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_spd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunord_spd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_sph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpunord_sph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_sph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpunord_sph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_sph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpunord_sph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_sph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunord_sph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_sph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunord_sph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_sph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunord_sph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_sps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpunord_sps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_sps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpunord_sps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_sps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpunord_sps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_sps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpunord_sps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_sps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpunord_sps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_sps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunord_sps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_sps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunord_sps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_sps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunord_sps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_sps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunord_sps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_sps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunord_sps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_ssd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpunord_ssd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_ssd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpunord_ssd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_ssd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunord_ssd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_ssd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunord_ssd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_ssh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpunord_ssh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_ssh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunord_ssh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_sss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpunord_sss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_sss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpunord_sss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_sss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunord_sss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_sss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunord_sss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordpd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpunordpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpunordpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordpd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpunordpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpunordpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordpd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpunordpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordpd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunordpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunordpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordpd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunordpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunordpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordpd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunordpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpunordph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpunordph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpunordph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunordph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunordph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunordph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpunordps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpunordps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpunordps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpunordps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpunordps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunordps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunordps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunordps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunordps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunordps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpunordsd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpunordsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunordsd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunordsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpunordsh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunordsh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpunordss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpunordss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunordss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunordss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcomisd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcomisd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcomisd_xmm_xmmm64 } else { Code::EVEX_Vcomisd_xmm_xmmm64_sae };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcomisd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcomisd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcomisd_xmm_xmmm64 } else { Code::EVEX_Vcomisd_xmm_xmmm64_sae };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcomish<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcomish(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcomish_xmm_xmmm16_sae, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcomish<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcomish(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcomish_xmm_xmmm16_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcomiss<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcomiss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcomiss_xmm_xmmm32 } else { Code::EVEX_Vcomiss_xmm_xmmm32_sae };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcomiss<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcomiss(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcomiss_xmm_xmmm32 } else { Code::EVEX_Vcomiss_xmm_xmmm32_sae };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcompresspd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcompresspd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcompresspd_xmmm128_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcompresspd<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcompresspd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcompresspd_xmmm128_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcompresspd<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcompresspd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcompresspd_ymmm256_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcompresspd<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcompresspd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcompresspd_ymmm256_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcompresspd<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcompresspd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcompresspd_zmmm512_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcompresspd<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcompresspd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcompresspd_zmmm512_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcompressps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcompressps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcompressps_xmmm128_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcompressps<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcompressps(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcompressps_xmmm128_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcompressps<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcompressps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcompressps_ymmm256_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcompressps<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcompressps(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcompressps_ymmm256_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcompressps<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcompressps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcompressps_zmmm512_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcompressps<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcompressps(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcompressps_zmmm512_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtdq2pd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtdq2pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvtdq2pd_xmm_xmmm64 } else { Code::EVEX_Vcvtdq2pd_xmm_k1z_xmmm64b32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtdq2pd<__AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtdq2pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvtdq2pd_ymm_xmmm128 } else { Code::EVEX_Vcvtdq2pd_ymm_k1z_xmmm128b32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtdq2pd<__AsmRegisterZmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtdq2pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtdq2pd_zmm_k1z_ymmm256b32_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtdq2pd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vcvtdq2pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvtdq2pd_xmm_k1z_xmmm64b32
		} else if self.prefer_vex() {
			Code::VEX_Vcvtdq2pd_xmm_xmmm64
		} else {
			Code::EVEX_Vcvtdq2pd_xmm_k1z_xmmm64b32
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtdq2pd<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vcvtdq2pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvtdq2pd_ymm_k1z_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vcvtdq2pd_ymm_xmmm128
		} else {
			Code::EVEX_Vcvtdq2pd_ymm_k1z_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtdq2pd<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtdq2pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtdq2pd_zmm_k1z_ymmm256b32_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtdq2ph<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtdq2ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtdq2ph_xmm_k1z_xmmm128b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtdq2ph<__AsmRegisterXmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtdq2ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtdq2ph_xmm_k1z_ymmm256b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtdq2ph<__AsmRegisterYmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtdq2ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtdq2ph_ymm_k1z_zmmm512b32_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtdq2ph<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vcvtdq2ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvtdq2ph_xmm_k1z_ymmm256b32
		} else if op1.size() == MemoryOperandSize::Yword {
			Code::EVEX_Vcvtdq2ph_xmm_k1z_ymmm256b32
		} else if op1.size() == MemoryOperandSize::Xword {
			Code::EVEX_Vcvtdq2ph_xmm_k1z_xmmm128b32
		} else {
			return Err(IcedError::new("vcvtdq2ph: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtdq2ph<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtdq2ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtdq2ph_ymm_k1z_zmmm512b32_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtdq2phx<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtdq2phx(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtdq2ph_xmm_k1z_xmmm128b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtdq2phy<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtdq2phy(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtdq2ph_xmm_k1z_ymmm256b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtdq2ps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtdq2ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvtdq2ps_xmm_xmmm128 } else { Code::EVEX_Vcvtdq2ps_xmm_k1z_xmmm128b32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtdq2ps<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtdq2ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvtdq2ps_ymm_ymmm256 } else { Code::EVEX_Vcvtdq2ps_ymm_k1z_ymmm256b32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtdq2ps<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtdq2ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtdq2ps_zmm_k1z_zmmm512b32_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtdq2ps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vcvtdq2ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvtdq2ps_xmm_k1z_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vcvtdq2ps_xmm_xmmm128
		} else {
			Code::EVEX_Vcvtdq2ps_xmm_k1z_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtdq2ps<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vcvtdq2ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvtdq2ps_ymm_k1z_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vcvtdq2ps_ymm_ymmm256
		} else {
			Code::EVEX_Vcvtdq2ps_ymm_k1z_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtdq2ps<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtdq2ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtdq2ps_zmm_k1z_zmmm512b32_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtne2ps2bf16<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtne2ps2bf16(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtne2ps2bf16_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtne2ps2bf16<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtne2ps2bf16(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtne2ps2bf16_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtne2ps2bf16<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtne2ps2bf16(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtne2ps2bf16_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtne2ps2bf16<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtne2ps2bf16(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtne2ps2bf16_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtne2ps2bf16<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtne2ps2bf16(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtne2ps2bf16_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtne2ps2bf16<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtne2ps2bf16(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtne2ps2bf16_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtneps2bf16<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtneps2bf16(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtneps2bf16_xmm_k1z_xmmm128b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtneps2bf16<__AsmRegisterXmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtneps2bf16(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtneps2bf16_xmm_k1z_ymmm256b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtneps2bf16<__AsmRegisterYmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtneps2bf16(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtneps2bf16_ymm_k1z_zmmm512b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtneps2bf16<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vcvtneps2bf16(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvtneps2bf16_xmm_k1z_ymmm256b32
		} else if op1.size() == MemoryOperandSize::Yword {
			Code::EVEX_Vcvtneps2bf16_xmm_k1z_ymmm256b32
		} else if op1.size() == MemoryOperandSize::Xword {
			Code::EVEX_Vcvtneps2bf16_xmm_k1z_xmmm128b32
		} else {
			return Err(IcedError::new("vcvtneps2bf16: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtneps2bf16<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtneps2bf16(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtneps2bf16_ymm_k1z_zmmm512b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtneps2bf16x<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtneps2bf16x(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtneps2bf16_xmm_k1z_xmmm128b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtneps2bf16y<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtneps2bf16y(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtneps2bf16_xmm_k1z_ymmm256b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2dq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtpd2dq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvtpd2dq_xmm_xmmm128 } else { Code::EVEX_Vcvtpd2dq_xmm_k1z_xmmm128b64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2dq<__AsmRegisterXmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtpd2dq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvtpd2dq_xmm_ymmm256 } else { Code::EVEX_Vcvtpd2dq_xmm_k1z_ymmm256b64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2dq<__AsmRegisterYmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtpd2dq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2dq_ymm_k1z_zmmm512b64_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2dq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vcvtpd2dq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvtpd2dq_xmm_k1z_ymmm256b64
		} else if op1.size() == MemoryOperandSize::Yword {
			if self.prefer_vex() { Code::VEX_Vcvtpd2dq_xmm_ymmm256 } else { Code::EVEX_Vcvtpd2dq_xmm_k1z_ymmm256b64 }
		} else if op1.size() == MemoryOperandSize::Xword {
			if self.prefer_vex() { Code::VEX_Vcvtpd2dq_xmm_xmmm128 } else { Code::EVEX_Vcvtpd2dq_xmm_k1z_xmmm128b64 }
		} else {
			return Err(IcedError::new("vcvtpd2dq: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2dq<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtpd2dq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2dq_ymm_k1z_zmmm512b64_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2dqx<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtpd2dqx(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2dq_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2dqy<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtpd2dqy(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2dq_xmm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2ph<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtpd2ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2ph_xmm_k1z_xmmm128b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2ph<__AsmRegisterXmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtpd2ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2ph_xmm_k1z_ymmm256b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2ph<__AsmRegisterXmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtpd2ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2ph_xmm_k1z_zmmm512b64_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2ph<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vcvtpd2ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvtpd2ph_xmm_k1z_zmmm512b64_er
		} else if op1.size() == MemoryOperandSize::Zword {
			Code::EVEX_Vcvtpd2ph_xmm_k1z_zmmm512b64_er
		} else if op1.size() == MemoryOperandSize::Yword {
			Code::EVEX_Vcvtpd2ph_xmm_k1z_ymmm256b64
		} else if op1.size() == MemoryOperandSize::Xword {
			Code::EVEX_Vcvtpd2ph_xmm_k1z_xmmm128b64
		} else {
			return Err(IcedError::new("vcvtpd2ph: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2phx<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtpd2phx(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2ph_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2phy<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtpd2phy(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2ph_xmm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2phz<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtpd2phz(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2ph_xmm_k1z_zmmm512b64_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2ps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtpd2ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvtpd2ps_xmm_xmmm128 } else { Code::EVEX_Vcvtpd2ps_xmm_k1z_xmmm128b64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2ps<__AsmRegisterXmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtpd2ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvtpd2ps_xmm_ymmm256 } else { Code::EVEX_Vcvtpd2ps_xmm_k1z_ymmm256b64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2ps<__AsmRegisterYmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtpd2ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2ps_ymm_k1z_zmmm512b64_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2ps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vcvtpd2ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvtpd2ps_xmm_k1z_ymmm256b64
		} else if op1.size() == MemoryOperandSize::Yword {
			if self.prefer_vex() { Code::VEX_Vcvtpd2ps_xmm_ymmm256 } else { Code::EVEX_Vcvtpd2ps_xmm_k1z_ymmm256b64 }
		} else if op1.size() == MemoryOperandSize::Xword {
			if self.prefer_vex() { Code::VEX_Vcvtpd2ps_xmm_xmmm128 } else { Code::EVEX_Vcvtpd2ps_xmm_k1z_xmmm128b64 }
		} else {
			return Err(IcedError::new("vcvtpd2ps: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2ps<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtpd2ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2ps_ymm_k1z_zmmm512b64_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2psx<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtpd2psx(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2ps_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2psy<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtpd2psy(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2ps_xmm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2qq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtpd2qq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2qq_xmm_k1z_xmmm128b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2qq<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtpd2qq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2qq_ymm_k1z_ymmm256b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2qq<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtpd2qq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2qq_zmm_k1z_zmmm512b64_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2qq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtpd2qq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2qq_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2qq<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtpd2qq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2qq_ymm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2qq<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtpd2qq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2qq_zmm_k1z_zmmm512b64_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2udq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtpd2udq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2udq_xmm_k1z_xmmm128b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2udq<__AsmRegisterXmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtpd2udq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2udq_xmm_k1z_ymmm256b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2udq<__AsmRegisterYmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtpd2udq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2udq_ymm_k1z_zmmm512b64_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2udq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vcvtpd2udq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvtpd2udq_xmm_k1z_ymmm256b64
		} else if op1.size() == MemoryOperandSize::Yword {
			Code::EVEX_Vcvtpd2udq_xmm_k1z_ymmm256b64
		} else if op1.size() == MemoryOperandSize::Xword {
			Code::EVEX_Vcvtpd2udq_xmm_k1z_xmmm128b64
		} else {
			return Err(IcedError::new("vcvtpd2udq: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2udq<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtpd2udq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2udq_ymm_k1z_zmmm512b64_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2udqx<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtpd2udqx(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2udq_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2udqy<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtpd2udqy(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2udq_xmm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2uqq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtpd2uqq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2uqq_xmm_k1z_xmmm128b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2uqq<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtpd2uqq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2uqq_ymm_k1z_ymmm256b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2uqq<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtpd2uqq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2uqq_zmm_k1z_zmmm512b64_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2uqq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtpd2uqq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2uqq_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2uqq<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtpd2uqq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2uqq_ymm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2uqq<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtpd2uqq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2uqq_zmm_k1z_zmmm512b64_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2dq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtph2dq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2dq_xmm_k1z_xmmm64b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2dq<__AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtph2dq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2dq_ymm_k1z_xmmm128b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2dq<__AsmRegisterZmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtph2dq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2dq_zmm_k1z_ymmm256b16_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2dq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2dq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2dq_xmm_k1z_xmmm64b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2dq<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2dq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2dq_ymm_k1z_xmmm128b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2dq<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2dq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2dq_zmm_k1z_ymmm256b16_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2pd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtph2pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2pd_xmm_k1z_xmmm32b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2pd<__AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtph2pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2pd_ymm_k1z_xmmm64b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2pd<__AsmRegisterZmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtph2pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2pd_zmm_k1z_xmmm128b16_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2pd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2pd_xmm_k1z_xmmm32b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2pd<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2pd_ymm_k1z_xmmm64b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2pd<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2pd_zmm_k1z_xmmm128b16_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2ps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtph2ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvtph2ps_xmm_xmmm64 } else { Code::EVEX_Vcvtph2ps_xmm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2ps<__AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtph2ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvtph2ps_ymm_xmmm128 } else { Code::EVEX_Vcvtph2ps_ymm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2ps<__AsmRegisterZmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtph2ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2ps_zmm_k1z_ymmm256_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2ps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvtph2ps_xmm_xmmm64 } else { Code::EVEX_Vcvtph2ps_xmm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2ps<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvtph2ps_ymm_xmmm128 } else { Code::EVEX_Vcvtph2ps_ymm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2ps<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2ps_zmm_k1z_ymmm256_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2psx<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtph2psx(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2psx_xmm_k1z_xmmm64b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2psx<__AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtph2psx(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2psx_ymm_k1z_xmmm128b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2psx<__AsmRegisterZmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtph2psx(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2psx_zmm_k1z_ymmm256b16_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2psx<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2psx(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2psx_xmm_k1z_xmmm64b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2psx<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2psx(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2psx_ymm_k1z_xmmm128b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2psx<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2psx(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2psx_zmm_k1z_ymmm256b16_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2qq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtph2qq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2qq_xmm_k1z_xmmm32b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2qq<__AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtph2qq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2qq_ymm_k1z_xmmm64b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2qq<__AsmRegisterZmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtph2qq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2qq_zmm_k1z_xmmm128b16_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2qq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2qq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2qq_xmm_k1z_xmmm32b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2qq<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2qq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2qq_ymm_k1z_xmmm64b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2qq<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2qq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2qq_zmm_k1z_xmmm128b16_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2udq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtph2udq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2udq_xmm_k1z_xmmm64b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2udq<__AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtph2udq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2udq_ymm_k1z_xmmm128b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2udq<__AsmRegisterZmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtph2udq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2udq_zmm_k1z_ymmm256b16_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2udq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2udq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2udq_xmm_k1z_xmmm64b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2udq<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2udq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2udq_ymm_k1z_xmmm128b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2udq<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2udq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2udq_zmm_k1z_ymmm256b16_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2uqq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtph2uqq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2uqq_xmm_k1z_xmmm32b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2uqq<__AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtph2uqq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2uqq_ymm_k1z_xmmm64b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2uqq<__AsmRegisterZmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtph2uqq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2uqq_zmm_k1z_xmmm128b16_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2uqq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2uqq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2uqq_xmm_k1z_xmmm32b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2uqq<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2uqq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2uqq_ymm_k1z_xmmm64b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2uqq<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2uqq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2uqq_zmm_k1z_xmmm128b16_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2uw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtph2uw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2uw_xmm_k1z_xmmm128b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2uw<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtph2uw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2uw_ymm_k1z_ymmm256b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2uw<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtph2uw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2uw_zmm_k1z_zmmm512b16_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2uw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2uw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2uw_xmm_k1z_xmmm128b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2uw<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2uw(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2uw_ymm_k1z_ymmm256b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2uw<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2uw(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2uw_zmm_k1z_zmmm512b16_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2w<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtph2w(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2w_xmm_k1z_xmmm128b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2w<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtph2w(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2w_ymm_k1z_ymmm256b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2w<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtph2w(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2w_zmm_k1z_zmmm512b16_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2w<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2w(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2w_xmm_k1z_xmmm128b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2w<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2w(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2w_ymm_k1z_ymmm256b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2w<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2w(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2w_zmm_k1z_zmmm512b16_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2dq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtps2dq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvtps2dq_xmm_xmmm128 } else { Code::EVEX_Vcvtps2dq_xmm_k1z_xmmm128b32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2dq<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtps2dq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvtps2dq_ymm_ymmm256 } else { Code::EVEX_Vcvtps2dq_ymm_k1z_ymmm256b32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2dq<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtps2dq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2dq_zmm_k1z_zmmm512b32_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2dq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vcvtps2dq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvtps2dq_xmm_k1z_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vcvtps2dq_xmm_xmmm128
		} else {
			Code::EVEX_Vcvtps2dq_xmm_k1z_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2dq<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vcvtps2dq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvtps2dq_ymm_k1z_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vcvtps2dq_ymm_ymmm256
		} else {
			Code::EVEX_Vcvtps2dq_ymm_k1z_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2dq<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtps2dq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2dq_zmm_k1z_zmmm512b32_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2pd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtps2pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvtps2pd_xmm_xmmm64 } else { Code::EVEX_Vcvtps2pd_xmm_k1z_xmmm64b32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2pd<__AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtps2pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvtps2pd_ymm_xmmm128 } else { Code::EVEX_Vcvtps2pd_ymm_k1z_xmmm128b32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2pd<__AsmRegisterZmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtps2pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2pd_zmm_k1z_ymmm256b32_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2pd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vcvtps2pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvtps2pd_xmm_k1z_xmmm64b32
		} else if self.prefer_vex() {
			Code::VEX_Vcvtps2pd_xmm_xmmm64
		} else {
			Code::EVEX_Vcvtps2pd_xmm_k1z_xmmm64b32
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2pd<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vcvtps2pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvtps2pd_ymm_k1z_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vcvtps2pd_ymm_xmmm128
		} else {
			Code::EVEX_Vcvtps2pd_ymm_k1z_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2pd<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtps2pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2pd_zmm_k1z_ymmm256b32_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2ph<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vcvtps2ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvtps2ph_xmmm64_xmm_imm8 } else { Code::EVEX_Vcvtps2ph_xmmm64_k1z_xmm_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2ph<__AsmMemoryOperand, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vcvtps2ph(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvtps2ph_xmmm64_xmm_imm8 } else { Code::EVEX_Vcvtps2ph_xmmm64_k1z_xmm_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2ph<__AsmRegisterXmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vcvtps2ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvtps2ph_xmmm128_ymm_imm8 } else { Code::EVEX_Vcvtps2ph_xmmm128_k1z_ymm_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2ph<__AsmMemoryOperand, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vcvtps2ph(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvtps2ph_xmmm128_ymm_imm8 } else { Code::EVEX_Vcvtps2ph_xmmm128_k1z_ymm_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2ph<__AsmRegisterYmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vcvtps2ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtps2ph_ymmm256_k1z_zmm_imm8_sae, op0.register(), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2ph<__AsmMemoryOperand, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vcvtps2ph(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtps2ph_ymmm256_k1z_zmm_imm8_sae, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2ph<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vcvtps2ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvtps2ph_xmmm64_xmm_imm8 } else { Code::EVEX_Vcvtps2ph_xmmm64_k1z_xmm_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2ph<__AsmMemoryOperand, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vcvtps2ph(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvtps2ph_xmmm64_xmm_imm8 } else { Code::EVEX_Vcvtps2ph_xmmm64_k1z_xmm_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2ph<__AsmRegisterXmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vcvtps2ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvtps2ph_xmmm128_ymm_imm8 } else { Code::EVEX_Vcvtps2ph_xmmm128_k1z_ymm_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2ph<__AsmMemoryOperand, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vcvtps2ph(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvtps2ph_xmmm128_ymm_imm8 } else { Code::EVEX_Vcvtps2ph_xmmm128_k1z_ymm_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2ph<__AsmRegisterYmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vcvtps2ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtps2ph_ymmm256_k1z_zmm_imm8_sae, op0.register(), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2ph<__AsmMemoryOperand, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vcvtps2ph(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtps2ph_ymmm256_k1z_zmm_imm8_sae, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2phx<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtps2phx(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2phx_xmm_k1z_xmmm128b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2phx<__AsmRegisterXmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtps2phx(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2phx_xmm_k1z_ymmm256b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2phx<__AsmRegisterYmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtps2phx(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2phx_ymm_k1z_zmmm512b32_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2phx<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vcvtps2phx(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvtps2phx_xmm_k1z_ymmm256b32
		} else if op1.size() == MemoryOperandSize::Yword {
			Code::EVEX_Vcvtps2phx_xmm_k1z_ymmm256b32
		} else if op1.size() == MemoryOperandSize::Xword {
			Code::EVEX_Vcvtps2phx_xmm_k1z_xmmm128b32
		} else {
			return Err(IcedError::new("vcvtps2phx: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2phx<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtps2phx(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2phx_ymm_k1z_zmmm512b32_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2phxx<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtps2phxx(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2phx_xmm_k1z_xmmm128b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2phxy<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtps2phxy(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2phx_xmm_k1z_ymmm256b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2qq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtps2qq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2qq_xmm_k1z_xmmm64b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2qq<__AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtps2qq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2qq_ymm_k1z_xmmm128b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2qq<__AsmRegisterZmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtps2qq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2qq_zmm_k1z_ymmm256b32_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2qq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtps2qq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2qq_xmm_k1z_xmmm64b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2qq<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtps2qq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2qq_ymm_k1z_xmmm128b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2qq<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtps2qq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2qq_zmm_k1z_ymmm256b32_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2udq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtps2udq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2udq_xmm_k1z_xmmm128b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2udq<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtps2udq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2udq_ymm_k1z_ymmm256b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2udq<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtps2udq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2udq_zmm_k1z_zmmm512b32_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2udq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtps2udq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2udq_xmm_k1z_xmmm128b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2udq<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtps2udq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2udq_ymm_k1z_ymmm256b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2udq<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtps2udq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2udq_zmm_k1z_zmmm512b32_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2uqq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtps2uqq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2uqq_xmm_k1z_xmmm64b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2uqq<__AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtps2uqq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2uqq_ymm_k1z_xmmm128b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2uqq<__AsmRegisterZmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtps2uqq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2uqq_zmm_k1z_ymmm256b32_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2uqq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtps2uqq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2uqq_xmm_k1z_xmmm64b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2uqq<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtps2uqq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2uqq_ymm_k1z_xmmm128b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2uqq<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtps2uqq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2uqq_zmm_k1z_ymmm256b32_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtqq2pd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtqq2pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtqq2pd_xmm_k1z_xmmm128b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtqq2pd<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtqq2pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtqq2pd_ymm_k1z_ymmm256b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtqq2pd<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtqq2pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtqq2pd_zmm_k1z_zmmm512b64_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtqq2pd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtqq2pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtqq2pd_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtqq2pd<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtqq2pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtqq2pd_ymm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtqq2pd<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtqq2pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtqq2pd_zmm_k1z_zmmm512b64_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtqq2ph<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtqq2ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtqq2ph_xmm_k1z_xmmm128b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtqq2ph<__AsmRegisterXmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtqq2ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtqq2ph_xmm_k1z_ymmm256b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtqq2ph<__AsmRegisterXmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtqq2ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtqq2ph_xmm_k1z_zmmm512b64_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtqq2ph<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vcvtqq2ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvtqq2ph_xmm_k1z_zmmm512b64_er
		} else if op1.size() == MemoryOperandSize::Zword {
			Code::EVEX_Vcvtqq2ph_xmm_k1z_zmmm512b64_er
		} else if op1.size() == MemoryOperandSize::Yword {
			Code::EVEX_Vcvtqq2ph_xmm_k1z_ymmm256b64
		} else if op1.size() == MemoryOperandSize::Xword {
			Code::EVEX_Vcvtqq2ph_xmm_k1z_xmmm128b64
		} else {
			return Err(IcedError::new("vcvtqq2ph: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtqq2phx<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtqq2phx(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtqq2ph_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtqq2phy<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtqq2phy(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtqq2ph_xmm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtqq2phz<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtqq2phz(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtqq2ph_xmm_k1z_zmmm512b64_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtqq2ps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtqq2ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtqq2ps_xmm_k1z_xmmm128b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtqq2ps<__AsmRegisterXmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtqq2ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtqq2ps_xmm_k1z_ymmm256b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtqq2ps<__AsmRegisterYmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtqq2ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtqq2ps_ymm_k1z_zmmm512b64_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtqq2ps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vcvtqq2ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvtqq2ps_xmm_k1z_ymmm256b64
		} else if op1.size() == MemoryOperandSize::Yword {
			Code::EVEX_Vcvtqq2ps_xmm_k1z_ymmm256b64
		} else if op1.size() == MemoryOperandSize::Xword {
			Code::EVEX_Vcvtqq2ps_xmm_k1z_xmmm128b64
		} else {
			return Err(IcedError::new("vcvtqq2ps: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtqq2ps<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtqq2ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtqq2ps_ymm_k1z_zmmm512b64_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtqq2psx<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtqq2psx(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtqq2ps_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtqq2psy<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtqq2psy(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtqq2ps_xmm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsd2sh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtsd2sh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtsd2sh_xmm_k1z_xmm_xmmm64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsd2sh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtsd2sh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtsd2sh_xmm_k1z_xmm_xmmm64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsd2si<__AsmRegister32, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtsd2si(&mut self, op0: __AsmRegister32, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvtsd2si_r32_xmmm64 } else { Code::EVEX_Vcvtsd2si_r32_xmmm64_er };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsd2si<__AsmRegister64, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtsd2si(&mut self, op0: __AsmRegister64, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvtsd2si_r64_xmmm64 } else { Code::EVEX_Vcvtsd2si_r64_xmmm64_er };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsd2si<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtsd2si(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvtsd2si_r32_xmmm64 } else { Code::EVEX_Vcvtsd2si_r32_xmmm64_er };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsd2si<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtsd2si(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvtsd2si_r64_xmmm64 } else { Code::EVEX_Vcvtsd2si_r64_xmmm64_er };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsd2ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtsd2ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvtsd2ss_xmm_xmm_xmmm64 } else { Code::EVEX_Vcvtsd2ss_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsd2ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtsd2ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvtsd2ss_xmm_xmm_xmmm64 } else { Code::EVEX_Vcvtsd2ss_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsd2usi<__AsmRegister32, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtsd2usi(&mut self, op0: __AsmRegister32, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtsd2usi_r32_xmmm64_er, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsd2usi<__AsmRegister64, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtsd2usi(&mut self, op0: __AsmRegister64, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtsd2usi_r64_xmmm64_er, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsd2usi<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtsd2usi(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtsd2usi_r32_xmmm64_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsd2usi<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtsd2usi(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtsd2usi_r64_xmmm64_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsh2sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtsh2sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtsh2sd_xmm_k1z_xmm_xmmm16_sae, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsh2sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtsh2sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtsh2sd_xmm_k1z_xmm_xmmm16_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsh2si<__AsmRegister32, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtsh2si(&mut self, op0: __AsmRegister32, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtsh2si_r32_xmmm16_er, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsh2si<__AsmRegister64, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtsh2si(&mut self, op0: __AsmRegister64, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtsh2si_r64_xmmm16_er, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsh2si<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtsh2si(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtsh2si_r32_xmmm16_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsh2si<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtsh2si(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtsh2si_r64_xmmm16_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsh2ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtsh2ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtsh2ss_xmm_k1z_xmm_xmmm16_sae, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsh2ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtsh2ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtsh2ss_xmm_k1z_xmm_xmmm16_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsh2usi<__AsmRegister32, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtsh2usi(&mut self, op0: __AsmRegister32, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtsh2usi_r32_xmmm16_er, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsh2usi<__AsmRegister64, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtsh2usi(&mut self, op0: __AsmRegister64, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtsh2usi_r64_xmmm16_er, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsh2usi<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtsh2usi(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtsh2usi_r32_xmmm16_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsh2usi<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtsh2usi(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtsh2usi_r64_xmmm16_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsi2sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn vcvtsi2sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegister32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvtsi2sd_xmm_xmm_rm32 } else { Code::EVEX_Vcvtsi2sd_xmm_xmm_rm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsi2sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn vcvtsi2sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegister64) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvtsi2sd_xmm_xmm_rm64 } else { Code::EVEX_Vcvtsi2sd_xmm_xmm_rm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsi2sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vcvtsi2sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.size() == MemoryOperandSize::Qword {
			if self.prefer_vex() { Code::VEX_Vcvtsi2sd_xmm_xmm_rm64 } else { Code::EVEX_Vcvtsi2sd_xmm_xmm_rm64_er }
		} else if op2.size() == MemoryOperandSize::Dword {
			if self.prefer_vex() { Code::VEX_Vcvtsi2sd_xmm_xmm_rm32 } else { Code::EVEX_Vcvtsi2sd_xmm_xmm_rm32_er }
		} else {
			return Err(IcedError::new("vcvtsi2sd: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsi2sh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn vcvtsi2sh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtsi2sh_xmm_xmm_rm32_er, op0.register(), op1.register(), op2.register())?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsi2sh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn vcvtsi2sh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtsi2sh_xmm_xmm_rm64_er, op0.register(), op1.register(), op2.register())?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsi2sh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vcvtsi2sh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.size() == MemoryOperandSize::Qword {
			Code::EVEX_Vcvtsi2sh_xmm_xmm_rm64_er
		} else if op2.size() == MemoryOperandSize::Dword {
			Code::EVEX_Vcvtsi2sh_xmm_xmm_rm32_er
		} else {
			return Err(IcedError::new("vcvtsi2sh: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsi2ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn vcvtsi2ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegister32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvtsi2ss_xmm_xmm_rm32 } else { Code::EVEX_Vcvtsi2ss_xmm_xmm_rm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsi2ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn vcvtsi2ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegister64) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvtsi2ss_xmm_xmm_rm64 } else { Code::EVEX_Vcvtsi2ss_xmm_xmm_rm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsi2ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vcvtsi2ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.size() == MemoryOperandSize::Qword {
			if self.prefer_vex() { Code::VEX_Vcvtsi2ss_xmm_xmm_rm64 } else { Code::EVEX_Vcvtsi2ss_xmm_xmm_rm64_er }
		} else if op2.size() == MemoryOperandSize::Dword {
			if self.prefer_vex() { Code::VEX_Vcvtsi2ss_xmm_xmm_rm32 } else { Code::EVEX_Vcvtsi2ss_xmm_xmm_rm32_er }
		} else {
			return Err(IcedError::new("vcvtsi2ss: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtss2sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtss2sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvtss2sd_xmm_xmm_xmmm32 } else { Code::EVEX_Vcvtss2sd_xmm_k1z_xmm_xmmm32_sae };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtss2sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtss2sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvtss2sd_xmm_xmm_xmmm32 } else { Code::EVEX_Vcvtss2sd_xmm_k1z_xmm_xmmm32_sae };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtss2sh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtss2sh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtss2sh_xmm_k1z_xmm_xmmm32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtss2sh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtss2sh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtss2sh_xmm_k1z_xmm_xmmm32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtss2si<__AsmRegister32, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtss2si(&mut self, op0: __AsmRegister32, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvtss2si_r32_xmmm32 } else { Code::EVEX_Vcvtss2si_r32_xmmm32_er };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtss2si<__AsmRegister64, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtss2si(&mut self, op0: __AsmRegister64, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvtss2si_r64_xmmm32 } else { Code::EVEX_Vcvtss2si_r64_xmmm32_er };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtss2si<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtss2si(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvtss2si_r32_xmmm32 } else { Code::EVEX_Vcvtss2si_r32_xmmm32_er };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtss2si<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtss2si(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvtss2si_r64_xmmm32 } else { Code::EVEX_Vcvtss2si_r64_xmmm32_er };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtss2usi<__AsmRegister32, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtss2usi(&mut self, op0: __AsmRegister32, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtss2usi_r32_xmmm32_er, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtss2usi<__AsmRegister64, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtss2usi(&mut self, op0: __AsmRegister64, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtss2usi_r64_xmmm32_er, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtss2usi<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtss2usi(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtss2usi_r32_xmmm32_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtss2usi<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtss2usi(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtss2usi_r64_xmmm32_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2dq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttpd2dq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvttpd2dq_xmm_xmmm128 } else { Code::EVEX_Vcvttpd2dq_xmm_k1z_xmmm128b64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2dq<__AsmRegisterXmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvttpd2dq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvttpd2dq_xmm_ymmm256 } else { Code::EVEX_Vcvttpd2dq_xmm_k1z_ymmm256b64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2dq<__AsmRegisterYmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvttpd2dq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2dq_ymm_k1z_zmmm512b64_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2dq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vcvttpd2dq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvttpd2dq_xmm_k1z_ymmm256b64
		} else if op1.size() == MemoryOperandSize::Yword {
			if self.prefer_vex() { Code::VEX_Vcvttpd2dq_xmm_ymmm256 } else { Code::EVEX_Vcvttpd2dq_xmm_k1z_ymmm256b64 }
		} else if op1.size() == MemoryOperandSize::Xword {
			if self.prefer_vex() { Code::VEX_Vcvttpd2dq_xmm_xmmm128 } else { Code::EVEX_Vcvttpd2dq_xmm_k1z_xmmm128b64 }
		} else {
			return Err(IcedError::new("vcvttpd2dq: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2dq<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttpd2dq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2dq_ymm_k1z_zmmm512b64_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2dqx<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttpd2dqx(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2dq_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2dqy<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttpd2dqy(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2dq_xmm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2qq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttpd2qq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2qq_xmm_k1z_xmmm128b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2qq<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvttpd2qq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2qq_ymm_k1z_ymmm256b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2qq<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvttpd2qq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2qq_zmm_k1z_zmmm512b64_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2qq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttpd2qq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2qq_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2qq<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttpd2qq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2qq_ymm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2qq<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttpd2qq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2qq_zmm_k1z_zmmm512b64_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2udq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttpd2udq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2udq_xmm_k1z_xmmm128b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2udq<__AsmRegisterXmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvttpd2udq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2udq_xmm_k1z_ymmm256b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2udq<__AsmRegisterYmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvttpd2udq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2udq_ymm_k1z_zmmm512b64_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2udq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vcvttpd2udq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvttpd2udq_xmm_k1z_ymmm256b64
		} else if op1.size() == MemoryOperandSize::Yword {
			Code::EVEX_Vcvttpd2udq_xmm_k1z_ymmm256b64
		} else if op1.size() == MemoryOperandSize::Xword {
			Code::EVEX_Vcvttpd2udq_xmm_k1z_xmmm128b64
		} else {
			return Err(IcedError::new("vcvttpd2udq: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2udq<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttpd2udq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2udq_ymm_k1z_zmmm512b64_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2udqx<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttpd2udqx(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2udq_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2udqy<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttpd2udqy(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2udq_xmm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2uqq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttpd2uqq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2uqq_xmm_k1z_xmmm128b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2uqq<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvttpd2uqq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2uqq_ymm_k1z_ymmm256b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2uqq<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvttpd2uqq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2uqq_zmm_k1z_zmmm512b64_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2uqq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttpd2uqq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2uqq_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2uqq<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttpd2uqq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2uqq_ymm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2uqq<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttpd2uqq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2uqq_zmm_k1z_zmmm512b64_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2dq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttph2dq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2dq_xmm_k1z_xmmm64b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2dq<__AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttph2dq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2dq_ymm_k1z_xmmm128b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2dq<__AsmRegisterZmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvttph2dq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2dq_zmm_k1z_ymmm256b16_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2dq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttph2dq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2dq_xmm_k1z_xmmm64b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2dq<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttph2dq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2dq_ymm_k1z_xmmm128b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2dq<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttph2dq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2dq_zmm_k1z_ymmm256b16_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2qq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttph2qq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2qq_xmm_k1z_xmmm32b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2qq<__AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttph2qq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2qq_ymm_k1z_xmmm64b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2qq<__AsmRegisterZmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttph2qq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2qq_zmm_k1z_xmmm128b16_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2qq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttph2qq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2qq_xmm_k1z_xmmm32b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2qq<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttph2qq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2qq_ymm_k1z_xmmm64b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2qq<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttph2qq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2qq_zmm_k1z_xmmm128b16_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2udq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttph2udq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2udq_xmm_k1z_xmmm64b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2udq<__AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttph2udq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2udq_ymm_k1z_xmmm128b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2udq<__AsmRegisterZmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvttph2udq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2udq_zmm_k1z_ymmm256b16_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2udq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttph2udq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2udq_xmm_k1z_xmmm64b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2udq<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttph2udq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2udq_ymm_k1z_xmmm128b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2udq<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttph2udq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2udq_zmm_k1z_ymmm256b16_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2uqq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttph2uqq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2uqq_xmm_k1z_xmmm32b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2uqq<__AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttph2uqq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2uqq_ymm_k1z_xmmm64b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2uqq<__AsmRegisterZmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttph2uqq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2uqq_zmm_k1z_xmmm128b16_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2uqq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttph2uqq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2uqq_xmm_k1z_xmmm32b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2uqq<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttph2uqq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2uqq_ymm_k1z_xmmm64b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2uqq<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttph2uqq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2uqq_zmm_k1z_xmmm128b16_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2uw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttph2uw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2uw_xmm_k1z_xmmm128b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2uw<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvttph2uw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2uw_ymm_k1z_ymmm256b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2uw<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvttph2uw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2uw_zmm_k1z_zmmm512b16_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2uw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttph2uw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2uw_xmm_k1z_xmmm128b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2uw<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttph2uw(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2uw_ymm_k1z_ymmm256b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2uw<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttph2uw(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2uw_zmm_k1z_zmmm512b16_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2w<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttph2w(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2w_xmm_k1z_xmmm128b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2w<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvttph2w(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2w_ymm_k1z_ymmm256b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2w<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvttph2w(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2w_zmm_k1z_zmmm512b16_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2w<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttph2w(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2w_xmm_k1z_xmmm128b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2w<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttph2w(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2w_ymm_k1z_ymmm256b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2w<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttph2w(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2w_zmm_k1z_zmmm512b16_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2dq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttps2dq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvttps2dq_xmm_xmmm128 } else { Code::EVEX_Vcvttps2dq_xmm_k1z_xmmm128b32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2dq<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvttps2dq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvttps2dq_ymm_ymmm256 } else { Code::EVEX_Vcvttps2dq_ymm_k1z_ymmm256b32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2dq<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvttps2dq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttps2dq_zmm_k1z_zmmm512b32_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2dq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vcvttps2dq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvttps2dq_xmm_k1z_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vcvttps2dq_xmm_xmmm128
		} else {
			Code::EVEX_Vcvttps2dq_xmm_k1z_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2dq<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vcvttps2dq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvttps2dq_ymm_k1z_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vcvttps2dq_ymm_ymmm256
		} else {
			Code::EVEX_Vcvttps2dq_ymm_k1z_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2dq<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttps2dq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttps2dq_zmm_k1z_zmmm512b32_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2qq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttps2qq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttps2qq_xmm_k1z_xmmm64b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2qq<__AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttps2qq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttps2qq_ymm_k1z_xmmm128b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2qq<__AsmRegisterZmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvttps2qq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttps2qq_zmm_k1z_ymmm256b32_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2qq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttps2qq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttps2qq_xmm_k1z_xmmm64b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2qq<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttps2qq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttps2qq_ymm_k1z_xmmm128b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2qq<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttps2qq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttps2qq_zmm_k1z_ymmm256b32_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2udq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttps2udq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttps2udq_xmm_k1z_xmmm128b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2udq<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvttps2udq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttps2udq_ymm_k1z_ymmm256b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2udq<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvttps2udq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttps2udq_zmm_k1z_zmmm512b32_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2udq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttps2udq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttps2udq_xmm_k1z_xmmm128b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2udq<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttps2udq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttps2udq_ymm_k1z_ymmm256b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2udq<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttps2udq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttps2udq_zmm_k1z_zmmm512b32_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2uqq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttps2uqq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttps2uqq_xmm_k1z_xmmm64b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2uqq<__AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttps2uqq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttps2uqq_ymm_k1z_xmmm128b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2uqq<__AsmRegisterZmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvttps2uqq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttps2uqq_zmm_k1z_ymmm256b32_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2uqq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttps2uqq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttps2uqq_xmm_k1z_xmmm64b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2uqq<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttps2uqq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttps2uqq_ymm_k1z_xmmm128b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2uqq<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttps2uqq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttps2uqq_zmm_k1z_ymmm256b32_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttsd2si<__AsmRegister32, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttsd2si(&mut self, op0: __AsmRegister32, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvttsd2si_r32_xmmm64 } else { Code::EVEX_Vcvttsd2si_r32_xmmm64_sae };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttsd2si<__AsmRegister64, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttsd2si(&mut self, op0: __AsmRegister64, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvttsd2si_r64_xmmm64 } else { Code::EVEX_Vcvttsd2si_r64_xmmm64_sae };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttsd2si<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttsd2si(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvttsd2si_r32_xmmm64 } else { Code::EVEX_Vcvttsd2si_r32_xmmm64_sae };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttsd2si<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttsd2si(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvttsd2si_r64_xmmm64 } else { Code::EVEX_Vcvttsd2si_r64_xmmm64_sae };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttsd2usi<__AsmRegister32, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttsd2usi(&mut self, op0: __AsmRegister32, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttsd2usi_r32_xmmm64_sae, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttsd2usi<__AsmRegister64, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttsd2usi(&mut self, op0: __AsmRegister64, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttsd2usi_r64_xmmm64_sae, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttsd2usi<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttsd2usi(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttsd2usi_r32_xmmm64_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttsd2usi<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttsd2usi(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttsd2usi_r64_xmmm64_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttsh2si<__AsmRegister32, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttsh2si(&mut self, op0: __AsmRegister32, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttsh2si_r32_xmmm16_sae, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttsh2si<__AsmRegister64, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttsh2si(&mut self, op0: __AsmRegister64, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttsh2si_r64_xmmm16_sae, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttsh2si<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttsh2si(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttsh2si_r32_xmmm16_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttsh2si<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttsh2si(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttsh2si_r64_xmmm16_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttsh2usi<__AsmRegister32, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttsh2usi(&mut self, op0: __AsmRegister32, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttsh2usi_r32_xmmm16_sae, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttsh2usi<__AsmRegister64, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttsh2usi(&mut self, op0: __AsmRegister64, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttsh2usi_r64_xmmm16_sae, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttsh2usi<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttsh2usi(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttsh2usi_r32_xmmm16_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttsh2usi<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttsh2usi(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttsh2usi_r64_xmmm16_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttss2si<__AsmRegister32, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttss2si(&mut self, op0: __AsmRegister32, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvttss2si_r32_xmmm32 } else { Code::EVEX_Vcvttss2si_r32_xmmm32_sae };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttss2si<__AsmRegister64, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttss2si(&mut self, op0: __AsmRegister64, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvttss2si_r64_xmmm32 } else { Code::EVEX_Vcvttss2si_r64_xmmm32_sae };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttss2si<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttss2si(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvttss2si_r32_xmmm32 } else { Code::EVEX_Vcvttss2si_r32_xmmm32_sae };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttss2si<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttss2si(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vcvttss2si_r64_xmmm32 } else { Code::EVEX_Vcvttss2si_r64_xmmm32_sae };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttss2usi<__AsmRegister32, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttss2usi(&mut self, op0: __AsmRegister32, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttss2usi_r32_xmmm32_sae, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttss2usi<__AsmRegister64, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttss2usi(&mut self, op0: __AsmRegister64, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttss2usi_r64_xmmm32_sae, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttss2usi<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttss2usi(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttss2usi_r32_xmmm32_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttss2usi<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttss2usi(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttss2usi_r64_xmmm32_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtudq2pd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtudq2pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtudq2pd_xmm_k1z_xmmm64b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtudq2pd<__AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtudq2pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtudq2pd_ymm_k1z_xmmm128b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtudq2pd<__AsmRegisterZmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtudq2pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtudq2pd_zmm_k1z_ymmm256b32_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtudq2pd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtudq2pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtudq2pd_xmm_k1z_xmmm64b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtudq2pd<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtudq2pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtudq2pd_ymm_k1z_xmmm128b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtudq2pd<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtudq2pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtudq2pd_zmm_k1z_ymmm256b32_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtudq2ph<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtudq2ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtudq2ph_xmm_k1z_xmmm128b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtudq2ph<__AsmRegisterXmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtudq2ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtudq2ph_xmm_k1z_ymmm256b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtudq2ph<__AsmRegisterYmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtudq2ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtudq2ph_ymm_k1z_zmmm512b32_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtudq2ph<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vcvtudq2ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvtudq2ph_xmm_k1z_ymmm256b32
		} else if op1.size() == MemoryOperandSize::Yword {
			Code::EVEX_Vcvtudq2ph_xmm_k1z_ymmm256b32
		} else if op1.size() == MemoryOperandSize::Xword {
			Code::EVEX_Vcvtudq2ph_xmm_k1z_xmmm128b32
		} else {
			return Err(IcedError::new("vcvtudq2ph: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtudq2ph<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtudq2ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtudq2ph_ymm_k1z_zmmm512b32_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtudq2phx<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtudq2phx(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtudq2ph_xmm_k1z_xmmm128b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtudq2phy<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtudq2phy(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtudq2ph_xmm_k1z_ymmm256b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtudq2ps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtudq2ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtudq2ps_xmm_k1z_xmmm128b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtudq2ps<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtudq2ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtudq2ps_ymm_k1z_ymmm256b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtudq2ps<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtudq2ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtudq2ps_zmm_k1z_zmmm512b32_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtudq2ps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtudq2ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtudq2ps_xmm_k1z_xmmm128b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtudq2ps<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtudq2ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtudq2ps_ymm_k1z_ymmm256b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtudq2ps<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtudq2ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtudq2ps_zmm_k1z_zmmm512b32_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuqq2pd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtuqq2pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuqq2pd_xmm_k1z_xmmm128b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuqq2pd<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtuqq2pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuqq2pd_ymm_k1z_ymmm256b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuqq2pd<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtuqq2pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuqq2pd_zmm_k1z_zmmm512b64_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuqq2pd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtuqq2pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuqq2pd_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuqq2pd<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtuqq2pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuqq2pd_ymm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuqq2pd<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtuqq2pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuqq2pd_zmm_k1z_zmmm512b64_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuqq2ph<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtuqq2ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuqq2ph_xmm_k1z_xmmm128b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuqq2ph<__AsmRegisterXmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtuqq2ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuqq2ph_xmm_k1z_ymmm256b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuqq2ph<__AsmRegisterXmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtuqq2ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuqq2ph_xmm_k1z_zmmm512b64_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuqq2ph<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vcvtuqq2ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvtuqq2ph_xmm_k1z_zmmm512b64_er
		} else if op1.size() == MemoryOperandSize::Zword {
			Code::EVEX_Vcvtuqq2ph_xmm_k1z_zmmm512b64_er
		} else if op1.size() == MemoryOperandSize::Yword {
			Code::EVEX_Vcvtuqq2ph_xmm_k1z_ymmm256b64
		} else if op1.size() == MemoryOperandSize::Xword {
			Code::EVEX_Vcvtuqq2ph_xmm_k1z_xmmm128b64
		} else {
			return Err(IcedError::new("vcvtuqq2ph: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuqq2phx<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtuqq2phx(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuqq2ph_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuqq2phy<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtuqq2phy(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuqq2ph_xmm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuqq2phz<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtuqq2phz(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuqq2ph_xmm_k1z_zmmm512b64_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuqq2ps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtuqq2ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuqq2ps_xmm_k1z_xmmm128b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuqq2ps<__AsmRegisterXmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtuqq2ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuqq2ps_xmm_k1z_ymmm256b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuqq2ps<__AsmRegisterYmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtuqq2ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuqq2ps_ymm_k1z_zmmm512b64_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuqq2ps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vcvtuqq2ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvtuqq2ps_xmm_k1z_ymmm256b64
		} else if op1.size() == MemoryOperandSize::Yword {
			Code::EVEX_Vcvtuqq2ps_xmm_k1z_ymmm256b64
		} else if op1.size() == MemoryOperandSize::Xword {
			Code::EVEX_Vcvtuqq2ps_xmm_k1z_xmmm128b64
		} else {
			return Err(IcedError::new("vcvtuqq2ps: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuqq2ps<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtuqq2ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuqq2ps_ymm_k1z_zmmm512b64_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuqq2psx<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtuqq2psx(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuqq2ps_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuqq2psy<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtuqq2psy(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuqq2ps_xmm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtusi2sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn vcvtusi2sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtusi2sd_xmm_xmm_rm32_er, op0.register(), op1.register(), op2.register())?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtusi2sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn vcvtusi2sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtusi2sd_xmm_xmm_rm64_er, op0.register(), op1.register(), op2.register())?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtusi2sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vcvtusi2sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.size() == MemoryOperandSize::Qword {
			Code::EVEX_Vcvtusi2sd_xmm_xmm_rm64_er
		} else if op2.size() == MemoryOperandSize::Dword {
			Code::EVEX_Vcvtusi2sd_xmm_xmm_rm32_er
		} else {
			return Err(IcedError::new("vcvtusi2sd: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtusi2sh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn vcvtusi2sh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtusi2sh_xmm_xmm_rm32_er, op0.register(), op1.register(), op2.register())?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtusi2sh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn vcvtusi2sh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtusi2sh_xmm_xmm_rm64_er, op0.register(), op1.register(), op2.register())?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtusi2sh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vcvtusi2sh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.size() == MemoryOperandSize::Qword {
			Code::EVEX_Vcvtusi2sh_xmm_xmm_rm64_er
		} else if op2.size() == MemoryOperandSize::Dword {
			Code::EVEX_Vcvtusi2sh_xmm_xmm_rm32_er
		} else {
			return Err(IcedError::new("vcvtusi2sh: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtusi2ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn vcvtusi2ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtusi2ss_xmm_xmm_rm32_er, op0.register(), op1.register(), op2.register())?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtusi2ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn vcvtusi2ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtusi2ss_xmm_xmm_rm64_er, op0.register(), op1.register(), op2.register())?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtusi2ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vcvtusi2ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.size() == MemoryOperandSize::Qword {
			Code::EVEX_Vcvtusi2ss_xmm_xmm_rm64_er
		} else if op2.size() == MemoryOperandSize::Dword {
			Code::EVEX_Vcvtusi2ss_xmm_xmm_rm32_er
		} else {
			return Err(IcedError::new("vcvtusi2ss: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuw2ph<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtuw2ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuw2ph_xmm_k1z_xmmm128b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuw2ph<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtuw2ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuw2ph_ymm_k1z_ymmm256b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuw2ph<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtuw2ph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuw2ph_zmm_k1z_zmmm512b16_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuw2ph<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtuw2ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuw2ph_xmm_k1z_xmmm128b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuw2ph<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtuw2ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuw2ph_ymm_k1z_ymmm256b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuw2ph<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtuw2ph(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuw2ph_zmm_k1z_zmmm512b16_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtw2ph<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtw2ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtw2ph_xmm_k1z_xmmm128b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtw2ph<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtw2ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtw2ph_ymm_k1z_ymmm256b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtw2ph<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtw2ph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtw2ph_zmm_k1z_zmmm512b16_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtw2ph<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtw2ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtw2ph_xmm_k1z_xmmm128b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtw2ph<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtw2ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtw2ph_ymm_k1z_ymmm256b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtw2ph<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtw2ph(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtw2ph_zmm_k1z_zmmm512b16_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdbpsadbw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vdbpsadbw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vdbpsadbw_xmm_k1z_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdbpsadbw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vdbpsadbw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vdbpsadbw_ymm_k1z_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdbpsadbw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vdbpsadbw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vdbpsadbw_zmm_k1z_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdbpsadbw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vdbpsadbw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vdbpsadbw_xmm_k1z_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdbpsadbw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vdbpsadbw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vdbpsadbw_ymm_k1z_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdbpsadbw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vdbpsadbw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vdbpsadbw_zmm_k1z_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdbpsadbw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vdbpsadbw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vdbpsadbw_xmm_k1z_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdbpsadbw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vdbpsadbw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vdbpsadbw_ymm_k1z_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdbpsadbw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vdbpsadbw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vdbpsadbw_zmm_k1z_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdbpsadbw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vdbpsadbw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vdbpsadbw_xmm_k1z_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdbpsadbw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vdbpsadbw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vdbpsadbw_ymm_k1z_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdbpsadbw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vdbpsadbw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vdbpsadbw_zmm_k1z_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdivpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vdivpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vdivpd_xmm_xmm_xmmm128 } else { Code::EVEX_Vdivpd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdivpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vdivpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vdivpd_ymm_ymm_ymmm256 } else { Code::EVEX_Vdivpd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdivpd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vdivpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vdivpd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdivpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vdivpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vdivpd_xmm_k1z_xmm_xmmm128b64
		} else if self.prefer_vex() {
			Code::VEX_Vdivpd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vdivpd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdivpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vdivpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vdivpd_ymm_k1z_ymm_ymmm256b64
		} else if self.prefer_vex() {
			Code::VEX_Vdivpd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vdivpd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdivpd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vdivpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vdivpd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdivph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vdivph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vdivph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdivph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vdivph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vdivph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdivph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vdivph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vdivph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdivph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vdivph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vdivph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdivph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vdivph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vdivph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdivph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vdivph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vdivph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdivps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vdivps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vdivps_xmm_xmm_xmmm128 } else { Code::EVEX_Vdivps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdivps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vdivps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vdivps_ymm_ymm_ymmm256 } else { Code::EVEX_Vdivps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdivps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vdivps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vdivps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdivps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vdivps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vdivps_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vdivps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vdivps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdivps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vdivps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vdivps_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vdivps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vdivps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdivps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vdivps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vdivps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdivsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vdivsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vdivsd_xmm_xmm_xmmm64 } else { Code::EVEX_Vdivsd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdivsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vdivsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vdivsd_xmm_xmm_xmmm64 } else { Code::EVEX_Vdivsd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdivsh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vdivsh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vdivsh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdivsh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vdivsh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vdivsh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdivss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vdivss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vdivss_xmm_xmm_xmmm32 } else { Code::EVEX_Vdivss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdivss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vdivss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vdivss_xmm_xmm_xmmm32 } else { Code::EVEX_Vdivss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdpbf16ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vdpbf16ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vdpbf16ps_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdpbf16ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vdpbf16ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vdpbf16ps_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdpbf16ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vdpbf16ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vdpbf16ps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdpbf16ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vdpbf16ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vdpbf16ps_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdpbf16ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vdpbf16ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vdpbf16ps_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdpbf16ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vdpbf16ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vdpbf16ps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vdppd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vdppd_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVdppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vdppd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vdppd_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVdppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vdppd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vdppd_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVdppd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vdppd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vdppd_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVdpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vdpps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vdpps_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVdpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vdpps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vdpps_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVdpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vdpps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vdpps_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVdpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vdpps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vdpps_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVdpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vdpps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vdpps_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVdpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vdpps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vdpps_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVdpps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vdpps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vdpps_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVdpps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vdpps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vdpps_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVerr<__AsmRegister16> for CodeAssembler {
	#[inline]
	fn verr(&mut self, op0: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Verr_rm16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVerr<__AsmRegister32> for CodeAssembler {
	#[inline]
	fn verr(&mut self, op0: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Verr_r32m16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVerr<__AsmRegister64> for CodeAssembler {
	#[inline]
	fn verr(&mut self, op0: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Verr_r64m16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVerr<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn verr(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Verr_r32m16 } else { Code::Verr_rm16 };
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVerw<__AsmRegister16> for CodeAssembler {
	#[inline]
	fn verw(&mut self, op0: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Verw_rm16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVerw<__AsmRegister32> for CodeAssembler {
	#[inline]
	fn verw(&mut self, op0: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Verw_r32m16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVerw<__AsmRegister64> for CodeAssembler {
	#[inline]
	fn verw(&mut self, op0: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Verw_r64m16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVerw<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn verw(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Verw_r32m16 } else { Code::Verw_rm16 };
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVexp2pd<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vexp2pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vexp2pd_zmm_k1z_zmmm512b64_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVexp2pd<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vexp2pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vexp2pd_zmm_k1z_zmmm512b64_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVexp2ps<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vexp2ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vexp2ps_zmm_k1z_zmmm512b32_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVexp2ps<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vexp2ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vexp2ps_zmm_k1z_zmmm512b32_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVexpandpd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vexpandpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vexpandpd_xmm_k1z_xmmm128, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVexpandpd<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vexpandpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vexpandpd_ymm_k1z_ymmm256, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVexpandpd<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vexpandpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vexpandpd_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVexpandpd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vexpandpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vexpandpd_xmm_k1z_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVexpandpd<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vexpandpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vexpandpd_ymm_k1z_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVexpandpd<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vexpandpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vexpandpd_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVexpandps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vexpandps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vexpandps_xmm_k1z_xmmm128, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVexpandps<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vexpandps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vexpandps_ymm_k1z_ymmm256, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVexpandps<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vexpandps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vexpandps_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVexpandps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vexpandps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vexpandps_xmm_k1z_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVexpandps<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vexpandps(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vexpandps_ymm_k1z_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVexpandps<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vexpandps(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vexpandps_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf128<__AsmRegisterXmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vextractf128(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vextractf128_xmmm128_ymm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf128<__AsmMemoryOperand, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vextractf128(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vextractf128_xmmm128_ymm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf128<__AsmRegisterXmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vextractf128(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vextractf128_xmmm128_ymm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf128<__AsmMemoryOperand, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vextractf128(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vextractf128_xmmm128_ymm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf32x4<__AsmRegisterXmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vextractf32x4(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf32x4_xmmm128_k1z_ymm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf32x4<__AsmMemoryOperand, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vextractf32x4(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf32x4_xmmm128_k1z_ymm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf32x4<__AsmRegisterXmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vextractf32x4(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf32x4_xmmm128_k1z_zmm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf32x4<__AsmMemoryOperand, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vextractf32x4(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf32x4_xmmm128_k1z_zmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf32x4<__AsmRegisterXmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vextractf32x4(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf32x4_xmmm128_k1z_ymm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf32x4<__AsmMemoryOperand, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vextractf32x4(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf32x4_xmmm128_k1z_ymm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf32x4<__AsmRegisterXmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vextractf32x4(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf32x4_xmmm128_k1z_zmm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf32x4<__AsmMemoryOperand, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vextractf32x4(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf32x4_xmmm128_k1z_zmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf32x8<__AsmRegisterYmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vextractf32x8(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf32x8_ymmm256_k1z_zmm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf32x8<__AsmMemoryOperand, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vextractf32x8(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf32x8_ymmm256_k1z_zmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf32x8<__AsmRegisterYmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vextractf32x8(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf32x8_ymmm256_k1z_zmm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf32x8<__AsmMemoryOperand, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vextractf32x8(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf32x8_ymmm256_k1z_zmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf64x2<__AsmRegisterXmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vextractf64x2(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf64x2_xmmm128_k1z_ymm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf64x2<__AsmMemoryOperand, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vextractf64x2(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf64x2_xmmm128_k1z_ymm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf64x2<__AsmRegisterXmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vextractf64x2(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf64x2_xmmm128_k1z_zmm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf64x2<__AsmMemoryOperand, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vextractf64x2(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf64x2_xmmm128_k1z_zmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf64x2<__AsmRegisterXmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vextractf64x2(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf64x2_xmmm128_k1z_ymm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf64x2<__AsmMemoryOperand, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vextractf64x2(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf64x2_xmmm128_k1z_ymm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf64x2<__AsmRegisterXmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vextractf64x2(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf64x2_xmmm128_k1z_zmm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf64x2<__AsmMemoryOperand, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vextractf64x2(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf64x2_xmmm128_k1z_zmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf64x4<__AsmRegisterYmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vextractf64x4(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf64x4_ymmm256_k1z_zmm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf64x4<__AsmMemoryOperand, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vextractf64x4(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf64x4_ymmm256_k1z_zmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf64x4<__AsmRegisterYmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vextractf64x4(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf64x4_ymmm256_k1z_zmm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf64x4<__AsmMemoryOperand, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vextractf64x4(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf64x4_ymmm256_k1z_zmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti128<__AsmRegisterXmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vextracti128(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vextracti128_xmmm128_ymm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti128<__AsmMemoryOperand, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vextracti128(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vextracti128_xmmm128_ymm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti128<__AsmRegisterXmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vextracti128(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vextracti128_xmmm128_ymm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti128<__AsmMemoryOperand, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vextracti128(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vextracti128_xmmm128_ymm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti32x4<__AsmRegisterXmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vextracti32x4(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti32x4_xmmm128_k1z_ymm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti32x4<__AsmMemoryOperand, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vextracti32x4(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti32x4_xmmm128_k1z_ymm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti32x4<__AsmRegisterXmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vextracti32x4(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti32x4_xmmm128_k1z_zmm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti32x4<__AsmMemoryOperand, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vextracti32x4(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti32x4_xmmm128_k1z_zmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti32x4<__AsmRegisterXmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vextracti32x4(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti32x4_xmmm128_k1z_ymm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti32x4<__AsmMemoryOperand, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vextracti32x4(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti32x4_xmmm128_k1z_ymm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti32x4<__AsmRegisterXmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vextracti32x4(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti32x4_xmmm128_k1z_zmm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti32x4<__AsmMemoryOperand, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vextracti32x4(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti32x4_xmmm128_k1z_zmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti32x8<__AsmRegisterYmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vextracti32x8(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti32x8_ymmm256_k1z_zmm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti32x8<__AsmMemoryOperand, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vextracti32x8(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti32x8_ymmm256_k1z_zmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti32x8<__AsmRegisterYmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vextracti32x8(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti32x8_ymmm256_k1z_zmm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti32x8<__AsmMemoryOperand, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vextracti32x8(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti32x8_ymmm256_k1z_zmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti64x2<__AsmRegisterXmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vextracti64x2(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti64x2_xmmm128_k1z_ymm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti64x2<__AsmMemoryOperand, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vextracti64x2(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti64x2_xmmm128_k1z_ymm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti64x2<__AsmRegisterXmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vextracti64x2(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti64x2_xmmm128_k1z_zmm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti64x2<__AsmMemoryOperand, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vextracti64x2(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti64x2_xmmm128_k1z_zmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti64x2<__AsmRegisterXmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vextracti64x2(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti64x2_xmmm128_k1z_ymm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti64x2<__AsmMemoryOperand, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vextracti64x2(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti64x2_xmmm128_k1z_ymm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti64x2<__AsmRegisterXmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vextracti64x2(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti64x2_xmmm128_k1z_zmm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti64x2<__AsmMemoryOperand, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vextracti64x2(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti64x2_xmmm128_k1z_zmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti64x4<__AsmRegisterYmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vextracti64x4(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti64x4_ymmm256_k1z_zmm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti64x4<__AsmMemoryOperand, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vextracti64x4(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti64x4_ymmm256_k1z_zmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti64x4<__AsmRegisterYmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vextracti64x4(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti64x4_ymmm256_k1z_zmm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti64x4<__AsmMemoryOperand, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vextracti64x4(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti64x4_ymmm256_k1z_zmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractps<__AsmRegister32, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vextractps(&mut self, op0: __AsmRegister32, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vextractps_rm32_xmm_imm8 } else { Code::EVEX_Vextractps_rm32_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVextractps<__AsmRegister64, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vextractps(&mut self, op0: __AsmRegister64, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vextractps_r64m32_xmm_imm8 } else { Code::EVEX_Vextractps_r64m32_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVextractps<__AsmMemoryOperand, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vextractps(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vextractps_rm32_xmm_imm8 } else { Code::EVEX_Vextractps_rm32_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVextractps<__AsmRegister32, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vextractps(&mut self, op0: __AsmRegister32, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vextractps_rm32_xmm_imm8 } else { Code::EVEX_Vextractps_rm32_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVextractps<__AsmRegister64, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vextractps(&mut self, op0: __AsmRegister64, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vextractps_r64m32_xmm_imm8 } else { Code::EVEX_Vextractps_r64m32_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVextractps<__AsmMemoryOperand, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vextractps(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vextractps_rm32_xmm_imm8 } else { Code::EVEX_Vextractps_rm32_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfcmaddcph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfcmaddcph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfcmaddcph_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfcmaddcph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfcmaddcph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfcmaddcph_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfcmaddcph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfcmaddcph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfcmaddcph_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfcmaddcph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfcmaddcph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfcmaddcph_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfcmaddcph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfcmaddcph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfcmaddcph_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfcmaddcph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfcmaddcph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfcmaddcph_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfcmaddcsh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfcmaddcsh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfcmaddcsh_xmm_k1z_xmm_xmmm32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfcmaddcsh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfcmaddcsh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfcmaddcsh_xmm_k1z_xmm_xmmm32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfcmulcph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfcmulcph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfcmulcph_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfcmulcph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfcmulcph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfcmulcph_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfcmulcph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfcmulcph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfcmulcph_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfcmulcph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfcmulcph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfcmulcph_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfcmulcph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfcmulcph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfcmulcph_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfcmulcph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfcmulcph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfcmulcph_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfcmulcsh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfcmulcsh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfcmulcsh_xmm_k1z_xmm_xmmm32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfcmulcsh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfcmulcsh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfcmulcsh_xmm_k1z_xmm_xmmm32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vfixupimmpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmpd_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vfixupimmpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmpd_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmpd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vfixupimmpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmpd_zmm_k1z_zmm_zmmm512b64_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vfixupimmpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmpd_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vfixupimmpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmpd_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmpd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vfixupimmpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmpd_zmm_k1z_zmm_zmmm512b64_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vfixupimmpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmpd_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vfixupimmpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmpd_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmpd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vfixupimmpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmpd_zmm_k1z_zmm_zmmm512b64_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vfixupimmpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmpd_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vfixupimmpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmpd_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmpd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vfixupimmpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmpd_zmm_k1z_zmm_zmmm512b64_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vfixupimmps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmps_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vfixupimmps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmps_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vfixupimmps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmps_zmm_k1z_zmm_zmmm512b32_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vfixupimmps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmps_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vfixupimmps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmps_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vfixupimmps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmps_zmm_k1z_zmm_zmmm512b32_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vfixupimmps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmps_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vfixupimmps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmps_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vfixupimmps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmps_zmm_k1z_zmm_zmmm512b32_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vfixupimmps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmps_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vfixupimmps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmps_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vfixupimmps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmps_zmm_k1z_zmm_zmmm512b32_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vfixupimmsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmsd_xmm_k1z_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vfixupimmsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmsd_xmm_k1z_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vfixupimmsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmsd_xmm_k1z_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vfixupimmsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmsd_xmm_k1z_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vfixupimmss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmss_xmm_k1z_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vfixupimmss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmss_xmm_k1z_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vfixupimmss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmss_xmm_k1z_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vfixupimmss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmss_xmm_k1z_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmadd132pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmadd132pd_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmadd132pd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmadd132pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmadd132pd_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmadd132pd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132pd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmadd132pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd132pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmadd132pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmadd132pd_xmm_k1z_xmm_xmmm128b64
		} else if self.prefer_vex() {
			Code::VEX_Vfmadd132pd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmadd132pd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmadd132pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmadd132pd_ymm_k1z_ymm_ymmm256b64
		} else if self.prefer_vex() {
			Code::VEX_Vfmadd132pd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmadd132pd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132pd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd132pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd132pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132ph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmadd132ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd132ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132ph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmadd132ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd132ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132ph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmadd132ph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd132ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132ph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd132ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd132ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132ph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd132ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd132ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132ph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd132ph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd132ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmadd132ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmadd132ps_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmadd132ps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmadd132ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmadd132ps_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmadd132ps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmadd132ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd132ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmadd132ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmadd132ps_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vfmadd132ps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmadd132ps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmadd132ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmadd132ps_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vfmadd132ps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmadd132ps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd132ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd132ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmadd132sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmadd132sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfmadd132sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd132sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmadd132sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfmadd132sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132sh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmadd132sh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd132sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132sh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd132sh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd132sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmadd132ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmadd132ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfmadd132ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd132ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmadd132ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfmadd132ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmadd213pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmadd213pd_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmadd213pd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmadd213pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmadd213pd_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmadd213pd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213pd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmadd213pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd213pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmadd213pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmadd213pd_xmm_k1z_xmm_xmmm128b64
		} else if self.prefer_vex() {
			Code::VEX_Vfmadd213pd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmadd213pd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmadd213pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmadd213pd_ymm_k1z_ymm_ymmm256b64
		} else if self.prefer_vex() {
			Code::VEX_Vfmadd213pd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmadd213pd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213pd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd213pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd213pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213ph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmadd213ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd213ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213ph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmadd213ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd213ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213ph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmadd213ph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd213ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213ph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd213ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd213ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213ph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd213ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd213ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213ph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd213ph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd213ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmadd213ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmadd213ps_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmadd213ps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmadd213ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmadd213ps_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmadd213ps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmadd213ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd213ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmadd213ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmadd213ps_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vfmadd213ps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmadd213ps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmadd213ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmadd213ps_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vfmadd213ps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmadd213ps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd213ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd213ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmadd213sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmadd213sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfmadd213sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd213sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmadd213sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfmadd213sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213sh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmadd213sh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd213sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213sh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd213sh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd213sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmadd213ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmadd213ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfmadd213ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd213ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmadd213ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfmadd213ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmadd231pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmadd231pd_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmadd231pd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmadd231pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmadd231pd_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmadd231pd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231pd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmadd231pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd231pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmadd231pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmadd231pd_xmm_k1z_xmm_xmmm128b64
		} else if self.prefer_vex() {
			Code::VEX_Vfmadd231pd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmadd231pd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmadd231pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmadd231pd_ymm_k1z_ymm_ymmm256b64
		} else if self.prefer_vex() {
			Code::VEX_Vfmadd231pd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmadd231pd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231pd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd231pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd231pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231ph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmadd231ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd231ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231ph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmadd231ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd231ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231ph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmadd231ph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd231ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231ph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd231ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd231ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231ph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd231ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd231ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231ph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd231ph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd231ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmadd231ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmadd231ps_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmadd231ps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmadd231ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmadd231ps_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmadd231ps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmadd231ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd231ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmadd231ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmadd231ps_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vfmadd231ps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmadd231ps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmadd231ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmadd231ps_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vfmadd231ps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmadd231ps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd231ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd231ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmadd231sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmadd231sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfmadd231sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd231sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmadd231sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfmadd231sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231sh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmadd231sh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd231sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231sh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd231sh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd231sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmadd231ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmadd231ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfmadd231ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd231ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmadd231ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfmadd231ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddcph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddcph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddcph_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddcph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmaddcph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddcph_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddcph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmaddcph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddcph_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddcph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddcph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddcph_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddcph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddcph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddcph_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddcph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddcph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddcph_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddcsh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddcsh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddcsh_xmm_k1z_xmm_xmmm32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddcsh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddcsh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddcsh_xmm_k1z_xmm_xmmm32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddpd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddpd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmaddpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddpd_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmaddpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddpd_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddpd_xmm_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddpd_ymm_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddps_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddps_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmaddps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddps_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmaddps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddps_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddps_xmm_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddps_ymm_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddsd_xmm_xmm_xmmm64_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddsd_xmm_xmm_xmmm64_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddsd_xmm_xmm_xmm_xmmm64, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddss_xmm_xmm_xmmm32_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddss_xmm_xmm_xmmm32_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddss_xmm_xmm_xmm_xmmm32, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub132pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub132pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmaddsub132pd_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmaddsub132pd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub132pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub132pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmaddsub132pd_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmaddsub132pd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub132pd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub132pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub132pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub132pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmaddsub132pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmaddsub132pd_xmm_k1z_xmm_xmmm128b64
		} else if self.prefer_vex() {
			Code::VEX_Vfmaddsub132pd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmaddsub132pd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub132pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmaddsub132pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmaddsub132pd_ymm_k1z_ymm_ymmm256b64
		} else if self.prefer_vex() {
			Code::VEX_Vfmaddsub132pd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmaddsub132pd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub132pd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddsub132pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub132pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub132ph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub132ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub132ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub132ph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub132ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub132ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub132ph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub132ph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub132ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub132ph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddsub132ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub132ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub132ph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddsub132ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub132ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub132ph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddsub132ph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub132ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub132ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub132ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmaddsub132ps_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmaddsub132ps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub132ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub132ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmaddsub132ps_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmaddsub132ps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub132ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub132ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub132ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub132ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmaddsub132ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmaddsub132ps_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vfmaddsub132ps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmaddsub132ps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub132ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmaddsub132ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmaddsub132ps_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vfmaddsub132ps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmaddsub132ps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub132ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddsub132ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub132ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub213pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub213pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmaddsub213pd_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmaddsub213pd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub213pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub213pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmaddsub213pd_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmaddsub213pd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub213pd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub213pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub213pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub213pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmaddsub213pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmaddsub213pd_xmm_k1z_xmm_xmmm128b64
		} else if self.prefer_vex() {
			Code::VEX_Vfmaddsub213pd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmaddsub213pd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub213pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmaddsub213pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmaddsub213pd_ymm_k1z_ymm_ymmm256b64
		} else if self.prefer_vex() {
			Code::VEX_Vfmaddsub213pd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmaddsub213pd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub213pd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddsub213pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub213pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub213ph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub213ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub213ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub213ph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub213ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub213ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub213ph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub213ph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub213ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub213ph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddsub213ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub213ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub213ph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddsub213ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub213ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub213ph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddsub213ph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub213ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub213ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub213ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmaddsub213ps_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmaddsub213ps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub213ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub213ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmaddsub213ps_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmaddsub213ps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub213ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub213ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub213ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub213ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmaddsub213ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmaddsub213ps_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vfmaddsub213ps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmaddsub213ps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub213ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmaddsub213ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmaddsub213ps_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vfmaddsub213ps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmaddsub213ps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub213ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddsub213ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub213ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub231pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub231pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmaddsub231pd_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmaddsub231pd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub231pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub231pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmaddsub231pd_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmaddsub231pd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub231pd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub231pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub231pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub231pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmaddsub231pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmaddsub231pd_xmm_k1z_xmm_xmmm128b64
		} else if self.prefer_vex() {
			Code::VEX_Vfmaddsub231pd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmaddsub231pd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub231pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmaddsub231pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmaddsub231pd_ymm_k1z_ymm_ymmm256b64
		} else if self.prefer_vex() {
			Code::VEX_Vfmaddsub231pd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmaddsub231pd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub231pd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddsub231pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub231pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub231ph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub231ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub231ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub231ph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub231ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub231ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub231ph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub231ph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub231ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub231ph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddsub231ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub231ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub231ph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddsub231ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub231ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub231ph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddsub231ph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub231ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub231ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub231ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmaddsub231ps_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmaddsub231ps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub231ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub231ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmaddsub231ps_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmaddsub231ps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub231ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub231ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub231ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub231ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmaddsub231ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmaddsub231ps_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vfmaddsub231ps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmaddsub231ps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub231ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmaddsub231ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmaddsub231ps_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vfmaddsub231ps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmaddsub231ps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub231ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddsub231ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub231ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsubpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddsubpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddsubpd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsubpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddsubpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddsubpd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsubpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmaddsubpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddsubpd_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsubpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmaddsubpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddsubpd_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsubpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddsubpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddsubpd_xmm_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsubpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddsubpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddsubpd_ymm_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsubps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddsubps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddsubps_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsubps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddsubps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddsubps_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsubps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmaddsubps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddsubps_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsubps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmaddsubps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddsubps_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsubps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddsubps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddsubps_xmm_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsubps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddsubps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddsubps_ymm_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsub132pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmsub132pd_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmsub132pd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsub132pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmsub132pd_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmsub132pd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132pd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmsub132pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub132pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmsub132pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsub132pd_xmm_k1z_xmm_xmmm128b64
		} else if self.prefer_vex() {
			Code::VEX_Vfmsub132pd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmsub132pd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmsub132pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsub132pd_ymm_k1z_ymm_ymmm256b64
		} else if self.prefer_vex() {
			Code::VEX_Vfmsub132pd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmsub132pd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132pd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub132pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub132pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132ph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsub132ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub132ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132ph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsub132ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub132ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132ph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmsub132ph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub132ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132ph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub132ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub132ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132ph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub132ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub132ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132ph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub132ph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub132ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsub132ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmsub132ps_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmsub132ps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsub132ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmsub132ps_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmsub132ps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmsub132ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub132ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmsub132ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsub132ps_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vfmsub132ps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmsub132ps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmsub132ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsub132ps_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vfmsub132ps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmsub132ps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub132ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub132ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsub132sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmsub132sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfmsub132sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub132sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmsub132sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfmsub132sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132sh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsub132sh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub132sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132sh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub132sh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub132sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsub132ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmsub132ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfmsub132ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub132ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmsub132ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfmsub132ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsub213pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmsub213pd_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmsub213pd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsub213pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmsub213pd_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmsub213pd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213pd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmsub213pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub213pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmsub213pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsub213pd_xmm_k1z_xmm_xmmm128b64
		} else if self.prefer_vex() {
			Code::VEX_Vfmsub213pd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmsub213pd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmsub213pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsub213pd_ymm_k1z_ymm_ymmm256b64
		} else if self.prefer_vex() {
			Code::VEX_Vfmsub213pd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmsub213pd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213pd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub213pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub213pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213ph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsub213ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub213ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213ph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsub213ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub213ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213ph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmsub213ph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub213ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213ph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub213ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub213ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213ph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub213ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub213ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213ph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub213ph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub213ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsub213ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmsub213ps_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmsub213ps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsub213ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmsub213ps_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmsub213ps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmsub213ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub213ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmsub213ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsub213ps_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vfmsub213ps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmsub213ps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmsub213ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsub213ps_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vfmsub213ps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmsub213ps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub213ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub213ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsub213sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmsub213sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfmsub213sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub213sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmsub213sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfmsub213sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213sh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsub213sh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub213sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213sh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub213sh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub213sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsub213ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmsub213ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfmsub213ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub213ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmsub213ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfmsub213ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsub231pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmsub231pd_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmsub231pd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsub231pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmsub231pd_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmsub231pd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231pd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmsub231pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub231pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmsub231pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsub231pd_xmm_k1z_xmm_xmmm128b64
		} else if self.prefer_vex() {
			Code::VEX_Vfmsub231pd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmsub231pd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmsub231pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsub231pd_ymm_k1z_ymm_ymmm256b64
		} else if self.prefer_vex() {
			Code::VEX_Vfmsub231pd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmsub231pd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231pd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub231pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub231pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231ph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsub231ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub231ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231ph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsub231ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub231ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231ph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmsub231ph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub231ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231ph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub231ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub231ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231ph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub231ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub231ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231ph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub231ph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub231ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsub231ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmsub231ps_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmsub231ps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsub231ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmsub231ps_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmsub231ps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmsub231ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub231ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmsub231ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsub231ps_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vfmsub231ps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmsub231ps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmsub231ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsub231ps_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vfmsub231ps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmsub231ps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub231ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub231ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsub231sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmsub231sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfmsub231sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub231sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmsub231sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfmsub231sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231sh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsub231sh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub231sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231sh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub231sh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub231sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsub231ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmsub231ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfmsub231ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub231ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmsub231ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfmsub231ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd132pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd132pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmsubadd132pd_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmsubadd132pd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd132pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd132pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmsubadd132pd_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmsubadd132pd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd132pd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd132pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd132pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd132pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmsubadd132pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsubadd132pd_xmm_k1z_xmm_xmmm128b64
		} else if self.prefer_vex() {
			Code::VEX_Vfmsubadd132pd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmsubadd132pd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd132pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmsubadd132pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsubadd132pd_ymm_k1z_ymm_ymmm256b64
		} else if self.prefer_vex() {
			Code::VEX_Vfmsubadd132pd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmsubadd132pd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd132pd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubadd132pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd132pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd132ph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd132ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd132ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd132ph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd132ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd132ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd132ph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd132ph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd132ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd132ph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubadd132ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd132ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd132ph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubadd132ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd132ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd132ph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubadd132ph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd132ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd132ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd132ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmsubadd132ps_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmsubadd132ps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd132ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd132ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmsubadd132ps_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmsubadd132ps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd132ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd132ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd132ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd132ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmsubadd132ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsubadd132ps_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vfmsubadd132ps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmsubadd132ps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd132ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmsubadd132ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsubadd132ps_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vfmsubadd132ps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmsubadd132ps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd132ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubadd132ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd132ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd213pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd213pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmsubadd213pd_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmsubadd213pd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd213pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd213pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmsubadd213pd_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmsubadd213pd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd213pd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd213pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd213pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd213pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmsubadd213pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsubadd213pd_xmm_k1z_xmm_xmmm128b64
		} else if self.prefer_vex() {
			Code::VEX_Vfmsubadd213pd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmsubadd213pd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd213pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmsubadd213pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsubadd213pd_ymm_k1z_ymm_ymmm256b64
		} else if self.prefer_vex() {
			Code::VEX_Vfmsubadd213pd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmsubadd213pd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd213pd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubadd213pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd213pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd213ph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd213ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd213ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd213ph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd213ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd213ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd213ph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd213ph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd213ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd213ph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubadd213ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd213ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd213ph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubadd213ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd213ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd213ph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubadd213ph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd213ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd213ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd213ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmsubadd213ps_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmsubadd213ps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd213ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd213ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmsubadd213ps_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmsubadd213ps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd213ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd213ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd213ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd213ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmsubadd213ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsubadd213ps_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vfmsubadd213ps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmsubadd213ps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd213ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmsubadd213ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsubadd213ps_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vfmsubadd213ps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmsubadd213ps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd213ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubadd213ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd213ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd231pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd231pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmsubadd231pd_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmsubadd231pd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd231pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd231pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmsubadd231pd_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmsubadd231pd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd231pd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd231pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd231pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd231pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmsubadd231pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsubadd231pd_xmm_k1z_xmm_xmmm128b64
		} else if self.prefer_vex() {
			Code::VEX_Vfmsubadd231pd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmsubadd231pd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd231pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmsubadd231pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsubadd231pd_ymm_k1z_ymm_ymmm256b64
		} else if self.prefer_vex() {
			Code::VEX_Vfmsubadd231pd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmsubadd231pd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd231pd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubadd231pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd231pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd231ph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd231ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd231ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd231ph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd231ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd231ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd231ph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd231ph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd231ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd231ph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubadd231ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd231ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd231ph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubadd231ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd231ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd231ph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubadd231ph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd231ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd231ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd231ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmsubadd231ps_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmsubadd231ps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd231ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd231ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfmsubadd231ps_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmsubadd231ps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd231ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd231ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd231ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd231ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmsubadd231ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsubadd231ps_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vfmsubadd231ps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmsubadd231ps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd231ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfmsubadd231ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsubadd231ps_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vfmsubadd231ps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmsubadd231ps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd231ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubadd231ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd231ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubaddpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubaddpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubaddpd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubaddpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubaddpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubaddpd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubaddpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsubaddpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubaddpd_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubaddpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsubaddpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubaddpd_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubaddpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubaddpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubaddpd_xmm_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubaddpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubaddpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubaddpd_ymm_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubaddps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubaddps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubaddps_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubaddps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubaddps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubaddps_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubaddps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsubaddps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubaddps_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubaddps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsubaddps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubaddps_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubaddps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubaddps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubaddps_xmm_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubaddps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubaddps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubaddps_ymm_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubpd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubpd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsubpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubpd_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsubpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubpd_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubpd_xmm_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubpd_ymm_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubps_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubps_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsubps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubps_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsubps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubps_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubps_xmm_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubps_ymm_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubsd_xmm_xmm_xmmm64_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubsd_xmm_xmm_xmmm64_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubsd_xmm_xmm_xmm_xmmm64, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubss_xmm_xmm_xmmm32_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubss_xmm_xmm_xmmm32_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubss_xmm_xmm_xmm_xmmm32, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmulcph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmulcph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmulcph_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmulcph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmulcph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmulcph_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmulcph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmulcph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmulcph_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmulcph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmulcph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmulcph_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmulcph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmulcph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmulcph_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmulcph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmulcph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmulcph_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmulcsh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmulcsh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmulcsh_xmm_k1z_xmm_xmmm32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmulcsh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmulcsh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmulcsh_xmm_k1z_xmm_xmmm32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmadd132pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmadd132pd_xmm_xmm_xmmm128 } else { Code::EVEX_Vfnmadd132pd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmadd132pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmadd132pd_ymm_ymm_ymmm256 } else { Code::EVEX_Vfnmadd132pd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132pd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfnmadd132pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd132pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfnmadd132pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmadd132pd_xmm_k1z_xmm_xmmm128b64
		} else if self.prefer_vex() {
			Code::VEX_Vfnmadd132pd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfnmadd132pd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfnmadd132pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmadd132pd_ymm_k1z_ymm_ymmm256b64
		} else if self.prefer_vex() {
			Code::VEX_Vfnmadd132pd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfnmadd132pd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132pd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd132pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd132pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132ph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmadd132ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd132ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132ph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmadd132ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd132ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132ph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfnmadd132ph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd132ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132ph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd132ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd132ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132ph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd132ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd132ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132ph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd132ph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd132ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmadd132ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmadd132ps_xmm_xmm_xmmm128 } else { Code::EVEX_Vfnmadd132ps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmadd132ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmadd132ps_ymm_ymm_ymmm256 } else { Code::EVEX_Vfnmadd132ps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfnmadd132ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd132ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfnmadd132ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmadd132ps_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vfnmadd132ps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfnmadd132ps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfnmadd132ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmadd132ps_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vfnmadd132ps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfnmadd132ps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd132ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd132ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmadd132sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmadd132sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfnmadd132sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd132sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmadd132sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfnmadd132sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132sh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmadd132sh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd132sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132sh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd132sh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd132sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmadd132ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmadd132ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfnmadd132ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd132ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmadd132ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfnmadd132ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmadd213pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmadd213pd_xmm_xmm_xmmm128 } else { Code::EVEX_Vfnmadd213pd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmadd213pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmadd213pd_ymm_ymm_ymmm256 } else { Code::EVEX_Vfnmadd213pd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213pd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfnmadd213pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd213pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfnmadd213pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmadd213pd_xmm_k1z_xmm_xmmm128b64
		} else if self.prefer_vex() {
			Code::VEX_Vfnmadd213pd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfnmadd213pd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfnmadd213pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmadd213pd_ymm_k1z_ymm_ymmm256b64
		} else if self.prefer_vex() {
			Code::VEX_Vfnmadd213pd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfnmadd213pd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213pd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd213pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd213pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213ph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmadd213ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd213ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213ph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmadd213ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd213ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213ph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfnmadd213ph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd213ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213ph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd213ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd213ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213ph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd213ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd213ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213ph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd213ph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd213ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmadd213ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmadd213ps_xmm_xmm_xmmm128 } else { Code::EVEX_Vfnmadd213ps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmadd213ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmadd213ps_ymm_ymm_ymmm256 } else { Code::EVEX_Vfnmadd213ps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfnmadd213ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd213ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfnmadd213ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmadd213ps_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vfnmadd213ps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfnmadd213ps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfnmadd213ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmadd213ps_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vfnmadd213ps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfnmadd213ps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd213ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd213ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmadd213sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmadd213sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfnmadd213sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd213sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmadd213sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfnmadd213sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213sh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmadd213sh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd213sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213sh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd213sh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd213sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmadd213ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmadd213ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfnmadd213ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd213ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmadd213ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfnmadd213ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmadd231pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmadd231pd_xmm_xmm_xmmm128 } else { Code::EVEX_Vfnmadd231pd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmadd231pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmadd231pd_ymm_ymm_ymmm256 } else { Code::EVEX_Vfnmadd231pd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231pd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfnmadd231pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd231pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfnmadd231pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmadd231pd_xmm_k1z_xmm_xmmm128b64
		} else if self.prefer_vex() {
			Code::VEX_Vfnmadd231pd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfnmadd231pd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfnmadd231pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmadd231pd_ymm_k1z_ymm_ymmm256b64
		} else if self.prefer_vex() {
			Code::VEX_Vfnmadd231pd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfnmadd231pd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231pd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd231pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd231pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231ph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmadd231ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd231ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231ph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmadd231ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd231ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231ph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfnmadd231ph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd231ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231ph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd231ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd231ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231ph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd231ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd231ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231ph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd231ph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd231ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmadd231ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmadd231ps_xmm_xmm_xmmm128 } else { Code::EVEX_Vfnmadd231ps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmadd231ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmadd231ps_ymm_ymm_ymmm256 } else { Code::EVEX_Vfnmadd231ps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfnmadd231ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd231ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfnmadd231ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmadd231ps_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vfnmadd231ps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfnmadd231ps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfnmadd231ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmadd231ps_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vfnmadd231ps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfnmadd231ps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd231ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd231ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmadd231sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmadd231sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfnmadd231sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd231sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmadd231sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfnmadd231sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231sh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmadd231sh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd231sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231sh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd231sh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd231sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmadd231ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmadd231ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfnmadd231ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd231ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmadd231ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfnmadd231ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmaddpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmaddpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmaddpd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmaddpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmaddpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmaddpd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmaddpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmaddpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmaddpd_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmaddpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmaddpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmaddpd_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmaddpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmaddpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmaddpd_xmm_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmaddpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmaddpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmaddpd_ymm_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmaddps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmaddps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmaddps_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmaddps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmaddps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmaddps_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmaddps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmaddps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmaddps_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmaddps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmaddps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmaddps_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmaddps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmaddps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmaddps_xmm_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmaddps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmaddps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmaddps_ymm_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmaddsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmaddsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmaddsd_xmm_xmm_xmmm64_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmaddsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmaddsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmaddsd_xmm_xmm_xmmm64_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmaddsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmaddsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmaddsd_xmm_xmm_xmm_xmmm64, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmaddss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmaddss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmaddss_xmm_xmm_xmmm32_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmaddss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmaddss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmaddss_xmm_xmm_xmmm32_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmaddss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmaddss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmaddss_xmm_xmm_xmm_xmmm32, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsub132pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmsub132pd_xmm_xmm_xmmm128 } else { Code::EVEX_Vfnmsub132pd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmsub132pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmsub132pd_ymm_ymm_ymmm256 } else { Code::EVEX_Vfnmsub132pd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132pd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfnmsub132pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub132pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfnmsub132pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmsub132pd_xmm_k1z_xmm_xmmm128b64
		} else if self.prefer_vex() {
			Code::VEX_Vfnmsub132pd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfnmsub132pd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfnmsub132pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmsub132pd_ymm_k1z_ymm_ymmm256b64
		} else if self.prefer_vex() {
			Code::VEX_Vfnmsub132pd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfnmsub132pd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132pd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub132pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub132pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132ph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsub132ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub132ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132ph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmsub132ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub132ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132ph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfnmsub132ph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub132ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132ph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub132ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub132ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132ph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub132ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub132ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132ph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub132ph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub132ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsub132ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmsub132ps_xmm_xmm_xmmm128 } else { Code::EVEX_Vfnmsub132ps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmsub132ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmsub132ps_ymm_ymm_ymmm256 } else { Code::EVEX_Vfnmsub132ps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfnmsub132ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub132ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfnmsub132ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmsub132ps_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vfnmsub132ps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfnmsub132ps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfnmsub132ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmsub132ps_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vfnmsub132ps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfnmsub132ps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub132ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub132ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsub132sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmsub132sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfnmsub132sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub132sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmsub132sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfnmsub132sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132sh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsub132sh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub132sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132sh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub132sh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub132sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsub132ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmsub132ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfnmsub132ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub132ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmsub132ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfnmsub132ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsub213pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmsub213pd_xmm_xmm_xmmm128 } else { Code::EVEX_Vfnmsub213pd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmsub213pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmsub213pd_ymm_ymm_ymmm256 } else { Code::EVEX_Vfnmsub213pd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213pd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfnmsub213pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub213pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfnmsub213pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmsub213pd_xmm_k1z_xmm_xmmm128b64
		} else if self.prefer_vex() {
			Code::VEX_Vfnmsub213pd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfnmsub213pd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfnmsub213pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmsub213pd_ymm_k1z_ymm_ymmm256b64
		} else if self.prefer_vex() {
			Code::VEX_Vfnmsub213pd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfnmsub213pd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213pd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub213pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub213pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213ph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsub213ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub213ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213ph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmsub213ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub213ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213ph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfnmsub213ph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub213ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213ph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub213ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub213ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213ph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub213ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub213ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213ph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub213ph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub213ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsub213ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmsub213ps_xmm_xmm_xmmm128 } else { Code::EVEX_Vfnmsub213ps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmsub213ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmsub213ps_ymm_ymm_ymmm256 } else { Code::EVEX_Vfnmsub213ps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfnmsub213ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub213ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfnmsub213ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmsub213ps_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vfnmsub213ps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfnmsub213ps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfnmsub213ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmsub213ps_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vfnmsub213ps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfnmsub213ps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub213ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub213ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsub213sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmsub213sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfnmsub213sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub213sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmsub213sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfnmsub213sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213sh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsub213sh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub213sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213sh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub213sh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub213sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsub213ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmsub213ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfnmsub213ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub213ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmsub213ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfnmsub213ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsub231pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmsub231pd_xmm_xmm_xmmm128 } else { Code::EVEX_Vfnmsub231pd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmsub231pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmsub231pd_ymm_ymm_ymmm256 } else { Code::EVEX_Vfnmsub231pd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231pd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfnmsub231pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub231pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfnmsub231pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmsub231pd_xmm_k1z_xmm_xmmm128b64
		} else if self.prefer_vex() {
			Code::VEX_Vfnmsub231pd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfnmsub231pd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfnmsub231pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmsub231pd_ymm_k1z_ymm_ymmm256b64
		} else if self.prefer_vex() {
			Code::VEX_Vfnmsub231pd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfnmsub231pd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231pd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub231pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub231pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231ph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsub231ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub231ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231ph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmsub231ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub231ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231ph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfnmsub231ph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub231ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231ph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub231ph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub231ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231ph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub231ph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub231ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231ph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub231ph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub231ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsub231ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmsub231ps_xmm_xmm_xmmm128 } else { Code::EVEX_Vfnmsub231ps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmsub231ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmsub231ps_ymm_ymm_ymmm256 } else { Code::EVEX_Vfnmsub231ps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfnmsub231ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub231ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfnmsub231ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmsub231ps_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vfnmsub231ps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfnmsub231ps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vfnmsub231ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmsub231ps_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vfnmsub231ps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfnmsub231ps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub231ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub231ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsub231sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmsub231sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfnmsub231sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub231sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmsub231sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfnmsub231sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231sh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsub231sh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub231sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231sh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub231sh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub231sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsub231ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmsub231ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfnmsub231ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub231ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vfnmsub231ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfnmsub231ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsubpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsubpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmsubpd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsubpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsubpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmsubpd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsubpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmsubpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmsubpd_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsubpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmsubpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmsubpd_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsubpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsubpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmsubpd_xmm_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsubpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsubpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmsubpd_ymm_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsubps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsubps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmsubps_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsubps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsubps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmsubps_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsubps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmsubps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmsubps_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsubps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmsubps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmsubps_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsubps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsubps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmsubps_xmm_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsubps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsubps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmsubps_ymm_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsubsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsubsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmsubsd_xmm_xmm_xmmm64_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsubsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsubsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmsubsd_xmm_xmm_xmmm64_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsubsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsubsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmsubsd_xmm_xmm_xmm_xmmm64, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsubss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsubss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmsubss_xmm_xmm_xmmm32_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsubss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsubss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmsubss_xmm_xmm_xmmm32_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsubss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsubss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmsubss_xmm_xmm_xmm_xmmm32, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasspd<__AsmRegisterK, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vfpclasspd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclasspd_kr_k1_xmmm128b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasspd<__AsmRegisterK, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vfpclasspd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclasspd_kr_k1_ymmm256b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasspd<__AsmRegisterK, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vfpclasspd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclasspd_kr_k1_zmmm512b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasspd<__AsmRegisterK, __AsmMemoryOperand, i32> for CodeAssembler {
	fn vfpclasspd(&mut self, op0: __AsmRegisterK, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vfpclasspd_kr_k1_zmmm512b64_imm8
		} else if op1.size() == MemoryOperandSize::Zword {
			Code::EVEX_Vfpclasspd_kr_k1_zmmm512b64_imm8
		} else if op1.size() == MemoryOperandSize::Yword {
			Code::EVEX_Vfpclasspd_kr_k1_ymmm256b64_imm8
		} else if op1.size() == MemoryOperandSize::Xword {
			Code::EVEX_Vfpclasspd_kr_k1_xmmm128b64_imm8
		} else {
			return Err(IcedError::new("vfpclasspd: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasspd<__AsmRegisterK, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vfpclasspd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclasspd_kr_k1_xmmm128b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasspd<__AsmRegisterK, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vfpclasspd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclasspd_kr_k1_ymmm256b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasspd<__AsmRegisterK, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vfpclasspd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclasspd_kr_k1_zmmm512b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasspd<__AsmRegisterK, __AsmMemoryOperand, u32> for CodeAssembler {
	fn vfpclasspd(&mut self, op0: __AsmRegisterK, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vfpclasspd_kr_k1_zmmm512b64_imm8
		} else if op1.size() == MemoryOperandSize::Zword {
			Code::EVEX_Vfpclasspd_kr_k1_zmmm512b64_imm8
		} else if op1.size() == MemoryOperandSize::Yword {
			Code::EVEX_Vfpclasspd_kr_k1_ymmm256b64_imm8
		} else if op1.size() == MemoryOperandSize::Xword {
			Code::EVEX_Vfpclasspd_kr_k1_xmmm128b64_imm8
		} else {
			return Err(IcedError::new("vfpclasspd: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasspdx<__AsmRegisterK, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vfpclasspdx(&mut self, op0: __AsmRegisterK, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclasspd_kr_k1_xmmm128b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasspdx<__AsmRegisterK, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vfpclasspdx(&mut self, op0: __AsmRegisterK, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclasspd_kr_k1_xmmm128b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasspdy<__AsmRegisterK, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vfpclasspdy(&mut self, op0: __AsmRegisterK, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclasspd_kr_k1_ymmm256b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasspdy<__AsmRegisterK, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vfpclasspdy(&mut self, op0: __AsmRegisterK, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclasspd_kr_k1_ymmm256b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasspdz<__AsmRegisterK, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vfpclasspdz(&mut self, op0: __AsmRegisterK, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclasspd_kr_k1_zmmm512b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasspdz<__AsmRegisterK, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vfpclasspdz(&mut self, op0: __AsmRegisterK, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclasspd_kr_k1_zmmm512b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassph<__AsmRegisterK, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vfpclassph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassph_kr_k1_xmmm128b16_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassph<__AsmRegisterK, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vfpclassph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassph_kr_k1_ymmm256b16_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassph<__AsmRegisterK, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vfpclassph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassph_kr_k1_zmmm512b16_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassph<__AsmRegisterK, __AsmMemoryOperand, i32> for CodeAssembler {
	fn vfpclassph(&mut self, op0: __AsmRegisterK, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vfpclassph_kr_k1_zmmm512b16_imm8
		} else if op1.size() == MemoryOperandSize::Zword {
			Code::EVEX_Vfpclassph_kr_k1_zmmm512b16_imm8
		} else if op1.size() == MemoryOperandSize::Yword {
			Code::EVEX_Vfpclassph_kr_k1_ymmm256b16_imm8
		} else if op1.size() == MemoryOperandSize::Xword {
			Code::EVEX_Vfpclassph_kr_k1_xmmm128b16_imm8
		} else {
			return Err(IcedError::new("vfpclassph: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassph<__AsmRegisterK, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vfpclassph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassph_kr_k1_xmmm128b16_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassph<__AsmRegisterK, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vfpclassph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassph_kr_k1_ymmm256b16_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassph<__AsmRegisterK, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vfpclassph(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassph_kr_k1_zmmm512b16_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassph<__AsmRegisterK, __AsmMemoryOperand, u32> for CodeAssembler {
	fn vfpclassph(&mut self, op0: __AsmRegisterK, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vfpclassph_kr_k1_zmmm512b16_imm8
		} else if op1.size() == MemoryOperandSize::Zword {
			Code::EVEX_Vfpclassph_kr_k1_zmmm512b16_imm8
		} else if op1.size() == MemoryOperandSize::Yword {
			Code::EVEX_Vfpclassph_kr_k1_ymmm256b16_imm8
		} else if op1.size() == MemoryOperandSize::Xword {
			Code::EVEX_Vfpclassph_kr_k1_xmmm128b16_imm8
		} else {
			return Err(IcedError::new("vfpclassph: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassphx<__AsmRegisterK, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vfpclassphx(&mut self, op0: __AsmRegisterK, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassph_kr_k1_xmmm128b16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassphx<__AsmRegisterK, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vfpclassphx(&mut self, op0: __AsmRegisterK, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassph_kr_k1_xmmm128b16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassphy<__AsmRegisterK, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vfpclassphy(&mut self, op0: __AsmRegisterK, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassph_kr_k1_ymmm256b16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassphy<__AsmRegisterK, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vfpclassphy(&mut self, op0: __AsmRegisterK, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassph_kr_k1_ymmm256b16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassphz<__AsmRegisterK, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vfpclassphz(&mut self, op0: __AsmRegisterK, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassph_kr_k1_zmmm512b16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassphz<__AsmRegisterK, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vfpclassphz(&mut self, op0: __AsmRegisterK, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassph_kr_k1_zmmm512b16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassps<__AsmRegisterK, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vfpclassps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassps_kr_k1_xmmm128b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassps<__AsmRegisterK, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vfpclassps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassps_kr_k1_ymmm256b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassps<__AsmRegisterK, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vfpclassps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassps_kr_k1_zmmm512b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassps<__AsmRegisterK, __AsmMemoryOperand, i32> for CodeAssembler {
	fn vfpclassps(&mut self, op0: __AsmRegisterK, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vfpclassps_kr_k1_zmmm512b32_imm8
		} else if op1.size() == MemoryOperandSize::Zword {
			Code::EVEX_Vfpclassps_kr_k1_zmmm512b32_imm8
		} else if op1.size() == MemoryOperandSize::Yword {
			Code::EVEX_Vfpclassps_kr_k1_ymmm256b32_imm8
		} else if op1.size() == MemoryOperandSize::Xword {
			Code::EVEX_Vfpclassps_kr_k1_xmmm128b32_imm8
		} else {
			return Err(IcedError::new("vfpclassps: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassps<__AsmRegisterK, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vfpclassps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassps_kr_k1_xmmm128b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassps<__AsmRegisterK, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vfpclassps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassps_kr_k1_ymmm256b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassps<__AsmRegisterK, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vfpclassps(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassps_kr_k1_zmmm512b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassps<__AsmRegisterK, __AsmMemoryOperand, u32> for CodeAssembler {
	fn vfpclassps(&mut self, op0: __AsmRegisterK, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vfpclassps_kr_k1_zmmm512b32_imm8
		} else if op1.size() == MemoryOperandSize::Zword {
			Code::EVEX_Vfpclassps_kr_k1_zmmm512b32_imm8
		} else if op1.size() == MemoryOperandSize::Yword {
			Code::EVEX_Vfpclassps_kr_k1_ymmm256b32_imm8
		} else if op1.size() == MemoryOperandSize::Xword {
			Code::EVEX_Vfpclassps_kr_k1_xmmm128b32_imm8
		} else {
			return Err(IcedError::new("vfpclassps: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasspsx<__AsmRegisterK, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vfpclasspsx(&mut self, op0: __AsmRegisterK, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassps_kr_k1_xmmm128b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasspsx<__AsmRegisterK, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vfpclasspsx(&mut self, op0: __AsmRegisterK, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassps_kr_k1_xmmm128b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasspsy<__AsmRegisterK, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vfpclasspsy(&mut self, op0: __AsmRegisterK, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassps_kr_k1_ymmm256b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasspsy<__AsmRegisterK, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vfpclasspsy(&mut self, op0: __AsmRegisterK, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassps_kr_k1_ymmm256b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasspsz<__AsmRegisterK, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vfpclasspsz(&mut self, op0: __AsmRegisterK, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassps_kr_k1_zmmm512b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasspsz<__AsmRegisterK, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vfpclasspsz(&mut self, op0: __AsmRegisterK, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassps_kr_k1_zmmm512b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasssd<__AsmRegisterK, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vfpclasssd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclasssd_kr_k1_xmmm64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasssd<__AsmRegisterK, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vfpclasssd(&mut self, op0: __AsmRegisterK, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclasssd_kr_k1_xmmm64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasssd<__AsmRegisterK, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vfpclasssd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclasssd_kr_k1_xmmm64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasssd<__AsmRegisterK, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vfpclasssd(&mut self, op0: __AsmRegisterK, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclasssd_kr_k1_xmmm64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasssh<__AsmRegisterK, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vfpclasssh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclasssh_kr_k1_xmmm16_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasssh<__AsmRegisterK, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vfpclasssh(&mut self, op0: __AsmRegisterK, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclasssh_kr_k1_xmmm16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasssh<__AsmRegisterK, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vfpclasssh(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclasssh_kr_k1_xmmm16_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasssh<__AsmRegisterK, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vfpclasssh(&mut self, op0: __AsmRegisterK, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclasssh_kr_k1_xmmm16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassss<__AsmRegisterK, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vfpclassss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassss_kr_k1_xmmm32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassss<__AsmRegisterK, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vfpclassss(&mut self, op0: __AsmRegisterK, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassss_kr_k1_xmmm32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassss<__AsmRegisterK, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vfpclassss(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassss_kr_k1_xmmm32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassss<__AsmRegisterK, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vfpclassss(&mut self, op0: __AsmRegisterK, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassss_kr_k1_xmmm32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfrczpd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfrczpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vfrczpd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfrczpd<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfrczpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vfrczpd_ymm_ymmm256, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfrczpd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfrczpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vfrczpd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfrczpd<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfrczpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vfrczpd_ymm_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfrczps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfrczps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vfrczps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfrczps<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfrczps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vfrczps_ymm_ymmm256, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfrczps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfrczps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vfrczps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfrczps<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfrczps(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vfrczps_ymm_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfrczsd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfrczsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vfrczsd_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfrczsd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfrczsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vfrczsd_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfrczss<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfrczss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vfrczss_xmm_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfrczss<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfrczss(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vfrczss_xmm_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherdpd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgatherdpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgatherdpd_xmm_k1_vm32x, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherdpd<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgatherdpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgatherdpd_ymm_k1_vm32x, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherdpd<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgatherdpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgatherdpd_zmm_k1_vm32y, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherdpd3<__AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vgatherdpd_3(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vgatherdpd_xmm_vm32x_xmm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherdpd3<__AsmRegisterYmm, __AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vgatherdpd_3(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vgatherdpd_ymm_vm32x_ymm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherdps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgatherdps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgatherdps_xmm_k1_vm32x, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherdps<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgatherdps(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgatherdps_ymm_k1_vm32y, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherdps<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgatherdps(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgatherdps_zmm_k1_vm32z, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherdps3<__AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vgatherdps_3(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vgatherdps_xmm_vm32x_xmm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherdps3<__AsmRegisterYmm, __AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vgatherdps_3(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vgatherdps_ymm_vm32y_ymm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherpf0dpd<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgatherpf0dpd(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with1(Code::EVEX_Vgatherpf0dpd_vm32y_k1, op0.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherpf0dps<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgatherpf0dps(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with1(Code::EVEX_Vgatherpf0dps_vm32z_k1, op0.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherpf0qpd<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgatherpf0qpd(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with1(Code::EVEX_Vgatherpf0qpd_vm64z_k1, op0.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherpf0qps<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgatherpf0qps(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with1(Code::EVEX_Vgatherpf0qps_vm64z_k1, op0.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherpf1dpd<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgatherpf1dpd(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with1(Code::EVEX_Vgatherpf1dpd_vm32y_k1, op0.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherpf1dps<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgatherpf1dps(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with1(Code::EVEX_Vgatherpf1dps_vm32z_k1, op0.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherpf1qpd<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgatherpf1qpd(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with1(Code::EVEX_Vgatherpf1qpd_vm64z_k1, op0.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherpf1qps<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgatherpf1qps(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with1(Code::EVEX_Vgatherpf1qps_vm64z_k1, op0.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherqpd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgatherqpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgatherqpd_xmm_k1_vm64x, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherqpd<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgatherqpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgatherqpd_ymm_k1_vm64y, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherqpd<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgatherqpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgatherqpd_zmm_k1_vm64z, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherqpd3<__AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vgatherqpd_3(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vgatherqpd_xmm_vm64x_xmm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherqpd3<__AsmRegisterYmm, __AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vgatherqpd_3(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vgatherqpd_ymm_vm64y_ymm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherqps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vgatherqps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.index().is_xmm() {
			Code::EVEX_Vgatherqps_xmm_k1_vm64x
		} else if op1.index().is_ymm() {
			Code::EVEX_Vgatherqps_xmm_k1_vm64y
		} else {
			return Err(IcedError::new("vgatherqps: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherqps<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgatherqps(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgatherqps_ymm_k1_vm64z, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherqps3<__AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	fn vgatherqps_3(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if op1.index().is_xmm() {
			Code::VEX_Vgatherqps_xmm_vm64x_xmm
		} else if op1.index().is_ymm() {
			Code::VEX_Vgatherqps_xmm_vm64y_xmm
		} else {
			return Err(IcedError::new("vgatherqps: invalid operands"));
		};
		self.add_instr(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexppd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vgetexppd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgetexppd_xmm_k1z_xmmm128b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexppd<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vgetexppd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgetexppd_ymm_k1z_ymmm256b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexppd<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vgetexppd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgetexppd_zmm_k1z_zmmm512b64_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexppd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgetexppd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgetexppd_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexppd<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgetexppd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgetexppd_ymm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexppd<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgetexppd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgetexppd_zmm_k1z_zmmm512b64_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexpph<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vgetexpph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgetexpph_xmm_k1z_xmmm128b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexpph<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vgetexpph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgetexpph_ymm_k1z_ymmm256b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexpph<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vgetexpph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgetexpph_zmm_k1z_zmmm512b16_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexpph<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgetexpph(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgetexpph_xmm_k1z_xmmm128b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexpph<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgetexpph(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgetexpph_ymm_k1z_ymmm256b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexpph<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgetexpph(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgetexpph_zmm_k1z_zmmm512b16_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexpps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vgetexpps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgetexpps_xmm_k1z_xmmm128b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexpps<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vgetexpps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgetexpps_ymm_k1z_ymmm256b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexpps<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vgetexpps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgetexpps_zmm_k1z_zmmm512b32_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexpps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgetexpps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgetexpps_xmm_k1z_xmmm128b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexpps<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgetexpps(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgetexpps_ymm_k1z_ymmm256b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexpps<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgetexpps(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgetexpps_zmm_k1z_zmmm512b32_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vgetexpsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetexpsd_xmm_k1z_xmm_xmmm64_sae, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexpsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgetexpsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetexpsd_xmm_k1z_xmm_xmmm64_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexpsh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vgetexpsh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetexpsh_xmm_k1z_xmm_xmmm16_sae, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexpsh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgetexpsh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetexpsh_xmm_k1z_xmm_xmmm16_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vgetexpss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetexpss_xmm_k1z_xmm_xmmm32_sae, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgetexpss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetexpss_xmm_k1z_xmm_xmmm32_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantpd<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vgetmantpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantpd_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantpd<__AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vgetmantpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantpd_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantpd<__AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vgetmantpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantpd_zmm_k1z_zmmm512b64_imm8_sae, op0.register(), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantpd<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vgetmantpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantpd_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantpd<__AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vgetmantpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantpd_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantpd<__AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vgetmantpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantpd_zmm_k1z_zmmm512b64_imm8_sae, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantpd<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vgetmantpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantpd_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantpd<__AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vgetmantpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantpd_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantpd<__AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vgetmantpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantpd_zmm_k1z_zmmm512b64_imm8_sae, op0.register(), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantpd<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vgetmantpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantpd_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantpd<__AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vgetmantpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantpd_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantpd<__AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vgetmantpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantpd_zmm_k1z_zmmm512b64_imm8_sae, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantph<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vgetmantph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantph_xmm_k1z_xmmm128b16_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantph<__AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vgetmantph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantph_ymm_k1z_ymmm256b16_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantph<__AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vgetmantph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantph_zmm_k1z_zmmm512b16_imm8_sae, op0.register(), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantph<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vgetmantph(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantph_xmm_k1z_xmmm128b16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantph<__AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vgetmantph(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantph_ymm_k1z_ymmm256b16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantph<__AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vgetmantph(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantph_zmm_k1z_zmmm512b16_imm8_sae, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantph<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vgetmantph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantph_xmm_k1z_xmmm128b16_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantph<__AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vgetmantph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantph_ymm_k1z_ymmm256b16_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantph<__AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vgetmantph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantph_zmm_k1z_zmmm512b16_imm8_sae, op0.register(), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantph<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vgetmantph(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantph_xmm_k1z_xmmm128b16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantph<__AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vgetmantph(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantph_ymm_k1z_ymmm256b16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantph<__AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vgetmantph(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantph_zmm_k1z_zmmm512b16_imm8_sae, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantps<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vgetmantps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantps_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantps<__AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vgetmantps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantps_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantps<__AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vgetmantps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantps_zmm_k1z_zmmm512b32_imm8_sae, op0.register(), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantps<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vgetmantps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantps_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantps<__AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vgetmantps(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantps_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantps<__AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vgetmantps(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantps_zmm_k1z_zmmm512b32_imm8_sae, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantps<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vgetmantps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantps_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantps<__AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vgetmantps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantps_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantps<__AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vgetmantps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantps_zmm_k1z_zmmm512b32_imm8_sae, op0.register(), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantps<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vgetmantps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantps_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantps<__AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vgetmantps(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantps_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantps<__AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vgetmantps(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantps_zmm_k1z_zmmm512b32_imm8_sae, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vgetmantsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vgetmantsd_xmm_k1z_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vgetmantsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vgetmantsd_xmm_k1z_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vgetmantsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vgetmantsd_xmm_k1z_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vgetmantsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vgetmantsd_xmm_k1z_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantsh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vgetmantsh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vgetmantsh_xmm_k1z_xmm_xmmm16_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantsh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vgetmantsh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vgetmantsh_xmm_k1z_xmm_xmmm16_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantsh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vgetmantsh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vgetmantsh_xmm_k1z_xmm_xmmm16_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantsh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vgetmantsh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vgetmantsh_xmm_k1z_xmm_xmmm16_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vgetmantss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vgetmantss_xmm_k1z_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vgetmantss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vgetmantss_xmm_k1z_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vgetmantss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vgetmantss_xmm_k1z_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vgetmantss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vgetmantss_xmm_k1z_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineinvqb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vgf2p8affineinvqb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vgf2p8affineinvqb_xmm_xmm_xmmm128_imm8 } else { Code::EVEX_Vgf2p8affineinvqb_xmm_k1z_xmm_xmmm128b64_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineinvqb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vgf2p8affineinvqb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vgf2p8affineinvqb_ymm_ymm_ymmm256_imm8 } else { Code::EVEX_Vgf2p8affineinvqb_ymm_k1z_ymm_ymmm256b64_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineinvqb<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vgf2p8affineinvqb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vgf2p8affineinvqb_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineinvqb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	fn vgf2p8affineinvqb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vgf2p8affineinvqb_xmm_k1z_xmm_xmmm128b64_imm8
		} else if self.prefer_vex() {
			Code::VEX_Vgf2p8affineinvqb_xmm_xmm_xmmm128_imm8
		} else {
			Code::EVEX_Vgf2p8affineinvqb_xmm_k1z_xmm_xmmm128b64_imm8
		};
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineinvqb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	fn vgf2p8affineinvqb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vgf2p8affineinvqb_ymm_k1z_ymm_ymmm256b64_imm8
		} else if self.prefer_vex() {
			Code::VEX_Vgf2p8affineinvqb_ymm_ymm_ymmm256_imm8
		} else {
			Code::EVEX_Vgf2p8affineinvqb_ymm_k1z_ymm_ymmm256b64_imm8
		};
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineinvqb<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vgf2p8affineinvqb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vgf2p8affineinvqb_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineinvqb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vgf2p8affineinvqb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vgf2p8affineinvqb_xmm_xmm_xmmm128_imm8 } else { Code::EVEX_Vgf2p8affineinvqb_xmm_k1z_xmm_xmmm128b64_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineinvqb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vgf2p8affineinvqb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vgf2p8affineinvqb_ymm_ymm_ymmm256_imm8 } else { Code::EVEX_Vgf2p8affineinvqb_ymm_k1z_ymm_ymmm256b64_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineinvqb<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vgf2p8affineinvqb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vgf2p8affineinvqb_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineinvqb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	fn vgf2p8affineinvqb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vgf2p8affineinvqb_xmm_k1z_xmm_xmmm128b64_imm8
		} else if self.prefer_vex() {
			Code::VEX_Vgf2p8affineinvqb_xmm_xmm_xmmm128_imm8
		} else {
			Code::EVEX_Vgf2p8affineinvqb_xmm_k1z_xmm_xmmm128b64_imm8
		};
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineinvqb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	fn vgf2p8affineinvqb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vgf2p8affineinvqb_ymm_k1z_ymm_ymmm256b64_imm8
		} else if self.prefer_vex() {
			Code::VEX_Vgf2p8affineinvqb_ymm_ymm_ymmm256_imm8
		} else {
			Code::EVEX_Vgf2p8affineinvqb_ymm_k1z_ymm_ymmm256b64_imm8
		};
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineinvqb<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vgf2p8affineinvqb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vgf2p8affineinvqb_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineqb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vgf2p8affineqb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vgf2p8affineqb_xmm_xmm_xmmm128_imm8 } else { Code::EVEX_Vgf2p8affineqb_xmm_k1z_xmm_xmmm128b64_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineqb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vgf2p8affineqb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vgf2p8affineqb_ymm_ymm_ymmm256_imm8 } else { Code::EVEX_Vgf2p8affineqb_ymm_k1z_ymm_ymmm256b64_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineqb<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vgf2p8affineqb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vgf2p8affineqb_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineqb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	fn vgf2p8affineqb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vgf2p8affineqb_xmm_k1z_xmm_xmmm128b64_imm8
		} else if self.prefer_vex() {
			Code::VEX_Vgf2p8affineqb_xmm_xmm_xmmm128_imm8
		} else {
			Code::EVEX_Vgf2p8affineqb_xmm_k1z_xmm_xmmm128b64_imm8
		};
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineqb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	fn vgf2p8affineqb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vgf2p8affineqb_ymm_k1z_ymm_ymmm256b64_imm8
		} else if self.prefer_vex() {
			Code::VEX_Vgf2p8affineqb_ymm_ymm_ymmm256_imm8
		} else {
			Code::EVEX_Vgf2p8affineqb_ymm_k1z_ymm_ymmm256b64_imm8
		};
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineqb<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vgf2p8affineqb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vgf2p8affineqb_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineqb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vgf2p8affineqb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vgf2p8affineqb_xmm_xmm_xmmm128_imm8 } else { Code::EVEX_Vgf2p8affineqb_xmm_k1z_xmm_xmmm128b64_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineqb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vgf2p8affineqb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vgf2p8affineqb_ymm_ymm_ymmm256_imm8 } else { Code::EVEX_Vgf2p8affineqb_ymm_k1z_ymm_ymmm256b64_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineqb<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vgf2p8affineqb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vgf2p8affineqb_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineqb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	fn vgf2p8affineqb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vgf2p8affineqb_xmm_k1z_xmm_xmmm128b64_imm8
		} else if self.prefer_vex() {
			Code::VEX_Vgf2p8affineqb_xmm_xmm_xmmm128_imm8
		} else {
			Code::EVEX_Vgf2p8affineqb_xmm_k1z_xmm_xmmm128b64_imm8
		};
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineqb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	fn vgf2p8affineqb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vgf2p8affineqb_ymm_k1z_ymm_ymmm256b64_imm8
		} else if self.prefer_vex() {
			Code::VEX_Vgf2p8affineqb_ymm_ymm_ymmm256_imm8
		} else {
			Code::EVEX_Vgf2p8affineqb_ymm_k1z_ymm_ymmm256b64_imm8
		};
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineqb<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vgf2p8affineqb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vgf2p8affineqb_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8mulb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vgf2p8mulb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vgf2p8mulb_xmm_xmm_xmmm128 } else { Code::EVEX_Vgf2p8mulb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8mulb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vgf2p8mulb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vgf2p8mulb_ymm_ymm_ymmm256 } else { Code::EVEX_Vgf2p8mulb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8mulb<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vgf2p8mulb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgf2p8mulb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8mulb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgf2p8mulb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vgf2p8mulb_xmm_xmm_xmmm128 } else { Code::EVEX_Vgf2p8mulb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8mulb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgf2p8mulb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vgf2p8mulb_ymm_ymm_ymmm256 } else { Code::EVEX_Vgf2p8mulb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8mulb<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgf2p8mulb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgf2p8mulb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVhaddpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vhaddpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vhaddpd_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVhaddpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vhaddpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vhaddpd_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVhaddpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vhaddpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vhaddpd_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVhaddpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vhaddpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vhaddpd_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVhaddps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vhaddps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vhaddps_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVhaddps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vhaddps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vhaddps_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVhaddps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vhaddps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vhaddps_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVhaddps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vhaddps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vhaddps_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVhsubpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vhsubpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vhsubpd_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVhsubpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vhsubpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vhsubpd_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVhsubpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vhsubpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vhsubpd_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVhsubpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vhsubpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vhsubpd_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVhsubps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vhsubps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vhsubps_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVhsubps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vhsubps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vhsubps_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVhsubps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vhsubps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vhsubps_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVhsubps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vhsubps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vhsubps_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf128<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vinsertf128(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vinsertf128_ymm_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf128<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vinsertf128(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vinsertf128_ymm_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf128<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vinsertf128(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vinsertf128_ymm_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf128<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vinsertf128(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vinsertf128_ymm_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf32x4<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vinsertf32x4(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf32x4_ymm_k1z_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf32x4<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vinsertf32x4(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf32x4_zmm_k1z_zmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf32x4<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vinsertf32x4(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf32x4_ymm_k1z_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf32x4<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vinsertf32x4(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf32x4_zmm_k1z_zmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf32x4<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vinsertf32x4(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf32x4_ymm_k1z_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf32x4<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vinsertf32x4(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf32x4_zmm_k1z_zmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf32x4<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vinsertf32x4(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf32x4_ymm_k1z_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf32x4<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vinsertf32x4(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf32x4_zmm_k1z_zmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf32x8<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vinsertf32x8(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf32x8_zmm_k1z_zmm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf32x8<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vinsertf32x8(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf32x8_zmm_k1z_zmm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf32x8<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vinsertf32x8(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf32x8_zmm_k1z_zmm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf32x8<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vinsertf32x8(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf32x8_zmm_k1z_zmm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf64x2<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vinsertf64x2(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf64x2_ymm_k1z_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf64x2<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vinsertf64x2(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf64x2_zmm_k1z_zmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf64x2<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vinsertf64x2(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf64x2_ymm_k1z_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf64x2<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vinsertf64x2(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf64x2_zmm_k1z_zmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf64x2<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vinsertf64x2(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf64x2_ymm_k1z_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf64x2<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vinsertf64x2(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf64x2_zmm_k1z_zmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf64x2<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vinsertf64x2(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf64x2_ymm_k1z_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf64x2<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vinsertf64x2(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf64x2_zmm_k1z_zmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf64x4<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vinsertf64x4(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf64x4_zmm_k1z_zmm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf64x4<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vinsertf64x4(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf64x4_zmm_k1z_zmm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf64x4<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vinsertf64x4(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf64x4_zmm_k1z_zmm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf64x4<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vinsertf64x4(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf64x4_zmm_k1z_zmm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti128<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vinserti128(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vinserti128_ymm_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti128<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vinserti128(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vinserti128_ymm_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti128<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vinserti128(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vinserti128_ymm_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti128<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vinserti128(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vinserti128_ymm_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti32x4<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vinserti32x4(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti32x4_ymm_k1z_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti32x4<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vinserti32x4(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti32x4_zmm_k1z_zmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti32x4<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vinserti32x4(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti32x4_ymm_k1z_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti32x4<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vinserti32x4(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti32x4_zmm_k1z_zmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti32x4<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vinserti32x4(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti32x4_ymm_k1z_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti32x4<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vinserti32x4(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti32x4_zmm_k1z_zmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti32x4<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vinserti32x4(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti32x4_ymm_k1z_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti32x4<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vinserti32x4(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti32x4_zmm_k1z_zmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti32x8<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vinserti32x8(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti32x8_zmm_k1z_zmm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti32x8<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vinserti32x8(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti32x8_zmm_k1z_zmm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti32x8<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vinserti32x8(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti32x8_zmm_k1z_zmm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti32x8<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vinserti32x8(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti32x8_zmm_k1z_zmm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti64x2<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vinserti64x2(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti64x2_ymm_k1z_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti64x2<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vinserti64x2(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti64x2_zmm_k1z_zmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti64x2<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vinserti64x2(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti64x2_ymm_k1z_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti64x2<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vinserti64x2(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti64x2_zmm_k1z_zmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti64x2<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vinserti64x2(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti64x2_ymm_k1z_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti64x2<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vinserti64x2(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti64x2_zmm_k1z_zmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti64x2<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vinserti64x2(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti64x2_ymm_k1z_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti64x2<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vinserti64x2(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti64x2_zmm_k1z_zmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti64x4<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vinserti64x4(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti64x4_zmm_k1z_zmm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti64x4<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vinserti64x4(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti64x4_zmm_k1z_zmm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti64x4<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vinserti64x4(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti64x4_zmm_k1z_zmm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti64x4<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vinserti64x4(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti64x4_zmm_k1z_zmm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vinsertps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vinsertps_xmm_xmm_xmmm32_imm8 } else { Code::EVEX_Vinsertps_xmm_xmm_xmmm32_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vinsertps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vinsertps_xmm_xmm_xmmm32_imm8 } else { Code::EVEX_Vinsertps_xmm_xmm_xmmm32_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vinsertps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vinsertps_xmm_xmm_xmmm32_imm8 } else { Code::EVEX_Vinsertps_xmm_xmm_xmmm32_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vinsertps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vinsertps_xmm_xmm_xmmm32_imm8 } else { Code::EVEX_Vinsertps_xmm_xmm_xmmm32_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVlddqu<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vlddqu(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vlddqu_xmm_m128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVlddqu<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vlddqu(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vlddqu_ymm_m256, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVldmxcsr<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vldmxcsr(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::VEX_Vldmxcsr_m32, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmaskmovdqu<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmaskmovdqu(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_vmaskmovdqu(self.bitness(), op0.register(), op1.register(), Register::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmaskmovpd<__AsmMemoryOperand, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmaskmovpd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vmaskmovpd_m128_xmm_xmm, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmaskmovpd<__AsmMemoryOperand, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmaskmovpd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vmaskmovpd_m256_ymm_ymm, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmaskmovpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmaskmovpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vmaskmovpd_xmm_xmm_m128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmaskmovpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmaskmovpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vmaskmovpd_ymm_ymm_m256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmaskmovps<__AsmMemoryOperand, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmaskmovps(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vmaskmovps_m128_xmm_xmm, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmaskmovps<__AsmMemoryOperand, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmaskmovps(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vmaskmovps_m256_ymm_ymm, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmaskmovps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmaskmovps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vmaskmovps_xmm_xmm_m128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmaskmovps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmaskmovps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vmaskmovps_ymm_ymm_m256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmaxpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmaxpd_xmm_xmm_xmmm128 } else { Code::EVEX_Vmaxpd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmaxpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmaxpd_ymm_ymm_ymmm256 } else { Code::EVEX_Vmaxpd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxpd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmaxpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmaxpd_zmm_k1z_zmm_zmmm512b64_sae, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vmaxpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vmaxpd_xmm_k1z_xmm_xmmm128b64
		} else if self.prefer_vex() {
			Code::VEX_Vmaxpd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vmaxpd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vmaxpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vmaxpd_ymm_k1z_ymm_ymmm256b64
		} else if self.prefer_vex() {
			Code::VEX_Vmaxpd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vmaxpd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxpd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmaxpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmaxpd_zmm_k1z_zmm_zmmm512b64_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmaxph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmaxph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmaxph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmaxph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmaxph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmaxph_zmm_k1z_zmm_zmmm512b16_sae, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmaxph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmaxph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmaxph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmaxph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmaxph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmaxph_zmm_k1z_zmm_zmmm512b16_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmaxps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmaxps_xmm_xmm_xmmm128 } else { Code::EVEX_Vmaxps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmaxps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmaxps_ymm_ymm_ymmm256 } else { Code::EVEX_Vmaxps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmaxps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmaxps_zmm_k1z_zmm_zmmm512b32_sae, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vmaxps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vmaxps_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vmaxps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vmaxps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vmaxps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vmaxps_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vmaxps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vmaxps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmaxps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmaxps_zmm_k1z_zmm_zmmm512b32_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmaxsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmaxsd_xmm_xmm_xmmm64 } else { Code::EVEX_Vmaxsd_xmm_k1z_xmm_xmmm64_sae };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmaxsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmaxsd_xmm_xmm_xmmm64 } else { Code::EVEX_Vmaxsd_xmm_k1z_xmm_xmmm64_sae };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxsh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmaxsh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmaxsh_xmm_k1z_xmm_xmmm16_sae, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxsh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmaxsh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmaxsh_xmm_k1z_xmm_xmmm16_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmaxss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmaxss_xmm_xmm_xmmm32 } else { Code::EVEX_Vmaxss_xmm_k1z_xmm_xmmm32_sae };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmaxss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmaxss_xmm_xmm_xmmm32 } else { Code::EVEX_Vmaxss_xmm_k1z_xmm_xmmm32_sae };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmcall for CodeAssembler {
	#[inline]
	fn vmcall(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Vmcall))
	}
}

#[rustfmt::skip]
impl CodeAsmVmclear<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmclear(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Vmclear_m64, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmfunc for CodeAssembler {
	#[inline]
	fn vmfunc(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Vmfunc))
	}
}

#[rustfmt::skip]
impl CodeAsmVmgexit for CodeAssembler {
	#[inline]
	fn vmgexit(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Vmgexit))
	}
}

#[rustfmt::skip]
impl CodeAsmVminpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vminpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vminpd_xmm_xmm_xmmm128 } else { Code::EVEX_Vminpd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVminpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vminpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vminpd_ymm_ymm_ymmm256 } else { Code::EVEX_Vminpd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVminpd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vminpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vminpd_zmm_k1z_zmm_zmmm512b64_sae, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVminpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vminpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vminpd_xmm_k1z_xmm_xmmm128b64
		} else if self.prefer_vex() {
			Code::VEX_Vminpd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vminpd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVminpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vminpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vminpd_ymm_k1z_ymm_ymmm256b64
		} else if self.prefer_vex() {
			Code::VEX_Vminpd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vminpd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVminpd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vminpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vminpd_zmm_k1z_zmm_zmmm512b64_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVminph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vminph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vminph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVminph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vminph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vminph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVminph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vminph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vminph_zmm_k1z_zmm_zmmm512b16_sae, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVminph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vminph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vminph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVminph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vminph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vminph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVminph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vminph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vminph_zmm_k1z_zmm_zmmm512b16_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVminps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vminps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vminps_xmm_xmm_xmmm128 } else { Code::EVEX_Vminps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVminps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vminps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vminps_ymm_ymm_ymmm256 } else { Code::EVEX_Vminps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVminps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vminps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vminps_zmm_k1z_zmm_zmmm512b32_sae, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVminps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vminps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vminps_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vminps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vminps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVminps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vminps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vminps_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vminps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vminps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVminps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vminps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vminps_zmm_k1z_zmm_zmmm512b32_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVminsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vminsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vminsd_xmm_xmm_xmmm64 } else { Code::EVEX_Vminsd_xmm_k1z_xmm_xmmm64_sae };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVminsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vminsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vminsd_xmm_xmm_xmmm64 } else { Code::EVEX_Vminsd_xmm_k1z_xmm_xmmm64_sae };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVminsh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vminsh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vminsh_xmm_k1z_xmm_xmmm16_sae, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVminsh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vminsh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vminsh_xmm_k1z_xmm_xmmm16_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVminss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vminss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vminss_xmm_xmm_xmmm32 } else { Code::EVEX_Vminss_xmm_k1z_xmm_xmmm32_sae };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVminss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vminss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vminss_xmm_xmm_xmmm32 } else { Code::EVEX_Vminss_xmm_k1z_xmm_xmmm32_sae };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmlaunch for CodeAssembler {
	#[inline]
	fn vmlaunch(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Vmlaunch))
	}
}

#[rustfmt::skip]
impl CodeAsmVmload for CodeAssembler {
	fn vmload(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Vmloadq
		} else if self.bitness() >= 32 {
			Code::Vmloadd
		} else {
			Code::Vmloadw
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmVmmcall for CodeAssembler {
	#[inline]
	fn vmmcall(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Vmmcall))
	}
}

#[rustfmt::skip]
impl CodeAsmVmovapd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovapd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovapd_xmm_xmmm128 } else { Code::EVEX_Vmovapd_xmm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovapd<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovapd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovapd_xmmm128_xmm } else { Code::EVEX_Vmovapd_xmmm128_k1z_xmm };
		self.add_instr_with_state(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovapd<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovapd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovapd_ymm_ymmm256 } else { Code::EVEX_Vmovapd_ymm_k1z_ymmm256 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovapd<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovapd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovapd_ymmm256_ymm } else { Code::EVEX_Vmovapd_ymmm256_k1z_ymm };
		self.add_instr_with_state(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovapd<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovapd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovapd_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovapd<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovapd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovapd_zmmm512_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovapd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovapd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovapd_xmm_xmmm128 } else { Code::EVEX_Vmovapd_xmm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovapd<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovapd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovapd_ymm_ymmm256 } else { Code::EVEX_Vmovapd_ymm_k1z_ymmm256 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovapd<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovapd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovapd_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovaps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovaps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovaps_xmm_xmmm128 } else { Code::EVEX_Vmovaps_xmm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovaps<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovaps(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovaps_xmmm128_xmm } else { Code::EVEX_Vmovaps_xmmm128_k1z_xmm };
		self.add_instr_with_state(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovaps<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovaps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovaps_ymm_ymmm256 } else { Code::EVEX_Vmovaps_ymm_k1z_ymmm256 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovaps<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovaps(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovaps_ymmm256_ymm } else { Code::EVEX_Vmovaps_ymmm256_k1z_ymm };
		self.add_instr_with_state(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovaps<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovaps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovaps_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovaps<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovaps(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovaps_zmmm512_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovaps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovaps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovaps_xmm_xmmm128 } else { Code::EVEX_Vmovaps_xmm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovaps<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovaps(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovaps_ymm_ymmm256 } else { Code::EVEX_Vmovaps_ymm_k1z_ymmm256 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovaps<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovaps(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovaps_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovd<__AsmRegisterXmm, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn vmovd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegister32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovd_xmm_rm32 } else { Code::EVEX_Vmovd_xmm_rm32 };
		self.add_instr(Instruction::with2(code, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovd<__AsmRegister32, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovd(&mut self, op0: __AsmRegister32, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovd_rm32_xmm } else { Code::EVEX_Vmovd_rm32_xmm };
		self.add_instr(Instruction::with2(code, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovd<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovd_rm32_xmm } else { Code::EVEX_Vmovd_rm32_xmm };
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovd_xmm_rm32 } else { Code::EVEX_Vmovd_xmm_rm32 };
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovddup<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovddup(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovddup_xmm_xmmm64 } else { Code::EVEX_Vmovddup_xmm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovddup<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovddup(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovddup_ymm_ymmm256 } else { Code::EVEX_Vmovddup_ymm_k1z_ymmm256 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovddup<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovddup(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovddup_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovddup<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovddup(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovddup_xmm_xmmm64 } else { Code::EVEX_Vmovddup_xmm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovddup<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovddup(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovddup_ymm_ymmm256 } else { Code::EVEX_Vmovddup_ymm_k1z_ymmm256 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovddup<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovddup(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovddup_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovdqa(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vmovdqa_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovdqa(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vmovdqa_xmmm128_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovdqa(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vmovdqa_ymm_ymmm256, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovdqa(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vmovdqa_ymmm256_ymm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqa(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vmovdqa_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqa(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vmovdqa_ymm_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa32<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovdqa32(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqa32_xmm_k1z_xmmm128, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa32<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovdqa32(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqa32_xmmm128_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa32<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovdqa32(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqa32_ymm_k1z_ymmm256, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa32<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovdqa32(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqa32_ymmm256_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa32<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovdqa32(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqa32_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa32<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovdqa32(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqa32_zmmm512_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa32<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqa32(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqa32_xmm_k1z_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa32<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqa32(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqa32_ymm_k1z_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa32<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqa32(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqa32_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa64<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovdqa64(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqa64_xmm_k1z_xmmm128, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa64<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovdqa64(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqa64_xmmm128_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa64<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovdqa64(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqa64_ymm_k1z_ymmm256, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa64<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovdqa64(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqa64_ymmm256_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa64<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovdqa64(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqa64_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa64<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovdqa64(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqa64_zmmm512_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa64<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqa64(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqa64_xmm_k1z_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa64<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqa64(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqa64_ymm_k1z_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa64<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqa64(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqa64_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovdqu(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vmovdqu_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovdqu(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vmovdqu_xmmm128_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovdqu(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vmovdqu_ymm_ymmm256, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovdqu(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vmovdqu_ymmm256_ymm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqu(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vmovdqu_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqu(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vmovdqu_ymm_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu16<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovdqu16(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu16_xmm_k1z_xmmm128, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu16<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovdqu16(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu16_xmmm128_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu16<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovdqu16(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu16_ymm_k1z_ymmm256, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu16<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovdqu16(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu16_ymmm256_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu16<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovdqu16(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu16_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu16<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovdqu16(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu16_zmmm512_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu16<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqu16(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu16_xmm_k1z_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu16<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqu16(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu16_ymm_k1z_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu16<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqu16(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu16_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu32<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovdqu32(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu32_xmm_k1z_xmmm128, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu32<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovdqu32(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu32_xmmm128_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu32<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovdqu32(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu32_ymm_k1z_ymmm256, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu32<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovdqu32(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu32_ymmm256_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu32<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovdqu32(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu32_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu32<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovdqu32(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu32_zmmm512_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu32<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqu32(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu32_xmm_k1z_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu32<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqu32(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu32_ymm_k1z_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu32<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqu32(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu32_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu64<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovdqu64(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu64_xmm_k1z_xmmm128, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu64<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovdqu64(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu64_xmmm128_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu64<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovdqu64(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu64_ymm_k1z_ymmm256, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu64<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovdqu64(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu64_ymmm256_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu64<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovdqu64(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu64_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu64<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovdqu64(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu64_zmmm512_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu64<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqu64(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu64_xmm_k1z_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu64<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqu64(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu64_ymm_k1z_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu64<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqu64(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu64_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu8<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovdqu8(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu8_xmm_k1z_xmmm128, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu8<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovdqu8(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu8_xmmm128_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu8<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovdqu8(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu8_ymm_k1z_ymmm256, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu8<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovdqu8(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu8_ymmm256_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu8<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovdqu8(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu8_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu8<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovdqu8(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu8_zmmm512_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu8<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqu8(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu8_xmm_k1z_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu8<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqu8(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu8_ymm_k1z_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu8<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqu8(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu8_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovhlps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovhlps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovhlps_xmm_xmm_xmm } else { Code::EVEX_Vmovhlps_xmm_xmm_xmm };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovhpd<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovhpd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovhpd_m64_xmm } else { Code::EVEX_Vmovhpd_m64_xmm };
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovhpd3<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovhpd_3(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovhpd_xmm_xmm_m64 } else { Code::EVEX_Vmovhpd_xmm_xmm_m64 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovhps<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovhps(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovhps_m64_xmm } else { Code::EVEX_Vmovhps_m64_xmm };
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovhps3<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovhps_3(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovhps_xmm_xmm_m64 } else { Code::EVEX_Vmovhps_xmm_xmm_m64 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovlhps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovlhps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovlhps_xmm_xmm_xmm } else { Code::EVEX_Vmovlhps_xmm_xmm_xmm };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovlpd<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovlpd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovlpd_m64_xmm } else { Code::EVEX_Vmovlpd_m64_xmm };
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovlpd3<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovlpd_3(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovlpd_xmm_xmm_m64 } else { Code::EVEX_Vmovlpd_xmm_xmm_m64 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovlps<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovlps(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovlps_m64_xmm } else { Code::EVEX_Vmovlps_m64_xmm };
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovlps3<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovlps_3(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovlps_xmm_xmm_m64 } else { Code::EVEX_Vmovlps_xmm_xmm_m64 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovmskpd<__AsmRegister32, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovmskpd(&mut self, op0: __AsmRegister32, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vmovmskpd_r32_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovmskpd<__AsmRegister64, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovmskpd(&mut self, op0: __AsmRegister64, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vmovmskpd_r64_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovmskpd<__AsmRegister32, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovmskpd(&mut self, op0: __AsmRegister32, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vmovmskpd_r32_ymm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovmskpd<__AsmRegister64, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovmskpd(&mut self, op0: __AsmRegister64, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vmovmskpd_r64_ymm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovmskps<__AsmRegister32, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovmskps(&mut self, op0: __AsmRegister32, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vmovmskps_r32_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovmskps<__AsmRegister64, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovmskps(&mut self, op0: __AsmRegister64, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vmovmskps_r64_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovmskps<__AsmRegister32, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovmskps(&mut self, op0: __AsmRegister32, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vmovmskps_r32_ymm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovmskps<__AsmRegister64, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovmskps(&mut self, op0: __AsmRegister64, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vmovmskps_r64_ymm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovntdq<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovntdq(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovntdq_m128_xmm } else { Code::EVEX_Vmovntdq_m128_xmm };
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovntdq<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovntdq(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovntdq_m256_ymm } else { Code::EVEX_Vmovntdq_m256_ymm };
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovntdq<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovntdq(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vmovntdq_m512_zmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovntdqa<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovntdqa(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovntdqa_xmm_m128 } else { Code::EVEX_Vmovntdqa_xmm_m128 };
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovntdqa<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovntdqa(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovntdqa_ymm_m256 } else { Code::EVEX_Vmovntdqa_ymm_m256 };
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovntdqa<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovntdqa(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vmovntdqa_zmm_m512, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovntpd<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovntpd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovntpd_m128_xmm } else { Code::EVEX_Vmovntpd_m128_xmm };
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovntpd<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovntpd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovntpd_m256_ymm } else { Code::EVEX_Vmovntpd_m256_ymm };
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovntpd<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovntpd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vmovntpd_m512_zmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovntps<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovntps(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovntps_m128_xmm } else { Code::EVEX_Vmovntps_m128_xmm };
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovntps<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovntps(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovntps_m256_ymm } else { Code::EVEX_Vmovntps_m256_ymm };
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovntps<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovntps(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vmovntps_m512_zmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovq<__AsmRegisterXmm, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn vmovq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegister64) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovq_xmm_rm64 } else { Code::EVEX_Vmovq_xmm_rm64 };
		self.add_instr(Instruction::with2(code, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovq<__AsmRegister64, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovq(&mut self, op0: __AsmRegister64, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovq_rm64_xmm } else { Code::EVEX_Vmovq_rm64_xmm };
		self.add_instr(Instruction::with2(code, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovq_xmm_xmmm64 } else { Code::EVEX_Vmovq_xmm_xmmm64 };
		self.add_instr(Instruction::with2(code, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovq<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovq(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovq_xmmm64_xmm } else { Code::EVEX_Vmovq_xmmm64_xmm };
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovq_xmm_xmmm64 } else { Code::EVEX_Vmovq_xmm_xmmm64 };
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovsd<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovsd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovsd_m64_xmm } else { Code::EVEX_Vmovsd_m64_k1_xmm };
		self.add_instr_with_state(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovsd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovsd_xmm_m64 } else { Code::EVEX_Vmovsd_xmm_k1z_m64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovsd3<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovsd_3(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovsd_xmm_xmm_xmm } else { Code::EVEX_Vmovsd_xmm_k1z_xmm_xmm };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovsh<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovsh(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovsh_m16_k1_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovsh<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovsh(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovsh_xmm_k1z_m16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovsh3<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovsh_3(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmovsh_xmm_k1z_xmm_xmm, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovshdup<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovshdup(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovshdup_xmm_xmmm128 } else { Code::EVEX_Vmovshdup_xmm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovshdup<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovshdup(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovshdup_ymm_ymmm256 } else { Code::EVEX_Vmovshdup_ymm_k1z_ymmm256 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovshdup<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovshdup(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovshdup_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovshdup<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovshdup(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovshdup_xmm_xmmm128 } else { Code::EVEX_Vmovshdup_xmm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovshdup<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovshdup(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovshdup_ymm_ymmm256 } else { Code::EVEX_Vmovshdup_ymm_k1z_ymmm256 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovshdup<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovshdup(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovshdup_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovsldup<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovsldup(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovsldup_xmm_xmmm128 } else { Code::EVEX_Vmovsldup_xmm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovsldup<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovsldup(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovsldup_ymm_ymmm256 } else { Code::EVEX_Vmovsldup_ymm_k1z_ymmm256 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovsldup<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovsldup(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovsldup_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovsldup<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovsldup(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovsldup_xmm_xmmm128 } else { Code::EVEX_Vmovsldup_xmm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovsldup<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovsldup(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovsldup_ymm_ymmm256 } else { Code::EVEX_Vmovsldup_ymm_k1z_ymmm256 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovsldup<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovsldup(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovsldup_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovss<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovss(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovss_m32_xmm } else { Code::EVEX_Vmovss_m32_k1_xmm };
		self.add_instr_with_state(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovss<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovss(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovss_xmm_m32 } else { Code::EVEX_Vmovss_xmm_k1z_m32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovss3<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovss_3(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovss_xmm_xmm_xmm } else { Code::EVEX_Vmovss_xmm_k1z_xmm_xmm };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovupd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovupd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovupd_xmm_xmmm128 } else { Code::EVEX_Vmovupd_xmm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovupd<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovupd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovupd_xmmm128_xmm } else { Code::EVEX_Vmovupd_xmmm128_k1z_xmm };
		self.add_instr_with_state(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovupd<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovupd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovupd_ymm_ymmm256 } else { Code::EVEX_Vmovupd_ymm_k1z_ymmm256 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovupd<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovupd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovupd_ymmm256_ymm } else { Code::EVEX_Vmovupd_ymmm256_k1z_ymm };
		self.add_instr_with_state(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovupd<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovupd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovupd_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovupd<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovupd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovupd_zmmm512_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovupd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovupd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovupd_xmm_xmmm128 } else { Code::EVEX_Vmovupd_xmm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovupd<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovupd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovupd_ymm_ymmm256 } else { Code::EVEX_Vmovupd_ymm_k1z_ymmm256 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovupd<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovupd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovupd_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovups<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovups(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovups_xmm_xmmm128 } else { Code::EVEX_Vmovups_xmm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovups<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovups(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovups_xmmm128_xmm } else { Code::EVEX_Vmovups_xmmm128_k1z_xmm };
		self.add_instr_with_state(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovups<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovups(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovups_ymm_ymmm256 } else { Code::EVEX_Vmovups_ymm_k1z_ymmm256 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovups<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovups(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovups_ymmm256_ymm } else { Code::EVEX_Vmovups_ymmm256_k1z_ymm };
		self.add_instr_with_state(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovups<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovups(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovups_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovups<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovups(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovups_zmmm512_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovups<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovups(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovups_xmm_xmmm128 } else { Code::EVEX_Vmovups_xmm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovups<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovups(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmovups_ymm_ymmm256 } else { Code::EVEX_Vmovups_ymm_k1z_ymmm256 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovups<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovups(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovups_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovw<__AsmRegisterXmm, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn vmovw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vmovw_xmm_r32m16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovw<__AsmRegisterXmm, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn vmovw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vmovw_xmm_r64m16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovw<__AsmRegister32, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovw(&mut self, op0: __AsmRegister32, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vmovw_r32m16_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovw<__AsmRegister64, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovw(&mut self, op0: __AsmRegister64, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vmovw_r64m16_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovw<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovw(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vmovw_r32m16_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vmovw_xmm_r32m16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmpsadbw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vmpsadbw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vmpsadbw_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmpsadbw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vmpsadbw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vmpsadbw_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmpsadbw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vmpsadbw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vmpsadbw_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmpsadbw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vmpsadbw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vmpsadbw_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmpsadbw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vmpsadbw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vmpsadbw_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmpsadbw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vmpsadbw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vmpsadbw_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmpsadbw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vmpsadbw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vmpsadbw_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmpsadbw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vmpsadbw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vmpsadbw_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmptrld<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmptrld(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Vmptrld_m64, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmptrst<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmptrst(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Vmptrst_m64, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmread<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn vmread(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Vmread_rm32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmread<__AsmMemoryOperand, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn vmread(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Vmread_rm32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmread<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn vmread(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Vmread_rm64_r64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmread<__AsmMemoryOperand, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn vmread(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Vmread_rm64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmresume for CodeAssembler {
	#[inline]
	fn vmresume(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Vmresume))
	}
}

#[rustfmt::skip]
impl CodeAsmVmrun for CodeAssembler {
	fn vmrun(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Vmrunq
		} else if self.bitness() >= 32 {
			Code::Vmrund
		} else {
			Code::Vmrunw
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmVmsave for CodeAssembler {
	fn vmsave(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Vmsaveq
		} else if self.bitness() >= 32 {
			Code::Vmsaved
		} else {
			Code::Vmsavew
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmVmulpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmulpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmulpd_xmm_xmm_xmmm128 } else { Code::EVEX_Vmulpd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmulpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmulpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmulpd_ymm_ymm_ymmm256 } else { Code::EVEX_Vmulpd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmulpd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmulpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmulpd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmulpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vmulpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vmulpd_xmm_k1z_xmm_xmmm128b64
		} else if self.prefer_vex() {
			Code::VEX_Vmulpd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vmulpd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmulpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vmulpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vmulpd_ymm_k1z_ymm_ymmm256b64
		} else if self.prefer_vex() {
			Code::VEX_Vmulpd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vmulpd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmulpd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmulpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmulpd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmulph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmulph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmulph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmulph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmulph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmulph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmulph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmulph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmulph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmulph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmulph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmulph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmulph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmulph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmulph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmulph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmulph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmulph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmulps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmulps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmulps_xmm_xmm_xmmm128 } else { Code::EVEX_Vmulps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmulps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmulps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmulps_ymm_ymm_ymmm256 } else { Code::EVEX_Vmulps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmulps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmulps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmulps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmulps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vmulps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vmulps_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vmulps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vmulps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmulps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vmulps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vmulps_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vmulps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vmulps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmulps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmulps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmulps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmulsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmulsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmulsd_xmm_xmm_xmmm64 } else { Code::EVEX_Vmulsd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmulsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmulsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmulsd_xmm_xmm_xmmm64 } else { Code::EVEX_Vmulsd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmulsh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmulsh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmulsh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmulsh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmulsh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmulsh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmulss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmulss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmulss_xmm_xmm_xmmm32 } else { Code::EVEX_Vmulss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmulss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmulss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vmulss_xmm_xmm_xmmm32 } else { Code::EVEX_Vmulss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmwrite<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn vmwrite(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Vmwrite_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmwrite<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn vmwrite(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Vmwrite_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmwrite<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmwrite(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Vmwrite_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmwrite<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmwrite(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Vmwrite_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmxoff for CodeAssembler {
	#[inline]
	fn vmxoff(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Vmxoff))
	}
}

#[rustfmt::skip]
impl CodeAsmVmxon<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmxon(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Vmxon_m64, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVorpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vorpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vorpd_xmm_xmm_xmmm128 } else { Code::EVEX_Vorpd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVorpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vorpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vorpd_ymm_ymm_ymmm256 } else { Code::EVEX_Vorpd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVorpd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vorpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vorpd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVorpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vorpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vorpd_xmm_k1z_xmm_xmmm128b64
		} else if self.prefer_vex() {
			Code::VEX_Vorpd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vorpd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVorpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vorpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vorpd_ymm_k1z_ymm_ymmm256b64
		} else if self.prefer_vex() {
			Code::VEX_Vorpd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vorpd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVorpd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vorpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vorpd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVorps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vorps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vorps_xmm_xmm_xmmm128 } else { Code::EVEX_Vorps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVorps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vorps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vorps_ymm_ymm_ymmm256 } else { Code::EVEX_Vorps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVorps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vorps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vorps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVorps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vorps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vorps_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vorps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vorps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVorps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vorps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vorps_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vorps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vorps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVorps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vorps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vorps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVp2intersectd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vp2intersectd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vp2intersectd_kp1_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVp2intersectd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vp2intersectd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vp2intersectd_kp1_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVp2intersectd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vp2intersectd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vp2intersectd_kp1_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVp2intersectd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vp2intersectd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vp2intersectd_kp1_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVp2intersectd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vp2intersectd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vp2intersectd_kp1_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVp2intersectd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vp2intersectd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vp2intersectd_kp1_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVp2intersectq<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vp2intersectq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vp2intersectq_kp1_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVp2intersectq<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vp2intersectq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vp2intersectq_kp1_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVp2intersectq<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vp2intersectq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vp2intersectq_kp1_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVp2intersectq<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vp2intersectq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vp2intersectq_kp1_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVp2intersectq<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vp2intersectq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vp2intersectq_kp1_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVp2intersectq<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vp2intersectq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vp2intersectq_kp1_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVp4dpwssd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vp4dpwssd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vp4dpwssd_zmm_k1z_zmmp3_m128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVp4dpwssds<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vp4dpwssds(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vp4dpwssds_zmm_k1z_zmmp3_m128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsb<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpabsb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpabsb_xmm_xmmm128 } else { Code::EVEX_Vpabsb_xmm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsb<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpabsb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpabsb_ymm_ymmm256 } else { Code::EVEX_Vpabsb_ymm_k1z_ymmm256 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsb<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpabsb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpabsb_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsb<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpabsb(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpabsb_xmm_xmmm128 } else { Code::EVEX_Vpabsb_xmm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsb<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpabsb(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpabsb_ymm_ymmm256 } else { Code::EVEX_Vpabsb_ymm_k1z_ymmm256 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsb<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpabsb(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpabsb_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpabsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpabsd_xmm_xmmm128 } else { Code::EVEX_Vpabsd_xmm_k1z_xmmm128b32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsd<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpabsd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpabsd_ymm_ymmm256 } else { Code::EVEX_Vpabsd_ymm_k1z_ymmm256b32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsd<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpabsd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpabsd_zmm_k1z_zmmm512b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpabsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vpabsd_xmm_k1z_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vpabsd_xmm_xmmm128
		} else {
			Code::EVEX_Vpabsd_xmm_k1z_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsd<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpabsd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vpabsd_ymm_k1z_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vpabsd_ymm_ymmm256
		} else {
			Code::EVEX_Vpabsd_ymm_k1z_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsd<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpabsd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpabsd_zmm_k1z_zmmm512b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpabsq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpabsq_xmm_k1z_xmmm128b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsq<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpabsq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpabsq_ymm_k1z_ymmm256b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsq<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpabsq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpabsq_zmm_k1z_zmmm512b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpabsq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpabsq_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsq<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpabsq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpabsq_ymm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsq<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpabsq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpabsq_zmm_k1z_zmmm512b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpabsw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpabsw_xmm_xmmm128 } else { Code::EVEX_Vpabsw_xmm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsw<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpabsw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpabsw_ymm_ymmm256 } else { Code::EVEX_Vpabsw_ymm_k1z_ymmm256 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsw<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpabsw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpabsw_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpabsw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpabsw_xmm_xmmm128 } else { Code::EVEX_Vpabsw_xmm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsw<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpabsw(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpabsw_ymm_ymmm256 } else { Code::EVEX_Vpabsw_ymm_k1z_ymmm256 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsw<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpabsw(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpabsw_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpackssdw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpackssdw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpackssdw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpackssdw_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpackssdw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpackssdw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpackssdw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpackssdw_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpackssdw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpackssdw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpackssdw_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpackssdw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpackssdw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpackssdw_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vpackssdw_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpackssdw_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpackssdw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpackssdw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpackssdw_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vpackssdw_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpackssdw_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpackssdw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpackssdw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpackssdw_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpacksswb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpacksswb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpacksswb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpacksswb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpacksswb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpacksswb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpacksswb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpacksswb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpacksswb<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpacksswb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpacksswb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpacksswb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpacksswb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpacksswb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpacksswb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpacksswb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpacksswb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpacksswb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpacksswb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpacksswb<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpacksswb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpacksswb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpackusdw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpackusdw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpackusdw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpackusdw_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpackusdw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpackusdw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpackusdw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpackusdw_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpackusdw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpackusdw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpackusdw_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpackusdw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpackusdw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpackusdw_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vpackusdw_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpackusdw_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpackusdw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpackusdw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpackusdw_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vpackusdw_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpackusdw_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpackusdw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpackusdw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpackusdw_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpackuswb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpackuswb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpackuswb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpackuswb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpackuswb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpackuswb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpackuswb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpackuswb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpackuswb<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpackuswb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpackuswb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpackuswb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpackuswb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpackuswb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpackuswb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpackuswb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpackuswb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpackuswb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpackuswb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpackuswb<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpackuswb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpackuswb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpaddb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpaddb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpaddb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpaddb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpaddb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpaddb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddb<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpaddb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpaddb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpaddb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpaddb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpaddb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpaddb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpaddb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpaddb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddb<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpaddb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpaddb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpaddd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpaddd_xmm_xmm_xmmm128 } else { Code::EVEX_Vpaddd_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpaddd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpaddd_ymm_ymm_ymmm256 } else { Code::EVEX_Vpaddd_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpaddd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpaddd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpaddd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpaddd_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vpaddd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpaddd_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpaddd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpaddd_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vpaddd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpaddd_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpaddd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpaddd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpaddq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpaddq_xmm_xmm_xmmm128 } else { Code::EVEX_Vpaddq_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpaddq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpaddq_ymm_ymm_ymmm256 } else { Code::EVEX_Vpaddq_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpaddq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpaddq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpaddq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpaddq_xmm_k1z_xmm_xmmm128b64
		} else if self.prefer_vex() {
			Code::VEX_Vpaddq_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpaddq_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpaddq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpaddq_ymm_k1z_ymm_ymmm256b64
		} else if self.prefer_vex() {
			Code::VEX_Vpaddq_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpaddq_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpaddq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpaddq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddsb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpaddsb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpaddsb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpaddsb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddsb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpaddsb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpaddsb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpaddsb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddsb<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpaddsb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpaddsb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddsb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpaddsb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpaddsb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpaddsb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddsb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpaddsb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpaddsb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpaddsb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddsb<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpaddsb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpaddsb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddsw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpaddsw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpaddsw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpaddsw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddsw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpaddsw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpaddsw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpaddsw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddsw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpaddsw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpaddsw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddsw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpaddsw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpaddsw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpaddsw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddsw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpaddsw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpaddsw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpaddsw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddsw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpaddsw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpaddsw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddusb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpaddusb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpaddusb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpaddusb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddusb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpaddusb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpaddusb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpaddusb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddusb<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpaddusb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpaddusb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddusb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpaddusb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpaddusb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpaddusb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddusb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpaddusb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpaddusb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpaddusb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddusb<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpaddusb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpaddusb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddusw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpaddusw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpaddusw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpaddusw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddusw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpaddusw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpaddusw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpaddusw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddusw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpaddusw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpaddusw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddusw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpaddusw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpaddusw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpaddusw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddusw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpaddusw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpaddusw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpaddusw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddusw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpaddusw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpaddusw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpaddw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpaddw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpaddw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpaddw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpaddw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpaddw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpaddw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpaddw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpaddw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpaddw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpaddw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpaddw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpaddw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpaddw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpaddw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpaddw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpalignr<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpalignr(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpalignr_xmm_xmm_xmmm128_imm8 } else { Code::EVEX_Vpalignr_xmm_k1z_xmm_xmmm128_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpalignr<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpalignr(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpalignr_ymm_ymm_ymmm256_imm8 } else { Code::EVEX_Vpalignr_ymm_k1z_ymm_ymmm256_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpalignr<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpalignr(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpalignr_zmm_k1z_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpalignr<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpalignr(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpalignr_xmm_xmm_xmmm128_imm8 } else { Code::EVEX_Vpalignr_xmm_k1z_xmm_xmmm128_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpalignr<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpalignr(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpalignr_ymm_ymm_ymmm256_imm8 } else { Code::EVEX_Vpalignr_ymm_k1z_ymm_ymmm256_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpalignr<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpalignr(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpalignr_zmm_k1z_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpalignr<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpalignr(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpalignr_xmm_xmm_xmmm128_imm8 } else { Code::EVEX_Vpalignr_xmm_k1z_xmm_xmmm128_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpalignr<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpalignr(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpalignr_ymm_ymm_ymmm256_imm8 } else { Code::EVEX_Vpalignr_ymm_k1z_ymm_ymmm256_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpalignr<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpalignr(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpalignr_zmm_k1z_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpalignr<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpalignr(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpalignr_xmm_xmm_xmmm128_imm8 } else { Code::EVEX_Vpalignr_xmm_k1z_xmm_xmmm128_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpalignr<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpalignr(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpalignr_ymm_ymm_ymmm256_imm8 } else { Code::EVEX_Vpalignr_ymm_k1z_ymm_ymmm256_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpalignr<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpalignr(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpalignr_zmm_k1z_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpand<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpand(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpand_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpand<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpand(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpand_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpand<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpand(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpand_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpand<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpand(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpand_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpandd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpandd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandd_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpandd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpandd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandd_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpandd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpandd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpandd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpandd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandd_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpandd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpandd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandd_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpandd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpandd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpandn<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpandn(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpandn_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpandn<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpandn(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpandn_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpandn<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpandn(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpandn_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpandn<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpandn(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpandn_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpandnd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpandnd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandnd_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpandnd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpandnd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandnd_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpandnd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpandnd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandnd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpandnd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpandnd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandnd_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpandnd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpandnd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandnd_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpandnd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpandnd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandnd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpandnq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpandnq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandnq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpandnq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpandnq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandnq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpandnq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpandnq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandnq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpandnq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpandnq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandnq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpandnq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpandnq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandnq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpandnq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpandnq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandnq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpandq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpandq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpandq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpandq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpandq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpandq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpandq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpandq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpandq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpandq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpandq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpandq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpavgb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpavgb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpavgb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpavgb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpavgb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpavgb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpavgb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpavgb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpavgb<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpavgb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpavgb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpavgb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpavgb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpavgb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpavgb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpavgb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpavgb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpavgb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpavgb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpavgb<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpavgb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpavgb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpavgw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpavgw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpavgw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpavgw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpavgw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpavgw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpavgw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpavgw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpavgw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpavgw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpavgw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpavgw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpavgw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpavgw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpavgw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpavgw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpavgw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpavgw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpavgw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpavgw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpavgw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpavgw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpblendd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vpblendd_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpblendd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vpblendd_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpblendd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vpblendd_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpblendd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vpblendd_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpblendd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vpblendd_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpblendd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vpblendd_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpblendd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vpblendd_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpblendd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vpblendd_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpblendmb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmb_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpblendmb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmb_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmb<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpblendmb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpblendmb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmb_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpblendmb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmb_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmb<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpblendmb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpblendmd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmd_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpblendmd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmd_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpblendmd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpblendmd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmd_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpblendmd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmd_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpblendmd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpblendmq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpblendmq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpblendmq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpblendmq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpblendmq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpblendmq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpblendmw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmw_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpblendmw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmw_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpblendmw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpblendmw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmw_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpblendmw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmw_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpblendmw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendvb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpblendvb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vpblendvb_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendvb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpblendvb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vpblendvb_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendvb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpblendvb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vpblendvb_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendvb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpblendvb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vpblendvb_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpblendw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vpblendw_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpblendw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vpblendw_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpblendw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vpblendw_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpblendw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vpblendw_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpblendw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vpblendw_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpblendw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vpblendw_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpblendw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vpblendw_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpblendw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vpblendw_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastb<__AsmRegisterXmm, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn vpbroadcastb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpbroadcastb_xmm_k1z_r32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastb<__AsmRegisterYmm, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn vpbroadcastb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpbroadcastb_ymm_k1z_r32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastb<__AsmRegisterZmm, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn vpbroadcastb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpbroadcastb_zmm_k1z_r32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastb<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpbroadcastb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpbroadcastb_xmm_xmmm8 } else { Code::EVEX_Vpbroadcastb_xmm_k1z_xmmm8 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastb<__AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpbroadcastb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpbroadcastb_ymm_xmmm8 } else { Code::EVEX_Vpbroadcastb_ymm_k1z_xmmm8 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastb<__AsmRegisterZmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpbroadcastb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpbroadcastb_zmm_k1z_xmmm8, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastb<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpbroadcastb(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpbroadcastb_xmm_xmmm8 } else { Code::EVEX_Vpbroadcastb_xmm_k1z_xmmm8 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastb<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpbroadcastb(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpbroadcastb_ymm_xmmm8 } else { Code::EVEX_Vpbroadcastb_ymm_k1z_xmmm8 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastb<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpbroadcastb(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpbroadcastb_zmm_k1z_xmmm8, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastd<__AsmRegisterXmm, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn vpbroadcastd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpbroadcastd_xmm_k1z_r32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastd<__AsmRegisterYmm, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn vpbroadcastd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpbroadcastd_ymm_k1z_r32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastd<__AsmRegisterZmm, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn vpbroadcastd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpbroadcastd_zmm_k1z_r32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpbroadcastd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpbroadcastd_xmm_xmmm32 } else { Code::EVEX_Vpbroadcastd_xmm_k1z_xmmm32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastd<__AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpbroadcastd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpbroadcastd_ymm_xmmm32 } else { Code::EVEX_Vpbroadcastd_ymm_k1z_xmmm32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastd<__AsmRegisterZmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpbroadcastd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpbroadcastd_zmm_k1z_xmmm32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpbroadcastd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpbroadcastd_xmm_xmmm32 } else { Code::EVEX_Vpbroadcastd_xmm_k1z_xmmm32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastd<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpbroadcastd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpbroadcastd_ymm_xmmm32 } else { Code::EVEX_Vpbroadcastd_ymm_k1z_xmmm32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastd<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpbroadcastd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpbroadcastd_zmm_k1z_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastmb2q<__AsmRegisterXmm, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn vpbroadcastmb2q(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpbroadcastmb2q_xmm_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastmb2q<__AsmRegisterYmm, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn vpbroadcastmb2q(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpbroadcastmb2q_ymm_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastmb2q<__AsmRegisterZmm, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn vpbroadcastmb2q(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpbroadcastmb2q_zmm_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastmw2d<__AsmRegisterXmm, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn vpbroadcastmw2d(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpbroadcastmw2d_xmm_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastmw2d<__AsmRegisterYmm, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn vpbroadcastmw2d(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpbroadcastmw2d_ymm_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastmw2d<__AsmRegisterZmm, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn vpbroadcastmw2d(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpbroadcastmw2d_zmm_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastq<__AsmRegisterXmm, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn vpbroadcastq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpbroadcastq_xmm_k1z_r64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastq<__AsmRegisterYmm, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn vpbroadcastq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpbroadcastq_ymm_k1z_r64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastq<__AsmRegisterZmm, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn vpbroadcastq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpbroadcastq_zmm_k1z_r64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpbroadcastq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpbroadcastq_xmm_xmmm64 } else { Code::EVEX_Vpbroadcastq_xmm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastq<__AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpbroadcastq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpbroadcastq_ymm_xmmm64 } else { Code::EVEX_Vpbroadcastq_ymm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastq<__AsmRegisterZmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpbroadcastq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpbroadcastq_zmm_k1z_xmmm64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpbroadcastq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpbroadcastq_xmm_xmmm64 } else { Code::EVEX_Vpbroadcastq_xmm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastq<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpbroadcastq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpbroadcastq_ymm_xmmm64 } else { Code::EVEX_Vpbroadcastq_ymm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastq<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpbroadcastq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpbroadcastq_zmm_k1z_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastw<__AsmRegisterXmm, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn vpbroadcastw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpbroadcastw_xmm_k1z_r32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastw<__AsmRegisterYmm, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn vpbroadcastw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpbroadcastw_ymm_k1z_r32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastw<__AsmRegisterZmm, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn vpbroadcastw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpbroadcastw_zmm_k1z_r32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpbroadcastw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpbroadcastw_xmm_xmmm16 } else { Code::EVEX_Vpbroadcastw_xmm_k1z_xmmm16 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastw<__AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpbroadcastw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpbroadcastw_ymm_xmmm16 } else { Code::EVEX_Vpbroadcastw_ymm_k1z_xmmm16 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastw<__AsmRegisterZmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpbroadcastw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpbroadcastw_zmm_k1z_xmmm16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpbroadcastw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpbroadcastw_xmm_xmmm16 } else { Code::EVEX_Vpbroadcastw_xmm_k1z_xmmm16 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastw<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpbroadcastw(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpbroadcastw_ymm_xmmm16 } else { Code::EVEX_Vpbroadcastw_ymm_k1z_xmmm16 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastw<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpbroadcastw(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpbroadcastw_zmm_k1z_xmmm16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulhqhqdq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpclmulhqhqdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpclmulqdq(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulhqhqdq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpclmulhqhqdq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpclmulqdq(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulhqhqdq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpclmulhqhqdq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpclmulqdq(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulhqhqdq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpclmulhqhqdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpclmulqdq(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulhqhqdq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpclmulhqhqdq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpclmulqdq(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulhqhqdq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpclmulhqhqdq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpclmulqdq(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulhqlqdq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpclmulhqlqdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpclmulqdq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulhqlqdq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpclmulhqlqdq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpclmulqdq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulhqlqdq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpclmulhqlqdq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpclmulqdq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulhqlqdq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpclmulhqlqdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpclmulqdq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulhqlqdq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpclmulhqlqdq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpclmulqdq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulhqlqdq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpclmulhqlqdq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpclmulqdq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmullqhqdq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpclmullqhqdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpclmulqdq(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmullqhqdq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpclmullqhqdq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpclmulqdq(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmullqhqdq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpclmullqhqdq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpclmulqdq(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmullqhqdq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpclmullqhqdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpclmulqdq(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmullqhqdq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpclmullqhqdq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpclmulqdq(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmullqhqdq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpclmullqhqdq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpclmulqdq(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmullqlqdq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpclmullqlqdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpclmulqdq(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmullqlqdq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpclmullqlqdq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpclmulqdq(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmullqlqdq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpclmullqlqdq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpclmulqdq(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmullqlqdq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpclmullqlqdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpclmulqdq(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmullqlqdq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpclmullqlqdq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpclmulqdq(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmullqlqdq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpclmullqlqdq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpclmulqdq(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulqdq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpclmulqdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpclmulqdq_xmm_xmm_xmmm128_imm8 } else { Code::EVEX_Vpclmulqdq_xmm_xmm_xmmm128_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulqdq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpclmulqdq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpclmulqdq_ymm_ymm_ymmm256_imm8 } else { Code::EVEX_Vpclmulqdq_ymm_ymm_ymmm256_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulqdq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpclmulqdq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::EVEX_Vpclmulqdq_zmm_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulqdq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpclmulqdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpclmulqdq_xmm_xmm_xmmm128_imm8 } else { Code::EVEX_Vpclmulqdq_xmm_xmm_xmmm128_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulqdq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpclmulqdq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpclmulqdq_ymm_ymm_ymmm256_imm8 } else { Code::EVEX_Vpclmulqdq_ymm_ymm_ymmm256_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulqdq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpclmulqdq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::EVEX_Vpclmulqdq_zmm_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulqdq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpclmulqdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpclmulqdq_xmm_xmm_xmmm128_imm8 } else { Code::EVEX_Vpclmulqdq_xmm_xmm_xmmm128_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulqdq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpclmulqdq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpclmulqdq_ymm_ymm_ymmm256_imm8 } else { Code::EVEX_Vpclmulqdq_ymm_ymm_ymmm256_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulqdq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpclmulqdq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::EVEX_Vpclmulqdq_zmm_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulqdq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpclmulqdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpclmulqdq_xmm_xmm_xmmm128_imm8 } else { Code::EVEX_Vpclmulqdq_xmm_xmm_xmmm128_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulqdq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpclmulqdq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpclmulqdq_ymm_ymm_ymmm256_imm8 } else { Code::EVEX_Vpclmulqdq_ymm_ymm_ymmm256_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulqdq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpclmulqdq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::EVEX_Vpclmulqdq_zmm_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmov<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmov(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcmov_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmov<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmov(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcmov_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmov<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmov(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcmov_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmov<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmov(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcmov_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmov<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmov(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcmov_xmm_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmov<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmov(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcmov_ymm_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpb_kr_k1_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpb_kr_k1_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpb_kr_k1_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpb_kr_k1_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpb_kr_k1_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpb_kr_k1_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpb_kr_k1_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpb_kr_k1_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpb_kr_k1_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpb_kr_k1_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpb_kr_k1_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpb_kr_k1_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpd_kr_k1_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpd_kr_k1_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpd_kr_k1_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpd_kr_k1_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpd_kr_k1_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpd_kr_k1_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpd_kr_k1_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpd_kr_k1_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpd_kr_k1_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpd_kr_k1_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpd_kr_k1_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpd_kr_k1_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqb<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpeqb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqb_kr_k1_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpeqb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpeqb_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqb<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpeqb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqb_kr_k1_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpeqb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpeqb_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqb<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpeqb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqb_kr_k1_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqb<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpeqb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqb_kr_k1_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpeqb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpeqb_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqb<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpeqb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqb_kr_k1_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpeqb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpeqb_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqb<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpeqb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqb_kr_k1_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpeqd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqd_kr_k1_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpeqd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpeqd_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpeqd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqd_kr_k1_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpeqd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpeqd_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpeqd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqd_kr_k1_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpeqd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqd_kr_k1_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpeqd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpeqd_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpeqd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqd_kr_k1_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpeqd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpeqd_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpeqd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqd_kr_k1_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqq<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpeqq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqq_kr_k1_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpeqq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpeqq_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqq<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpeqq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqq_kr_k1_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpeqq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpeqq_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqq<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpeqq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqq_kr_k1_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqq<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpeqq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqq_kr_k1_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpeqq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpeqq_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqq<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpeqq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqq_kr_k1_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpeqq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpeqq_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqq<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpeqq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqq_kr_k1_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequb<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpequb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpub(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequb<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpequb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpub(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequb<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpequb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpub(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequb<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpequb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequb<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpequb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequb<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpequb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpequd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpud(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpequd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpud(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpequd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpud(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpequd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpequd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpequd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequq<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpequq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpuq(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequq<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpequq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpuq(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequq<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpequq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpuq(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequq<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpequq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequq<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpequq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequq<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpequq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequw<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpequw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpuw(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequw<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpequw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpuw(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequw<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpequw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpuw(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequw<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpequw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequw<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpequw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequw<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpequw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqw<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpeqw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqw_kr_k1_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpeqw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpeqw_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqw<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpeqw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqw_kr_k1_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpeqw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpeqw_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqw<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpeqw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqw_kr_k1_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqw<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpeqw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqw_kr_k1_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpeqw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpeqw_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqw<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpeqw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqw_kr_k1_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpeqw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpeqw_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqw<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpeqw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqw_kr_k1_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpestri<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpestri(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpestri_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpestri<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpestri(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpestri_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpestri<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpestri(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpestri_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpestri<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpestri(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpestri_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpestri64<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpestri64(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpestri64_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpestri64<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpestri64(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpestri64_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpestri64<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpestri64(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpestri64_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpestri64<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpestri64(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpestri64_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpestrm<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpestrm(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpestrm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpestrm<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpestrm(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpestrm_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpestrm<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpestrm(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpestrm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpestrm<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpestrm(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpestrm_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpestrm64<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpestrm64(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpestrm64_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpestrm64<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpestrm64(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpestrm64_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpestrm64<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpestrm64(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpestrm64_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpestrm64<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpestrm64(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpestrm64_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseb<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalseb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpb(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseb<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalseb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpb(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseb<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalseb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpb(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseb<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalseb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseb<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalseb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseb<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalseb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalsed<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalsed(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalsed<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalsed(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalsed<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalsed(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalsed<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalsed(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalsed<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalsed(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalsed<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalsed(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseq<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalseq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpq(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseq<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalseq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpq(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseq<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalseq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpq(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseq<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalseq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseq<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalseq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseq<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalseq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseub<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalseub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpub(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseub<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalseub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpub(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseub<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalseub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpub(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseub<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalseub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseub<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalseub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseub<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalseub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseud<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalseud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpud(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseud<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalseud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpud(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseud<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalseud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpud(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseud<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalseud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseud<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalseud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseud<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalseud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseuq<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalseuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpuq(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseuq<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalseuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpuq(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseuq<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalseuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpuq(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseuq<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalseuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseuq<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalseuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseuq<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalseuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseuw<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalseuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpuw(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseuw<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalseuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpuw(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseuw<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalseuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpuw(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseuw<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalseuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseuw<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalseuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseuw<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalseuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalsew<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalsew(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpw(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalsew<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalsew(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpw(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalsew<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalsew(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpw(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalsew<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalsew(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalsew<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalsew(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalsew<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalsew(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtb<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpgtb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtb_kr_k1_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpgtb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpgtb_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtb<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpgtb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtb_kr_k1_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpgtb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpgtb_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtb<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpgtb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtb_kr_k1_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtb<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpgtb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtb_kr_k1_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpgtb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpgtb_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtb<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpgtb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtb_kr_k1_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpgtb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpgtb_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtb<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpgtb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtb_kr_k1_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpgtd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtd_kr_k1_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpgtd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpgtd_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpgtd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtd_kr_k1_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpgtd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpgtd_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpgtd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtd_kr_k1_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpgtd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtd_kr_k1_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpgtd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpgtd_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpgtd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtd_kr_k1_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpgtd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpgtd_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpgtd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtd_kr_k1_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtq<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpgtq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtq_kr_k1_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpgtq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpgtq_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtq<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpgtq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtq_kr_k1_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpgtq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpgtq_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtq<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpgtq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtq_kr_k1_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtq<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpgtq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtq_kr_k1_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpgtq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpgtq_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtq<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpgtq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtq_kr_k1_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpgtq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpgtq_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtq<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpgtq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtq_kr_k1_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtw<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpgtw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtw_kr_k1_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpgtw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpgtw_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtw<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpgtw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtw_kr_k1_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpgtw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpgtw_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtw<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpgtw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtw_kr_k1_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtw<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpgtw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtw_kr_k1_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpgtw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpgtw_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtw<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpgtw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtw_kr_k1_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpgtw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpgtw_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtw<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpgtw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtw_kr_k1_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpistri<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpistri(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpistri_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpistri<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpistri(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpistri_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpistri<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpistri(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpistri_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpistri<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpistri(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpistri_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpistrm<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpistrm(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpistrm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpistrm<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpistrm(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpistrm_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpistrm<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpistrm(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpistrm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpistrm<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpistrm(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpistrm_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleb<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpleb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpb(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleb<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpleb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpb(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleb<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpleb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpb(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleb<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpleb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleb<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpleb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleb<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpleb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpled<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpled(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpled<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpled(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpled<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpled(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpled<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpled(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpled<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpled(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpled<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpled(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleq<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpleq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpq(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleq<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpleq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpq(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleq<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpleq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpq(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleq<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpleq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleq<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpleq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleq<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpleq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleub<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpleub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpub(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleub<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpleub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpub(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleub<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpleub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpub(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleub<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpleub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleub<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpleub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleub<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpleub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleud<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpleud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpud(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleud<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpleud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpud(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleud<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpleud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpud(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleud<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpleud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleud<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpleud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleud<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpleud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleuq<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpleuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpuq(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleuq<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpleuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpuq(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleuq<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpleuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpuq(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleuq<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpleuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleuq<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpleuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleuq<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpleuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleuw<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpleuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpuw(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleuw<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpleuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpuw(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleuw<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpleuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpuw(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleuw<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpleuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleuw<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpleuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleuw<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpleuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmplew<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmplew(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpw(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmplew<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmplew(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpw(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmplew<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmplew(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpw(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmplew<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmplew(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmplew<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmplew(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmplew<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmplew(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltb<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpltb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpb(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltb<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpltb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpb(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltb<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpltb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpb(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltb<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltb<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltb<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpltd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpltd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpltd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltq<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpltq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltq<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpltq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltq<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpltq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltq<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltq<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltq<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltub<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpltub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpub(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltub<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpltub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpub(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltub<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpltub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpub(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltub<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltub<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltub<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltud<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpltud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpud(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltud<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpltud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpud(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltud<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpltud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpud(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltud<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltud<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltud<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltuq<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpltuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpuq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltuq<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpltuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpuq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltuq<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpltuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpuq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltuq<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltuq<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltuq<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltuw<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpltuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpuw(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltuw<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpltuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpuw(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltuw<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpltuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpuw(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltuw<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltuw<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltuw<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltw<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpltw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpw(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltw<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpltw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpw(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltw<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpltw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpw(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltw<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltw<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltw<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqb<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpneqb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpb(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqb<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpneqb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpb(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqb<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpneqb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpb(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqb<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpneqb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqb<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpneqb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqb<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpneqb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpneqd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpneqd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpneqd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpneqd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpneqd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpneqd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqq<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpneqq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpq(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqq<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpneqq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpq(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqq<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpneqq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpq(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqq<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpneqq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqq<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpneqq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqq<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpneqq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequb<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpnequb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpub(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequb<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpnequb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpub(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequb<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpnequb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpub(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequb<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnequb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequb<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnequb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequb<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnequb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpnequd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpud(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpnequd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpud(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpnequd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpud(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnequd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnequd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnequd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequq<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpnequq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpuq(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequq<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpnequq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpuq(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequq<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpnequq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpuq(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequq<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnequq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequq<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnequq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequq<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnequq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequw<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpnequw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpuw(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequw<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpnequw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpuw(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequw<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpnequw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpuw(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequw<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnequw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequw<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnequw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequw<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnequw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqw<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpneqw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpw(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqw<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpneqw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpw(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqw<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpneqw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpw(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqw<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpneqw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqw<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpneqw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqw<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpneqw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleb<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpnleb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpb(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleb<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpnleb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpb(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleb<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpnleb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpb(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleb<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnleb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleb<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnleb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleb<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnleb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnled<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpnled(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnled<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpnled(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnled<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpnled(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnled<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnled(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnled<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnled(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnled<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnled(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleq<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpnleq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpq(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleq<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpnleq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpq(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleq<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpnleq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpq(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleq<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnleq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleq<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnleq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleq<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnleq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleub<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpnleub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpub(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleub<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpnleub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpub(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleub<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpnleub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpub(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleub<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnleub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleub<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnleub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleub<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnleub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleud<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpnleud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpud(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleud<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpnleud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpud(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleud<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpnleud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpud(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleud<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnleud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleud<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnleud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleud<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnleud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleuq<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpnleuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpuq(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleuq<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpnleuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpuq(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleuq<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpnleuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpuq(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleuq<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnleuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleuq<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnleuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleuq<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnleuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleuw<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpnleuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpuw(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleuw<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpnleuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpuw(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleuw<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpnleuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpuw(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleuw<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnleuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleuw<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnleuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleuw<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnleuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnlew<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpnlew(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpw(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnlew<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpnlew(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpw(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnlew<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpnlew(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpw(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnlew<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnlew(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnlew<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnlew(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnlew<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnlew(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltb<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpb(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltb<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpb(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltb<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpb(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltb<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltb<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltb<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltq<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpq(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltq<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpq(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltq<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpq(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltq<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltq<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltq<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltub<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpub(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltub<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpub(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltub<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpub(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltub<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltub<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltub<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltud<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpud(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltud<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpud(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltud<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpud(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltud<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltud<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltud<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltuq<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpuq(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltuq<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpuq(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltuq<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpuq(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltuq<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltuq<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltuq<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltuw<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpuw(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltuw<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpuw(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltuw<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpuw(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltuw<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltuw<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltuw<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltw<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpw(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltw<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpw(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltw<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpw(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltw<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltw<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltw<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpq_kr_k1_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpq_kr_k1_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpq_kr_k1_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpq_kr_k1_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpq_kr_k1_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpq_kr_k1_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpq_kr_k1_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpq_kr_k1_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpq_kr_k1_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpq_kr_k1_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpq_kr_k1_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpq_kr_k1_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueb<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmptrueb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpb(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueb<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmptrueb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpb(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueb<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmptrueb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpb(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueb<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrueb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueb<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrueb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueb<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrueb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrued<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmptrued(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrued<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmptrued(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrued<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmptrued(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrued<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrued(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrued<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrued(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrued<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrued(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueq<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmptrueq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpq(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueq<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmptrueq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpq(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueq<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmptrueq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpq(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueq<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrueq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueq<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrueq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueq<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrueq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueub<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmptrueub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpub(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueub<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmptrueub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpub(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueub<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmptrueub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpub(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueub<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrueub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueub<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrueub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueub<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrueub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueud<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmptrueud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpud(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueud<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmptrueud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpud(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueud<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmptrueud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpud(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueud<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrueud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueud<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrueud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueud<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrueud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueuq<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmptrueuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpuq(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueuq<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmptrueuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpuq(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueuq<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmptrueuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpuq(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueuq<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrueuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueuq<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrueuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueuq<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrueuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueuw<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmptrueuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpuw(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueuw<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmptrueuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpuw(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueuw<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmptrueuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpuw(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueuw<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrueuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueuw<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrueuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueuw<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrueuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptruew<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmptruew(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcmpw(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptruew<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmptruew(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32>>::vpcmpw(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptruew<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmptruew(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32>>::vpcmpw(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptruew<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptruew(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptruew<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptruew(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptruew<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptruew(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpub_kr_k1_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpub_kr_k1_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpub_kr_k1_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpub_kr_k1_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpub_kr_k1_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpub_kr_k1_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpub_kr_k1_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpub_kr_k1_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpub_kr_k1_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpub_kr_k1_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpub_kr_k1_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpub<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpub(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpub_kr_k1_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpud_kr_k1_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpud_kr_k1_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpud_kr_k1_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpud_kr_k1_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpud_kr_k1_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpud_kr_k1_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpud_kr_k1_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpud_kr_k1_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpud_kr_k1_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpud_kr_k1_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpud_kr_k1_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpud<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpud(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpud_kr_k1_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuq_kr_k1_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuq_kr_k1_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuq_kr_k1_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuq_kr_k1_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuq_kr_k1_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuq_kr_k1_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuq_kr_k1_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuq_kr_k1_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuq_kr_k1_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuq_kr_k1_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuq_kr_k1_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuq<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpuq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuq_kr_k1_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuw_kr_k1_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuw_kr_k1_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuw_kr_k1_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuw_kr_k1_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuw_kr_k1_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuw_kr_k1_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuw_kr_k1_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuw_kr_k1_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuw_kr_k1_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuw_kr_k1_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuw_kr_k1_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuw<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpuw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuw_kr_k1_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpw_kr_k1_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpw_kr_k1_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpw_kr_k1_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpw_kr_k1_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpw_kr_k1_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpw_kr_k1_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpw_kr_k1_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpw_kr_k1_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpw_kr_k1_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpw_kr_k1_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpw_kr_k1_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpw<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpw_kr_k1_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcomb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomb_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcomb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomb_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcomb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomb_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcomb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomb_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcomd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomd_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcomd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomd_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcomd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomd_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcomd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomd_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomeqb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomeqb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomb(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomeqb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomeqb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomb(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomeqd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomeqd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomeqd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomeqd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomeqq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomeqq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomq(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomeqq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomeqq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomq(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomequb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomequb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomub<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomub(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomequb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomequb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomub<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomub(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomequd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomequd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomud<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomud(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomequd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomequd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomud<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomud(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomequq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomequq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomuq(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomequq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomequq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomuq(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomequw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomequw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomuw(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomequw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomequw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomuw(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomeqw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomeqw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomw(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomeqw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomeqw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomw(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomfalseb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomfalseb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomb(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomfalseb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomfalseb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomb(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomfalsed<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomfalsed(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomfalsed<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomfalsed(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomfalseq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomfalseq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomq(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomfalseq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomfalseq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomq(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomfalseub<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomfalseub(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomub<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomub(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomfalseub<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomfalseub(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomub<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomub(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomfalseud<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomfalseud(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomud<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomud(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomfalseud<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomfalseud(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomud<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomud(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomfalseuq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomfalseuq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomuq(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomfalseuq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomfalseuq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomuq(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomfalseuw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomfalseuw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomuw(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomfalseuw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomfalseuw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomuw(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomfalsew<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomfalsew(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomw(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomfalsew<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomfalsew(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomw(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgeb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomgeb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomb(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgeb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomgeb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomb(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomged<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomged(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomged<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomged(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgeq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomgeq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomq(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgeq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomgeq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomq(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgeub<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomgeub(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomub<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomub(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgeub<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomgeub(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomub<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomub(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgeud<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomgeud(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomud<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomud(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgeud<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomgeud(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomud<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomud(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgeuq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomgeuq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomuq(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgeuq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomgeuq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomuq(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgeuw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomgeuw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomuw(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgeuw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomgeuw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomuw(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgew<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomgew(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomw(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgew<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomgew(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomw(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgtb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomgtb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomb(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgtb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomgtb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomb(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgtd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomgtd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgtd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomgtd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgtq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomgtq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomq(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgtq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomgtq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomq(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgtub<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomgtub(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomub<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomub(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgtub<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomgtub(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomub<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomub(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgtud<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomgtud(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomud<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomud(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgtud<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomgtud(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomud<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomud(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgtuq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomgtuq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomuq(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgtuq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomgtuq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomuq(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgtuw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomgtuw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomuw(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgtuw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomgtuw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomuw(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgtw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomgtw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomw(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgtw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomgtw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomw(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomleb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomleb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomb(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomleb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomleb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomb(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomled<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomled(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomled<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomled(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomleq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomleq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomleq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomleq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomleub<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomleub(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomub<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomub(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomleub<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomleub(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomub<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomub(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomleud<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomleud(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomud<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomud(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomleud<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomleud(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomud<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomud(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomleuq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomleuq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomuq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomleuq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomleuq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomuq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomleuw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomleuw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomuw(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomleuw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomleuw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomuw(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomlew<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomlew(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomw(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomlew<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomlew(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomw(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomltb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomltb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomb(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomltb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomltb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomb(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomltd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomltd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomd(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomltd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomltd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomd(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomltq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomltq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomq(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomltq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomltq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomq(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomltub<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomltub(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomub<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomub(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomltub<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomltub(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomub<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomub(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomltud<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomltud(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomud<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomud(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomltud<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomltud(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomud<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomud(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomltuq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomltuq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomuq(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomltuq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomltuq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomuq(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomltuw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomltuw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomuw(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomltuw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomltuw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomuw(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomltw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomltw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomw(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomltw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomltw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomw(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomneqb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomneqb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomb(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomneqb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomneqb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomb(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomneqd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomneqd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomneqd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomneqd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomneqq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomneqq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomq(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomneqq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomneqq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomq(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomnequb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomnequb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomub<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomub(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomnequb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomnequb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomub<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomub(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomnequd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomnequd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomud<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomud(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomnequd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomnequd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomud<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomud(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomnequq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomnequq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomuq(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomnequq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomnequq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomuq(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomnequw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomnequw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomuw(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomnequw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomnequw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomuw(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomneqw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomneqw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomw(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomneqw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomneqw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomw(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressb<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcompressb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressb_xmmm128_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressb<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcompressb(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressb_xmmm128_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressb<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcompressb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressb_ymmm256_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressb<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcompressb(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressb_ymmm256_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressb<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcompressb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressb_zmmm512_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressb<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcompressb(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressb_zmmm512_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcompressd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressd_xmmm128_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressd<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcompressd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressd_xmmm128_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressd<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcompressd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressd_ymmm256_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressd<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcompressd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressd_ymmm256_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressd<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcompressd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressd_zmmm512_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressd<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcompressd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressd_zmmm512_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcompressq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressq_xmmm128_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressq<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcompressq(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressq_xmmm128_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressq<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcompressq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressq_ymmm256_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressq<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcompressq(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressq_ymmm256_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressq<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcompressq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressq_zmmm512_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressq<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcompressq(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressq_zmmm512_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcompressw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressw_xmmm128_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressw<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcompressw(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressw_xmmm128_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressw<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcompressw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressw_ymmm256_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressw<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcompressw(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressw_ymmm256_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressw<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcompressw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressw_zmmm512_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressw<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcompressw(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressw_zmmm512_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcomq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomq_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcomq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomq_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcomq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomq_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcomq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomq_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomtrueb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomtrueb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomb(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomtrueb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomtrueb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomb(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomtrued<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomtrued(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomtrued<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomtrued(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomtrueq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomtrueq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomq(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomtrueq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomtrueq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomq(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomtrueub<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomtrueub(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomub<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomub(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomtrueub<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomtrueub(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomub<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomub(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomtrueud<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomtrueud(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomud<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomud(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomtrueud<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomtrueud(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomud<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomud(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomtrueuq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomtrueuq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomuq(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomtrueuq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomtrueuq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomuq(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomtrueuw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomtrueuw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomuw(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomtrueuw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomtrueuw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomuw(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomtruew<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomtruew(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32>>::vpcomw(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomtruew<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomtruew(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32>>::vpcomw(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomub<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcomub(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomub_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomub<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcomub(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomub_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomub<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcomub(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomub_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomub<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcomub(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomub_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomud<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcomud(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomud_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomud<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcomud(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomud_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomud<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcomud(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomud_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomud<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcomud(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomud_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomuq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcomuq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomuq_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomuq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcomuq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomuq_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomuq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcomuq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomuq_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomuq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcomuq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomuq_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomuw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcomuw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomuw_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomuw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcomuw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomuw_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomuw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcomuw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomuw_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomuw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcomuw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomuw_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcomw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomw_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcomw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomw_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcomw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomw_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcomw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomw_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpconflictd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpconflictd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpconflictd_xmm_k1z_xmmm128b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpconflictd<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpconflictd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpconflictd_ymm_k1z_ymmm256b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpconflictd<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpconflictd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpconflictd_zmm_k1z_zmmm512b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpconflictd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpconflictd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpconflictd_xmm_k1z_xmmm128b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpconflictd<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpconflictd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpconflictd_ymm_k1z_ymmm256b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpconflictd<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpconflictd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpconflictd_zmm_k1z_zmmm512b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpconflictq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpconflictq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpconflictq_xmm_k1z_xmmm128b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpconflictq<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpconflictq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpconflictq_ymm_k1z_ymmm256b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpconflictq<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpconflictq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpconflictq_zmm_k1z_zmmm512b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpconflictq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpconflictq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpconflictq_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpconflictq<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpconflictq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpconflictq_ymm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpconflictq<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpconflictq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpconflictq_zmm_k1z_zmmm512b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbusd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpdpbusd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpdpbusd_xmm_xmm_xmmm128 } else { Code::EVEX_Vpdpbusd_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbusd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpdpbusd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpdpbusd_ymm_ymm_ymmm256 } else { Code::EVEX_Vpdpbusd_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbusd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpdpbusd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpdpbusd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbusd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpdpbusd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpdpbusd_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vpdpbusd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpdpbusd_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbusd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpdpbusd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpdpbusd_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vpdpbusd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpdpbusd_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbusd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpdpbusd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpdpbusd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbusds<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpdpbusds(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpdpbusds_xmm_xmm_xmmm128 } else { Code::EVEX_Vpdpbusds_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbusds<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpdpbusds(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpdpbusds_ymm_ymm_ymmm256 } else { Code::EVEX_Vpdpbusds_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbusds<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpdpbusds(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpdpbusds_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbusds<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpdpbusds(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpdpbusds_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vpdpbusds_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpdpbusds_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbusds<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpdpbusds(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpdpbusds_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vpdpbusds_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpdpbusds_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbusds<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpdpbusds(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpdpbusds_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwssd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpdpwssd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpdpwssd_xmm_xmm_xmmm128 } else { Code::EVEX_Vpdpwssd_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwssd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpdpwssd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpdpwssd_ymm_ymm_ymmm256 } else { Code::EVEX_Vpdpwssd_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwssd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpdpwssd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpdpwssd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwssd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpdpwssd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpdpwssd_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vpdpwssd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpdpwssd_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwssd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpdpwssd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpdpwssd_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vpdpwssd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpdpwssd_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwssd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpdpwssd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpdpwssd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwssds<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpdpwssds(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpdpwssds_xmm_xmm_xmmm128 } else { Code::EVEX_Vpdpwssds_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwssds<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpdpwssds(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpdpwssds_ymm_ymm_ymmm256 } else { Code::EVEX_Vpdpwssds_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwssds<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpdpwssds(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpdpwssds_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwssds<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpdpwssds(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpdpwssds_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vpdpwssds_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpdpwssds_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwssds<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpdpwssds(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpdpwssds_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vpdpwssds_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpdpwssds_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwssds<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpdpwssds(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpdpwssds_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVperm2f128<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vperm2f128(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vperm2f128_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVperm2f128<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vperm2f128(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vperm2f128_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVperm2f128<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vperm2f128(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vperm2f128_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVperm2f128<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vperm2f128(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vperm2f128_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVperm2i128<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vperm2i128(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vperm2i128_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVperm2i128<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vperm2i128(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vperm2i128_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVperm2i128<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vperm2i128(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vperm2i128_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVperm2i128<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vperm2i128(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vperm2i128_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpermb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermb_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpermb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermb_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermb<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpermb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermb_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermb_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermb<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpermd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpermd_ymm_ymm_ymmm256 } else { Code::EVEX_Vpermd_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpermd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpermd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpermd_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vpermd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpermd_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2b<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpermi2b(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2b_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2b<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpermi2b(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2b_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2b<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpermi2b(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2b_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2b<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermi2b(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2b_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2b<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermi2b(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2b_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2b<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermi2b(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2b_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2d<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpermi2d(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2d_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2d<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpermi2d(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2d_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2d<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpermi2d(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2d_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2d<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermi2d(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2d_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2d<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermi2d(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2d_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2d<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermi2d(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2d_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpermi2pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2pd_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpermi2pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2pd_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2pd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpermi2pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2pd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermi2pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2pd_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermi2pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2pd_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2pd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermi2pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2pd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpermi2ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2ps_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpermi2ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2ps_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpermi2ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2ps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermi2ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2ps_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermi2ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2ps_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermi2ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2ps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2q<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpermi2q(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2q_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2q<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpermi2q(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2q_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2q<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpermi2q(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2q_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2q<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermi2q(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2q_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2q<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermi2q(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2q_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2q<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermi2q(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2q_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2w<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpermi2w(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2w_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2w<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpermi2w(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2w_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2w<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpermi2w(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2w_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2w<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermi2w(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2w_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2w<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermi2w(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2w_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2w<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermi2w(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2w_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpermil2pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmRegisterXmm, op4: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2pd_xmm_xmm_xmmm128_xmm_imm4, op0.register(), op1.register(), op2.register(), op3.register(), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpermil2pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: __AsmRegisterXmm, op4: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2pd_xmm_xmm_xmmm128_xmm_imm4, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register(), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpermil2pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: __AsmRegisterYmm, op4: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2pd_ymm_ymm_ymmm256_ymm_imm4, op0.register(), op1.register(), op2.register(), op3.register(), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpermil2pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: __AsmRegisterYmm, op4: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2pd_ymm_ymm_ymmm256_ymm_imm4, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register(), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpermil2pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmMemoryOperand, op4: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2pd_xmm_xmm_xmm_xmmm128_imm4, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpermil2pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: __AsmMemoryOperand, op4: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2pd_ymm_ymm_ymm_ymmm256_imm4, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpermil2pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmRegisterXmm, op4: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2pd_xmm_xmm_xmmm128_xmm_imm4, op0.register(), op1.register(), op2.register(), op3.register(), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpermil2pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: __AsmRegisterXmm, op4: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2pd_xmm_xmm_xmmm128_xmm_imm4, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register(), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpermil2pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: __AsmRegisterYmm, op4: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2pd_ymm_ymm_ymmm256_ymm_imm4, op0.register(), op1.register(), op2.register(), op3.register(), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpermil2pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: __AsmRegisterYmm, op4: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2pd_ymm_ymm_ymmm256_ymm_imm4, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register(), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpermil2pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmMemoryOperand, op4: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2pd_xmm_xmm_xmm_xmmm128_imm4, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpermil2pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: __AsmMemoryOperand, op4: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2pd_ymm_ymm_ymm_ymmm256_imm4, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpermil2ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmRegisterXmm, op4: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2ps_xmm_xmm_xmmm128_xmm_imm4, op0.register(), op1.register(), op2.register(), op3.register(), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpermil2ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: __AsmRegisterXmm, op4: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2ps_xmm_xmm_xmmm128_xmm_imm4, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register(), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpermil2ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: __AsmRegisterYmm, op4: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2ps_ymm_ymm_ymmm256_ymm_imm4, op0.register(), op1.register(), op2.register(), op3.register(), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpermil2ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: __AsmRegisterYmm, op4: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2ps_ymm_ymm_ymmm256_ymm_imm4, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register(), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpermil2ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmMemoryOperand, op4: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2ps_xmm_xmm_xmm_xmmm128_imm4, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpermil2ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: __AsmMemoryOperand, op4: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2ps_ymm_ymm_ymm_ymmm256_imm4, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpermil2ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmRegisterXmm, op4: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2ps_xmm_xmm_xmmm128_xmm_imm4, op0.register(), op1.register(), op2.register(), op3.register(), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpermil2ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: __AsmRegisterXmm, op4: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2ps_xmm_xmm_xmmm128_xmm_imm4, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register(), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpermil2ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: __AsmRegisterYmm, op4: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2ps_ymm_ymm_ymmm256_ymm_imm4, op0.register(), op1.register(), op2.register(), op3.register(), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpermil2ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: __AsmRegisterYmm, op4: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2ps_ymm_ymm_ymmm256_ymm_imm4, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register(), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpermil2ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmMemoryOperand, op4: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2ps_xmm_xmm_xmm_xmmm128_imm4, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpermil2ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: __AsmMemoryOperand, op4: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2ps_ymm_ymm_ymm_ymmm256_imm4, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpermilpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpermilpd_xmm_xmm_xmmm128 } else { Code::EVEX_Vpermilpd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpermilpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpermilpd_ymm_ymm_ymmm256 } else { Code::EVEX_Vpermilpd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilpd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpermilpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermilpd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpermilpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpermilpd_xmm_k1z_xmm_xmmm128b64
		} else if self.prefer_vex() {
			Code::VEX_Vpermilpd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpermilpd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpermilpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpermilpd_ymm_k1z_ymm_ymmm256b64
		} else if self.prefer_vex() {
			Code::VEX_Vpermilpd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpermilpd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilpd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermilpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermilpd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilpd<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpermilpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpermilpd_xmm_xmmm128_imm8 } else { Code::EVEX_Vpermilpd_xmm_k1z_xmmm128b64_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilpd<__AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpermilpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpermilpd_ymm_ymmm256_imm8 } else { Code::EVEX_Vpermilpd_ymm_k1z_ymmm256b64_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilpd<__AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpermilpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermilpd_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilpd<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	fn vpermilpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vpermilpd_xmm_k1z_xmmm128b64_imm8
		} else if self.prefer_vex() {
			Code::VEX_Vpermilpd_xmm_xmmm128_imm8
		} else {
			Code::EVEX_Vpermilpd_xmm_k1z_xmmm128b64_imm8
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilpd<__AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	fn vpermilpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vpermilpd_ymm_k1z_ymmm256b64_imm8
		} else if self.prefer_vex() {
			Code::VEX_Vpermilpd_ymm_ymmm256_imm8
		} else {
			Code::EVEX_Vpermilpd_ymm_k1z_ymmm256b64_imm8
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilpd<__AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpermilpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermilpd_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilpd<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpermilpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpermilpd_xmm_xmmm128_imm8 } else { Code::EVEX_Vpermilpd_xmm_k1z_xmmm128b64_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilpd<__AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpermilpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpermilpd_ymm_ymmm256_imm8 } else { Code::EVEX_Vpermilpd_ymm_k1z_ymmm256b64_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilpd<__AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpermilpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermilpd_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilpd<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	fn vpermilpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vpermilpd_xmm_k1z_xmmm128b64_imm8
		} else if self.prefer_vex() {
			Code::VEX_Vpermilpd_xmm_xmmm128_imm8
		} else {
			Code::EVEX_Vpermilpd_xmm_k1z_xmmm128b64_imm8
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilpd<__AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	fn vpermilpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vpermilpd_ymm_k1z_ymmm256b64_imm8
		} else if self.prefer_vex() {
			Code::VEX_Vpermilpd_ymm_ymmm256_imm8
		} else {
			Code::EVEX_Vpermilpd_ymm_k1z_ymmm256b64_imm8
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilpd<__AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpermilpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermilpd_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpermilps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpermilps_xmm_xmm_xmmm128 } else { Code::EVEX_Vpermilps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpermilps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpermilps_ymm_ymm_ymmm256 } else { Code::EVEX_Vpermilps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpermilps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermilps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpermilps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpermilps_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vpermilps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpermilps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpermilps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpermilps_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vpermilps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpermilps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermilps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermilps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilps<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpermilps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpermilps_xmm_xmmm128_imm8 } else { Code::EVEX_Vpermilps_xmm_k1z_xmmm128b32_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilps<__AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpermilps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpermilps_ymm_ymmm256_imm8 } else { Code::EVEX_Vpermilps_ymm_k1z_ymmm256b32_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilps<__AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpermilps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermilps_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilps<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	fn vpermilps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vpermilps_xmm_k1z_xmmm128b32_imm8
		} else if self.prefer_vex() {
			Code::VEX_Vpermilps_xmm_xmmm128_imm8
		} else {
			Code::EVEX_Vpermilps_xmm_k1z_xmmm128b32_imm8
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilps<__AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	fn vpermilps(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vpermilps_ymm_k1z_ymmm256b32_imm8
		} else if self.prefer_vex() {
			Code::VEX_Vpermilps_ymm_ymmm256_imm8
		} else {
			Code::EVEX_Vpermilps_ymm_k1z_ymmm256b32_imm8
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilps<__AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpermilps(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermilps_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilps<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpermilps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpermilps_xmm_xmmm128_imm8 } else { Code::EVEX_Vpermilps_xmm_k1z_xmmm128b32_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilps<__AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpermilps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpermilps_ymm_ymmm256_imm8 } else { Code::EVEX_Vpermilps_ymm_k1z_ymmm256b32_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilps<__AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpermilps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermilps_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilps<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	fn vpermilps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vpermilps_xmm_k1z_xmmm128b32_imm8
		} else if self.prefer_vex() {
			Code::VEX_Vpermilps_xmm_xmmm128_imm8
		} else {
			Code::EVEX_Vpermilps_xmm_k1z_xmmm128b32_imm8
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilps<__AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	fn vpermilps(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vpermilps_ymm_k1z_ymmm256b32_imm8
		} else if self.prefer_vex() {
			Code::VEX_Vpermilps_ymm_ymmm256_imm8
		} else {
			Code::EVEX_Vpermilps_ymm_k1z_ymmm256b32_imm8
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilps<__AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpermilps(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermilps_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpermpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermpd_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermpd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpermpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermpd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermpd_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermpd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermpd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermpd<__AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpermpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpermpd_ymm_ymmm256_imm8 } else { Code::EVEX_Vpermpd_ymm_k1z_ymmm256b64_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermpd<__AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpermpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermpd_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermpd<__AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	fn vpermpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vpermpd_ymm_k1z_ymmm256b64_imm8
		} else if self.prefer_vex() {
			Code::VEX_Vpermpd_ymm_ymmm256_imm8
		} else {
			Code::EVEX_Vpermpd_ymm_k1z_ymmm256b64_imm8
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermpd<__AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpermpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermpd_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermpd<__AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpermpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpermpd_ymm_ymmm256_imm8 } else { Code::EVEX_Vpermpd_ymm_k1z_ymmm256b64_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermpd<__AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpermpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermpd_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermpd<__AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	fn vpermpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vpermpd_ymm_k1z_ymmm256b64_imm8
		} else if self.prefer_vex() {
			Code::VEX_Vpermpd_ymm_ymmm256_imm8
		} else {
			Code::EVEX_Vpermpd_ymm_k1z_ymmm256b64_imm8
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermpd<__AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpermpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermpd_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpermps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpermps_ymm_ymm_ymmm256 } else { Code::EVEX_Vpermps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpermps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpermps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpermps_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vpermps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpermps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpermq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpermq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermq<__AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpermq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpermq_ymm_ymmm256_imm8 } else { Code::EVEX_Vpermq_ymm_k1z_ymmm256b64_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermq<__AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpermq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermq<__AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	fn vpermq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vpermq_ymm_k1z_ymmm256b64_imm8
		} else if self.prefer_vex() {
			Code::VEX_Vpermq_ymm_ymmm256_imm8
		} else {
			Code::EVEX_Vpermq_ymm_k1z_ymmm256b64_imm8
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermq<__AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpermq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermq<__AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpermq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpermq_ymm_ymmm256_imm8 } else { Code::EVEX_Vpermq_ymm_k1z_ymmm256b64_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermq<__AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpermq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermq<__AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	fn vpermq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vpermq_ymm_k1z_ymmm256b64_imm8
		} else if self.prefer_vex() {
			Code::VEX_Vpermq_ymm_ymmm256_imm8
		} else {
			Code::EVEX_Vpermq_ymm_k1z_ymmm256b64_imm8
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermq<__AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpermq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2b<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpermt2b(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2b_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2b<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpermt2b(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2b_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2b<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpermt2b(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2b_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2b<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermt2b(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2b_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2b<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermt2b(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2b_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2b<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermt2b(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2b_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2d<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpermt2d(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2d_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2d<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpermt2d(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2d_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2d<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpermt2d(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2d_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2d<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermt2d(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2d_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2d<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermt2d(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2d_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2d<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermt2d(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2d_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpermt2pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2pd_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpermt2pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2pd_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2pd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpermt2pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2pd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2pd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermt2pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2pd_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2pd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermt2pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2pd_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2pd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermt2pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2pd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpermt2ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2ps_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpermt2ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2ps_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpermt2ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2ps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2ps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermt2ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2ps_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2ps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermt2ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2ps_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2ps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermt2ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2ps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2q<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpermt2q(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2q_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2q<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpermt2q(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2q_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2q<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpermt2q(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2q_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2q<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermt2q(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2q_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2q<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermt2q(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2q_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2q<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermt2q(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2q_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2w<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpermt2w(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2w_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2w<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpermt2w(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2w_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2w<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpermt2w(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2w_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2w<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermt2w(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2w_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2w<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermt2w(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2w_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2w<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermt2w(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2w_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpermw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermw_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpermw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermw_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpermw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermw_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermw_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandb<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpexpandb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandb_xmm_k1z_xmmm128, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandb<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpexpandb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandb_ymm_k1z_ymmm256, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandb<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpexpandb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandb_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandb<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpexpandb(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandb_xmm_k1z_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandb<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpexpandb(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandb_ymm_k1z_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandb<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpexpandb(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandb_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpexpandd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandd_xmm_k1z_xmmm128, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandd<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpexpandd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandd_ymm_k1z_ymmm256, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandd<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpexpandd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandd_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpexpandd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandd_xmm_k1z_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandd<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpexpandd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandd_ymm_k1z_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandd<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpexpandd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandd_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpexpandq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandq_xmm_k1z_xmmm128, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandq<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpexpandq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandq_ymm_k1z_ymmm256, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandq<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpexpandq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandq_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpexpandq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandq_xmm_k1z_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandq<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpexpandq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandq_ymm_k1z_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandq<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpexpandq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandq_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpexpandw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandw_xmm_k1z_xmmm128, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandw<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpexpandw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandw_ymm_k1z_ymmm256, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandw<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpexpandw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandw_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpexpandw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandw_xmm_k1z_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandw<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpexpandw(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandw_ymm_k1z_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandw<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpexpandw(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandw_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpextrb<__AsmRegister32, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpextrb(&mut self, op0: __AsmRegister32, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpextrb_r32m8_xmm_imm8 } else { Code::EVEX_Vpextrb_r32m8_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpextrb<__AsmRegister64, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpextrb(&mut self, op0: __AsmRegister64, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpextrb_r64m8_xmm_imm8 } else { Code::EVEX_Vpextrb_r64m8_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpextrb<__AsmMemoryOperand, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpextrb(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpextrb_r32m8_xmm_imm8 } else { Code::EVEX_Vpextrb_r32m8_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpextrb<__AsmRegister32, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpextrb(&mut self, op0: __AsmRegister32, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpextrb_r32m8_xmm_imm8 } else { Code::EVEX_Vpextrb_r32m8_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpextrb<__AsmRegister64, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpextrb(&mut self, op0: __AsmRegister64, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpextrb_r64m8_xmm_imm8 } else { Code::EVEX_Vpextrb_r64m8_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpextrb<__AsmMemoryOperand, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpextrb(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpextrb_r32m8_xmm_imm8 } else { Code::EVEX_Vpextrb_r32m8_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpextrd<__AsmRegister32, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpextrd(&mut self, op0: __AsmRegister32, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpextrd_rm32_xmm_imm8 } else { Code::EVEX_Vpextrd_rm32_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpextrd<__AsmMemoryOperand, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpextrd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpextrd_rm32_xmm_imm8 } else { Code::EVEX_Vpextrd_rm32_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpextrd<__AsmRegister32, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpextrd(&mut self, op0: __AsmRegister32, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpextrd_rm32_xmm_imm8 } else { Code::EVEX_Vpextrd_rm32_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpextrd<__AsmMemoryOperand, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpextrd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpextrd_rm32_xmm_imm8 } else { Code::EVEX_Vpextrd_rm32_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpextrq<__AsmRegister64, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpextrq(&mut self, op0: __AsmRegister64, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpextrq_rm64_xmm_imm8 } else { Code::EVEX_Vpextrq_rm64_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpextrq<__AsmMemoryOperand, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpextrq(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpextrq_rm64_xmm_imm8 } else { Code::EVEX_Vpextrq_rm64_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpextrq<__AsmRegister64, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpextrq(&mut self, op0: __AsmRegister64, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpextrq_rm64_xmm_imm8 } else { Code::EVEX_Vpextrq_rm64_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpextrq<__AsmMemoryOperand, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpextrq(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpextrq_rm64_xmm_imm8 } else { Code::EVEX_Vpextrq_rm64_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpextrw<__AsmRegister32, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpextrw(&mut self, op0: __AsmRegister32, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpextrw_r32_xmm_imm8 } else { Code::EVEX_Vpextrw_r32_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpextrw<__AsmRegister64, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpextrw(&mut self, op0: __AsmRegister64, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpextrw_r64_xmm_imm8 } else { Code::EVEX_Vpextrw_r64_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpextrw<__AsmMemoryOperand, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpextrw(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpextrw_r32m16_xmm_imm8 } else { Code::EVEX_Vpextrw_r32m16_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpextrw<__AsmRegister32, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpextrw(&mut self, op0: __AsmRegister32, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpextrw_r32_xmm_imm8 } else { Code::EVEX_Vpextrw_r32_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpextrw<__AsmRegister64, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpextrw(&mut self, op0: __AsmRegister64, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpextrw_r64_xmm_imm8 } else { Code::EVEX_Vpextrw_r64_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpextrw<__AsmMemoryOperand, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpextrw(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpextrw_r32m16_xmm_imm8 } else { Code::EVEX_Vpextrw_r32m16_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpgatherdd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpgatherdd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpgatherdd_xmm_k1_vm32x, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpgatherdd<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpgatherdd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpgatherdd_ymm_k1_vm32y, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpgatherdd<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpgatherdd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpgatherdd_zmm_k1_vm32z, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpgatherdd3<__AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpgatherdd_3(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpgatherdd_xmm_vm32x_xmm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpgatherdd3<__AsmRegisterYmm, __AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpgatherdd_3(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpgatherdd_ymm_vm32y_ymm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpgatherdq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpgatherdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpgatherdq_xmm_k1_vm32x, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpgatherdq<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpgatherdq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpgatherdq_ymm_k1_vm32x, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpgatherdq<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpgatherdq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpgatherdq_zmm_k1_vm32y, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpgatherdq3<__AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpgatherdq_3(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpgatherdq_xmm_vm32x_xmm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpgatherdq3<__AsmRegisterYmm, __AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpgatherdq_3(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpgatherdq_ymm_vm32x_ymm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpgatherqd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpgatherqd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.index().is_xmm() {
			Code::EVEX_Vpgatherqd_xmm_k1_vm64x
		} else if op1.index().is_ymm() {
			Code::EVEX_Vpgatherqd_xmm_k1_vm64y
		} else {
			return Err(IcedError::new("vpgatherqd: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpgatherqd<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpgatherqd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpgatherqd_ymm_k1_vm64z, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpgatherqd3<__AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	fn vpgatherqd_3(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if op1.index().is_xmm() {
			Code::VEX_Vpgatherqd_xmm_vm64x_xmm
		} else if op1.index().is_ymm() {
			Code::VEX_Vpgatherqd_xmm_vm64y_xmm
		} else {
			return Err(IcedError::new("vpgatherqd: invalid operands"));
		};
		self.add_instr(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpgatherqq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpgatherqq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpgatherqq_xmm_k1_vm64x, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpgatherqq<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpgatherqq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpgatherqq_ymm_k1_vm64y, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpgatherqq<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpgatherqq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpgatherqq_zmm_k1_vm64z, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpgatherqq3<__AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpgatherqq_3(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpgatherqq_xmm_vm64x_xmm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpgatherqq3<__AsmRegisterYmm, __AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpgatherqq_3(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpgatherqq_ymm_vm64y_ymm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddbd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphaddbd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphaddbd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddbd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphaddbd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphaddbd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddbq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphaddbq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphaddbq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddbq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphaddbq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphaddbq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddbw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphaddbw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphaddbw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddbw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphaddbw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphaddbw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphaddd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphaddd_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vphaddd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphaddd_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphaddd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphaddd_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphaddd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphaddd_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphadddq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphadddq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphadddq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphadddq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphadddq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphadddq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddsw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphaddsw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphaddsw_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddsw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vphaddsw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphaddsw_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddsw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphaddsw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphaddsw_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddsw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphaddsw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphaddsw_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddubd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphaddubd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphaddubd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddubd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphaddubd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphaddubd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddubq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphaddubq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphaddubq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddubq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphaddubq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphaddubq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddubw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphaddubw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphaddubw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddubw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphaddubw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphaddubw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddudq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphaddudq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphaddudq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddudq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphaddudq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphaddudq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphadduwd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphadduwd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphadduwd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphadduwd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphadduwd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphadduwd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphadduwq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphadduwq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphadduwq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphadduwq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphadduwq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphadduwq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphaddw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphaddw_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vphaddw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphaddw_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphaddw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphaddw_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphaddw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphaddw_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddwd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphaddwd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphaddwd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddwd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphaddwd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphaddwd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddwq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphaddwq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphaddwq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddwq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphaddwq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphaddwq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphminposuw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphminposuw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vphminposuw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphminposuw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphminposuw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vphminposuw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphsubbw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphsubbw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphsubbw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphsubbw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphsubbw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphsubbw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphsubd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphsubd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphsubd_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphsubd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vphsubd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphsubd_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphsubd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphsubd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphsubd_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphsubd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphsubd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphsubd_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphsubdq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphsubdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphsubdq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphsubdq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphsubdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphsubdq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphsubsw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphsubsw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphsubsw_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphsubsw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vphsubsw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphsubsw_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphsubsw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphsubsw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphsubsw_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphsubsw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphsubsw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphsubsw_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphsubw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphsubw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphsubw_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphsubw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vphsubw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphsubw_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphsubw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphsubw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphsubw_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphsubw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphsubw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphsubw_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphsubwd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphsubwd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphsubwd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphsubwd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphsubwd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphsubwd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpinsrb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn vpinsrb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegister32, op3: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpinsrb_xmm_xmm_r32m8_imm8 } else { Code::EVEX_Vpinsrb_xmm_xmm_r32m8_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpinsrb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn vpinsrb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegister64, op3: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpinsrb_xmm_xmm_r64m8_imm8 } else { Code::EVEX_Vpinsrb_xmm_xmm_r64m8_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpinsrb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpinsrb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpinsrb_xmm_xmm_r32m8_imm8 } else { Code::EVEX_Vpinsrb_xmm_xmm_r32m8_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpinsrb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn vpinsrb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegister32, op3: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpinsrb_xmm_xmm_r32m8_imm8 } else { Code::EVEX_Vpinsrb_xmm_xmm_r32m8_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpinsrb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn vpinsrb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegister64, op3: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpinsrb_xmm_xmm_r64m8_imm8 } else { Code::EVEX_Vpinsrb_xmm_xmm_r64m8_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpinsrb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpinsrb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpinsrb_xmm_xmm_r32m8_imm8 } else { Code::EVEX_Vpinsrb_xmm_xmm_r32m8_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpinsrd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn vpinsrd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegister32, op3: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpinsrd_xmm_xmm_rm32_imm8 } else { Code::EVEX_Vpinsrd_xmm_xmm_rm32_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpinsrd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpinsrd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpinsrd_xmm_xmm_rm32_imm8 } else { Code::EVEX_Vpinsrd_xmm_xmm_rm32_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpinsrd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn vpinsrd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegister32, op3: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpinsrd_xmm_xmm_rm32_imm8 } else { Code::EVEX_Vpinsrd_xmm_xmm_rm32_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpinsrd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpinsrd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpinsrd_xmm_xmm_rm32_imm8 } else { Code::EVEX_Vpinsrd_xmm_xmm_rm32_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpinsrq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn vpinsrq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegister64, op3: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpinsrq_xmm_xmm_rm64_imm8 } else { Code::EVEX_Vpinsrq_xmm_xmm_rm64_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpinsrq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpinsrq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpinsrq_xmm_xmm_rm64_imm8 } else { Code::EVEX_Vpinsrq_xmm_xmm_rm64_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpinsrq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn vpinsrq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegister64, op3: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpinsrq_xmm_xmm_rm64_imm8 } else { Code::EVEX_Vpinsrq_xmm_xmm_rm64_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpinsrq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpinsrq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpinsrq_xmm_xmm_rm64_imm8 } else { Code::EVEX_Vpinsrq_xmm_xmm_rm64_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpinsrw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn vpinsrw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegister32, op3: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpinsrw_xmm_xmm_r32m16_imm8 } else { Code::EVEX_Vpinsrw_xmm_xmm_r32m16_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpinsrw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn vpinsrw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegister64, op3: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpinsrw_xmm_xmm_r64m16_imm8 } else { Code::EVEX_Vpinsrw_xmm_xmm_r64m16_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpinsrw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpinsrw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpinsrw_xmm_xmm_r32m16_imm8 } else { Code::EVEX_Vpinsrw_xmm_xmm_r32m16_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpinsrw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn vpinsrw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegister32, op3: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpinsrw_xmm_xmm_r32m16_imm8 } else { Code::EVEX_Vpinsrw_xmm_xmm_r32m16_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpinsrw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn vpinsrw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegister64, op3: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpinsrw_xmm_xmm_r64m16_imm8 } else { Code::EVEX_Vpinsrw_xmm_xmm_r64m16_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpinsrw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpinsrw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpinsrw_xmm_xmm_r32m16_imm8 } else { Code::EVEX_Vpinsrw_xmm_xmm_r32m16_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVplzcntd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vplzcntd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vplzcntd_xmm_k1z_xmmm128b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVplzcntd<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vplzcntd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vplzcntd_ymm_k1z_ymmm256b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVplzcntd<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vplzcntd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vplzcntd_zmm_k1z_zmmm512b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVplzcntd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vplzcntd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vplzcntd_xmm_k1z_xmmm128b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVplzcntd<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vplzcntd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vplzcntd_ymm_k1z_ymmm256b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVplzcntd<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vplzcntd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vplzcntd_zmm_k1z_zmmm512b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVplzcntq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vplzcntq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vplzcntq_xmm_k1z_xmmm128b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVplzcntq<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vplzcntq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vplzcntq_ymm_k1z_ymmm256b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVplzcntq<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vplzcntq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vplzcntq_zmm_k1z_zmmm512b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVplzcntq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vplzcntq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vplzcntq_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVplzcntq<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vplzcntq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vplzcntq_ymm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVplzcntq<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vplzcntq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vplzcntq_zmm_k1z_zmmm512b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmacsdd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmacsdd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmacsdd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmacsdd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmacsdd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmacsdd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmacsdqh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmacsdqh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmacsdqh_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmacsdqh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmacsdqh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmacsdqh_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmacsdql<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmacsdql(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmacsdql_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmacsdql<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmacsdql(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmacsdql_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmacssdd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmacssdd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmacssdd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmacssdd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmacssdd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmacssdd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmacssdqh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmacssdqh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmacssdqh_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmacssdqh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmacssdqh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmacssdqh_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmacssdql<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmacssdql(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmacssdql_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmacssdql<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmacssdql(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmacssdql_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmacsswd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmacsswd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmacsswd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmacsswd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmacsswd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmacsswd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmacssww<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmacssww(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmacssww_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmacssww<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmacssww(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmacssww_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmacswd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmacswd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmacswd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmacswd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmacswd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmacswd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmacsww<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmacsww(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmacsww_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmacsww<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmacsww(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmacsww_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmadcsswd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmadcsswd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmadcsswd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmadcsswd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmadcsswd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmadcsswd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmadcswd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmadcswd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmadcswd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmadcswd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmadcswd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmadcswd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmadd52huq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmadd52huq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmadd52huq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmadd52huq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmadd52huq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmadd52huq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmadd52huq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmadd52huq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmadd52huq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmadd52huq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmadd52huq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmadd52huq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmadd52huq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmadd52huq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmadd52huq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmadd52huq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmadd52huq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmadd52huq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmadd52luq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmadd52luq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmadd52luq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmadd52luq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmadd52luq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmadd52luq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmadd52luq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmadd52luq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmadd52luq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmadd52luq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmadd52luq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmadd52luq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmadd52luq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmadd52luq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmadd52luq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmadd52luq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmadd52luq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmadd52luq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaddubsw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmaddubsw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmaddubsw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmaddubsw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaddubsw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmaddubsw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmaddubsw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmaddubsw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaddubsw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmaddubsw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaddubsw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaddubsw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaddubsw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmaddubsw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmaddubsw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaddubsw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaddubsw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmaddubsw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmaddubsw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaddubsw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaddubsw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaddubsw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaddwd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmaddwd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmaddwd_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmaddwd_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaddwd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmaddwd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmaddwd_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmaddwd_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaddwd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmaddwd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaddwd_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaddwd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaddwd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmaddwd_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmaddwd_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaddwd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaddwd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmaddwd_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmaddwd_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaddwd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaddwd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaddwd_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaskmovd<__AsmMemoryOperand, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmaskmovd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpmaskmovd_m128_xmm_xmm, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaskmovd<__AsmMemoryOperand, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmaskmovd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpmaskmovd_m256_ymm_ymm, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaskmovd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaskmovd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpmaskmovd_xmm_xmm_m128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaskmovd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaskmovd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpmaskmovd_ymm_ymm_m256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaskmovq<__AsmMemoryOperand, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmaskmovq(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpmaskmovq_m128_xmm_xmm, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaskmovq<__AsmMemoryOperand, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmaskmovq(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpmaskmovq_m256_ymm_ymm, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaskmovq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaskmovq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpmaskmovq_xmm_xmm_m128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaskmovq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaskmovq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpmaskmovq_ymm_ymm_m256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmaxsb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmaxsb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmaxsb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmaxsb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmaxsb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmaxsb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsb<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmaxsb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxsb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaxsb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmaxsb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmaxsb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaxsb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmaxsb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmaxsb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsb<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaxsb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxsb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmaxsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmaxsd_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmaxsd_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmaxsd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmaxsd_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmaxsd_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmaxsd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxsd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpmaxsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpmaxsd_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vpmaxsd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpmaxsd_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpmaxsd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpmaxsd_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vpmaxsd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpmaxsd_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaxsd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxsd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmaxsq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxsq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmaxsq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxsq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmaxsq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxsq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaxsq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxsq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaxsq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxsq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaxsq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxsq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmaxsw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmaxsw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmaxsw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmaxsw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmaxsw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmaxsw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmaxsw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxsw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaxsw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmaxsw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmaxsw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaxsw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmaxsw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmaxsw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaxsw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxsw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxub<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmaxub(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmaxub_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmaxub_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxub<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmaxub(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmaxub_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmaxub_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxub<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmaxub(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxub_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxub<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaxub(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmaxub_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmaxub_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxub<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaxub(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmaxub_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmaxub_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxub<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaxub(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxub_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxud<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmaxud(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmaxud_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmaxud_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxud<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmaxud(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmaxud_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmaxud_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxud<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmaxud(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxud_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxud<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpmaxud(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpmaxud_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vpmaxud_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpmaxud_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxud<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpmaxud(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpmaxud_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vpmaxud_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpmaxud_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxud<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaxud(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxud_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxuq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmaxuq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxuq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxuq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmaxuq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxuq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxuq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmaxuq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxuq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxuq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaxuq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxuq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxuq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaxuq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxuq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxuq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaxuq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxuq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxuw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmaxuw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmaxuw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmaxuw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxuw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmaxuw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmaxuw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmaxuw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxuw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmaxuw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxuw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxuw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaxuw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmaxuw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmaxuw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxuw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaxuw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmaxuw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmaxuw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxuw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaxuw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxuw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpminsb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpminsb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpminsb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpminsb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpminsb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpminsb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsb<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpminsb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminsb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpminsb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpminsb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpminsb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpminsb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpminsb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpminsb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsb<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpminsb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminsb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpminsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpminsd_xmm_xmm_xmmm128 } else { Code::EVEX_Vpminsd_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpminsd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpminsd_ymm_ymm_ymmm256 } else { Code::EVEX_Vpminsd_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpminsd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminsd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpminsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpminsd_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vpminsd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpminsd_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpminsd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpminsd_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vpminsd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpminsd_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpminsd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminsd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpminsq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminsq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpminsq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminsq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpminsq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminsq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpminsq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminsq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpminsq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminsq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpminsq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminsq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpminsw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpminsw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpminsw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpminsw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpminsw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpminsw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpminsw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminsw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpminsw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpminsw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpminsw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpminsw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpminsw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpminsw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpminsw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminsw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminub<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpminub(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpminub_xmm_xmm_xmmm128 } else { Code::EVEX_Vpminub_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminub<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpminub(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpminub_ymm_ymm_ymmm256 } else { Code::EVEX_Vpminub_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminub<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpminub(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminub_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminub<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpminub(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpminub_xmm_xmm_xmmm128 } else { Code::EVEX_Vpminub_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminub<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpminub(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpminub_ymm_ymm_ymmm256 } else { Code::EVEX_Vpminub_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminub<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpminub(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminub_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminud<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpminud(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpminud_xmm_xmm_xmmm128 } else { Code::EVEX_Vpminud_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminud<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpminud(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpminud_ymm_ymm_ymmm256 } else { Code::EVEX_Vpminud_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminud<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpminud(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminud_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminud<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpminud(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpminud_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vpminud_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpminud_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpminud<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpminud(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpminud_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vpminud_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpminud_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpminud<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpminud(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminud_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpminuq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpminuq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminuq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminuq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpminuq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminuq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminuq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpminuq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminuq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminuq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpminuq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminuq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpminuq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpminuq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminuq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpminuq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpminuq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminuq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpminuw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpminuw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpminuw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpminuw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminuw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpminuw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpminuw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpminuw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminuw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpminuw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminuw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminuw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpminuw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpminuw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpminuw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminuw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpminuw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpminuw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpminuw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminuw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpminuw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminuw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovb2m<__AsmRegisterK, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovb2m(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovb2m_kr_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovb2m<__AsmRegisterK, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovb2m(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovb2m_kr_ymm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovb2m<__AsmRegisterK, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovb2m(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovb2m_kr_zmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovd2m<__AsmRegisterK, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovd2m(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovd2m_kr_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovd2m<__AsmRegisterK, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovd2m(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovd2m_kr_ymm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovd2m<__AsmRegisterK, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovd2m(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovd2m_kr_zmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovdb<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovdb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovdb_xmmm32_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovdb<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovdb(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovdb_xmmm32_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovdb<__AsmRegisterXmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovdb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovdb_xmmm64_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovdb<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovdb(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovdb_xmmm64_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovdb<__AsmRegisterXmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovdb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovdb_xmmm128_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovdb<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovdb(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovdb_xmmm128_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovdw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovdw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovdw_xmmm64_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovdw<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovdw(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovdw_xmmm64_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovdw<__AsmRegisterXmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovdw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovdw_xmmm128_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovdw<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovdw(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovdw_xmmm128_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovdw<__AsmRegisterYmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovdw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovdw_ymmm256_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovdw<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovdw(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovdw_ymmm256_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovm2b<__AsmRegisterXmm, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn vpmovm2b(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovm2b_xmm_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovm2b<__AsmRegisterYmm, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn vpmovm2b(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovm2b_ymm_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovm2b<__AsmRegisterZmm, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn vpmovm2b(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovm2b_zmm_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovm2d<__AsmRegisterXmm, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn vpmovm2d(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovm2d_xmm_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovm2d<__AsmRegisterYmm, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn vpmovm2d(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovm2d_ymm_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovm2d<__AsmRegisterZmm, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn vpmovm2d(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovm2d_zmm_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovm2q<__AsmRegisterXmm, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn vpmovm2q(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovm2q_xmm_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovm2q<__AsmRegisterYmm, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn vpmovm2q(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovm2q_ymm_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovm2q<__AsmRegisterZmm, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn vpmovm2q(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovm2q_zmm_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovm2w<__AsmRegisterXmm, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn vpmovm2w(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovm2w_xmm_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovm2w<__AsmRegisterYmm, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn vpmovm2w(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovm2w_ymm_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovm2w<__AsmRegisterZmm, __AsmRegisterK> for CodeAssembler {
	#[inline]
	fn vpmovm2w(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovm2w_zmm_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovmskb<__AsmRegister32, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovmskb(&mut self, op0: __AsmRegister32, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vpmovmskb_r32_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovmskb<__AsmRegister64, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovmskb(&mut self, op0: __AsmRegister64, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vpmovmskb_r64_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovmskb<__AsmRegister32, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovmskb(&mut self, op0: __AsmRegister32, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vpmovmskb_r32_ymm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovmskb<__AsmRegister64, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovmskb(&mut self, op0: __AsmRegister64, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vpmovmskb_r64_ymm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovq2m<__AsmRegisterK, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovq2m(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovq2m_kr_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovq2m<__AsmRegisterK, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovq2m(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovq2m_kr_ymm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovq2m<__AsmRegisterK, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovq2m(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovq2m_kr_zmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovqb<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovqb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovqb_xmmm16_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovqb<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovqb(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovqb_xmmm16_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovqb<__AsmRegisterXmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovqb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovqb_xmmm32_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovqb<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovqb(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovqb_xmmm32_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovqb<__AsmRegisterXmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovqb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovqb_xmmm64_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovqb<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovqb(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovqb_xmmm64_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovqd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovqd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovqd_xmmm64_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovqd<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovqd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovqd_xmmm64_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovqd<__AsmRegisterXmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovqd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovqd_xmmm128_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovqd<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovqd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovqd_xmmm128_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovqd<__AsmRegisterYmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovqd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovqd_ymmm256_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovqd<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovqd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovqd_ymmm256_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovqw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovqw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovqw_xmmm32_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovqw<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovqw(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovqw_xmmm32_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovqw<__AsmRegisterXmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovqw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovqw_xmmm64_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovqw<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovqw(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovqw_xmmm64_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovqw<__AsmRegisterXmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovqw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovqw_xmmm128_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovqw<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovqw(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovqw_xmmm128_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsdb<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsdb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsdb_xmmm32_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsdb<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsdb(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsdb_xmmm32_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsdb<__AsmRegisterXmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovsdb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsdb_xmmm64_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsdb<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovsdb(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsdb_xmmm64_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsdb<__AsmRegisterXmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovsdb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsdb_xmmm128_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsdb<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovsdb(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsdb_xmmm128_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsdw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsdw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsdw_xmmm64_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsdw<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsdw(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsdw_xmmm64_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsdw<__AsmRegisterXmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovsdw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsdw_xmmm128_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsdw<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovsdw(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsdw_xmmm128_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsdw<__AsmRegisterYmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovsdw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsdw_ymmm256_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsdw<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovsdw(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsdw_ymmm256_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsqb<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsqb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsqb_xmmm16_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsqb<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsqb(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsqb_xmmm16_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsqb<__AsmRegisterXmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovsqb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsqb_xmmm32_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsqb<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovsqb(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsqb_xmmm32_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsqb<__AsmRegisterXmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovsqb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsqb_xmmm64_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsqb<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovsqb(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsqb_xmmm64_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsqd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsqd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsqd_xmmm64_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsqd<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsqd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsqd_xmmm64_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsqd<__AsmRegisterXmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovsqd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsqd_xmmm128_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsqd<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovsqd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsqd_xmmm128_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsqd<__AsmRegisterYmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovsqd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsqd_ymmm256_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsqd<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovsqd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsqd_ymmm256_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsqw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsqw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsqw_xmmm32_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsqw<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsqw(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsqw_xmmm32_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsqw<__AsmRegisterXmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovsqw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsqw_xmmm64_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsqw<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovsqw(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsqw_xmmm64_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsqw<__AsmRegisterXmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovsqw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsqw_xmmm128_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsqw<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovsqw(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsqw_xmmm128_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovswb<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovswb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovswb_xmmm64_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovswb<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovswb(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovswb_xmmm64_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovswb<__AsmRegisterXmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovswb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovswb_xmmm128_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovswb<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovswb(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovswb_xmmm128_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovswb<__AsmRegisterYmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovswb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovswb_ymmm256_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovswb<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovswb(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovswb_ymmm256_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxbd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsxbd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovsxbd_xmm_xmmm32 } else { Code::EVEX_Vpmovsxbd_xmm_k1z_xmmm32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxbd<__AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsxbd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovsxbd_ymm_xmmm64 } else { Code::EVEX_Vpmovsxbd_ymm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxbd<__AsmRegisterZmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsxbd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsxbd_zmm_k1z_xmmm128, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxbd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovsxbd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovsxbd_xmm_xmmm32 } else { Code::EVEX_Vpmovsxbd_xmm_k1z_xmmm32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxbd<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovsxbd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovsxbd_ymm_xmmm64 } else { Code::EVEX_Vpmovsxbd_ymm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxbd<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovsxbd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsxbd_zmm_k1z_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxbq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsxbq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovsxbq_xmm_xmmm16 } else { Code::EVEX_Vpmovsxbq_xmm_k1z_xmmm16 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxbq<__AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsxbq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovsxbq_ymm_xmmm32 } else { Code::EVEX_Vpmovsxbq_ymm_k1z_xmmm32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxbq<__AsmRegisterZmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsxbq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsxbq_zmm_k1z_xmmm64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxbq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovsxbq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovsxbq_xmm_xmmm16 } else { Code::EVEX_Vpmovsxbq_xmm_k1z_xmmm16 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxbq<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovsxbq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovsxbq_ymm_xmmm32 } else { Code::EVEX_Vpmovsxbq_ymm_k1z_xmmm32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxbq<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovsxbq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsxbq_zmm_k1z_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxbw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsxbw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovsxbw_xmm_xmmm64 } else { Code::EVEX_Vpmovsxbw_xmm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxbw<__AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsxbw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovsxbw_ymm_xmmm128 } else { Code::EVEX_Vpmovsxbw_ymm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxbw<__AsmRegisterZmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovsxbw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsxbw_zmm_k1z_ymmm256, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxbw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovsxbw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovsxbw_xmm_xmmm64 } else { Code::EVEX_Vpmovsxbw_xmm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxbw<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovsxbw(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovsxbw_ymm_xmmm128 } else { Code::EVEX_Vpmovsxbw_ymm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxbw<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovsxbw(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsxbw_zmm_k1z_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxdq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsxdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovsxdq_xmm_xmmm64 } else { Code::EVEX_Vpmovsxdq_xmm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxdq<__AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsxdq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovsxdq_ymm_xmmm128 } else { Code::EVEX_Vpmovsxdq_ymm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxdq<__AsmRegisterZmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovsxdq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsxdq_zmm_k1z_ymmm256, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxdq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovsxdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovsxdq_xmm_xmmm64 } else { Code::EVEX_Vpmovsxdq_xmm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxdq<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovsxdq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovsxdq_ymm_xmmm128 } else { Code::EVEX_Vpmovsxdq_ymm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxdq<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovsxdq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsxdq_zmm_k1z_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxwd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsxwd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovsxwd_xmm_xmmm64 } else { Code::EVEX_Vpmovsxwd_xmm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxwd<__AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsxwd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovsxwd_ymm_xmmm128 } else { Code::EVEX_Vpmovsxwd_ymm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxwd<__AsmRegisterZmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovsxwd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsxwd_zmm_k1z_ymmm256, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxwd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovsxwd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovsxwd_xmm_xmmm64 } else { Code::EVEX_Vpmovsxwd_xmm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxwd<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovsxwd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovsxwd_ymm_xmmm128 } else { Code::EVEX_Vpmovsxwd_ymm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxwd<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovsxwd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsxwd_zmm_k1z_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxwq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsxwq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovsxwq_xmm_xmmm32 } else { Code::EVEX_Vpmovsxwq_xmm_k1z_xmmm32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxwq<__AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsxwq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovsxwq_ymm_xmmm64 } else { Code::EVEX_Vpmovsxwq_ymm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxwq<__AsmRegisterZmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsxwq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsxwq_zmm_k1z_xmmm128, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxwq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovsxwq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovsxwq_xmm_xmmm32 } else { Code::EVEX_Vpmovsxwq_xmm_k1z_xmmm32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxwq<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovsxwq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovsxwq_ymm_xmmm64 } else { Code::EVEX_Vpmovsxwq_ymm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxwq<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovsxwq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsxwq_zmm_k1z_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusdb<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovusdb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusdb_xmmm32_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusdb<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovusdb(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusdb_xmmm32_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusdb<__AsmRegisterXmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovusdb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusdb_xmmm64_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusdb<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovusdb(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusdb_xmmm64_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusdb<__AsmRegisterXmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovusdb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusdb_xmmm128_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusdb<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovusdb(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusdb_xmmm128_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusdw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovusdw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusdw_xmmm64_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusdw<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovusdw(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusdw_xmmm64_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusdw<__AsmRegisterXmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovusdw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusdw_xmmm128_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusdw<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovusdw(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusdw_xmmm128_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusdw<__AsmRegisterYmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovusdw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusdw_ymmm256_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusdw<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovusdw(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusdw_ymmm256_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusqb<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovusqb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusqb_xmmm16_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusqb<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovusqb(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusqb_xmmm16_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusqb<__AsmRegisterXmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovusqb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusqb_xmmm32_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusqb<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovusqb(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusqb_xmmm32_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusqb<__AsmRegisterXmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovusqb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusqb_xmmm64_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusqb<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovusqb(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusqb_xmmm64_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusqd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovusqd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusqd_xmmm64_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusqd<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovusqd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusqd_xmmm64_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusqd<__AsmRegisterXmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovusqd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusqd_xmmm128_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusqd<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovusqd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusqd_xmmm128_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusqd<__AsmRegisterYmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovusqd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusqd_ymmm256_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusqd<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovusqd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusqd_ymmm256_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusqw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovusqw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusqw_xmmm32_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusqw<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovusqw(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusqw_xmmm32_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusqw<__AsmRegisterXmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovusqw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusqw_xmmm64_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusqw<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovusqw(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusqw_xmmm64_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusqw<__AsmRegisterXmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovusqw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusqw_xmmm128_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusqw<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovusqw(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusqw_xmmm128_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovuswb<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovuswb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovuswb_xmmm64_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovuswb<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovuswb(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovuswb_xmmm64_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovuswb<__AsmRegisterXmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovuswb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovuswb_xmmm128_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovuswb<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovuswb(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovuswb_xmmm128_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovuswb<__AsmRegisterYmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovuswb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovuswb_ymmm256_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovuswb<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovuswb(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovuswb_ymmm256_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovw2m<__AsmRegisterK, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovw2m(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovw2m_kr_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovw2m<__AsmRegisterK, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovw2m(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovw2m_kr_ymm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovw2m<__AsmRegisterK, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovw2m(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovw2m_kr_zmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovwb<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovwb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovwb_xmmm64_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovwb<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovwb(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovwb_xmmm64_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovwb<__AsmRegisterXmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovwb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovwb_xmmm128_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovwb<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovwb(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovwb_xmmm128_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovwb<__AsmRegisterYmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovwb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovwb_ymmm256_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovwb<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovwb(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovwb_ymmm256_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxbd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovzxbd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovzxbd_xmm_xmmm32 } else { Code::EVEX_Vpmovzxbd_xmm_k1z_xmmm32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxbd<__AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovzxbd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovzxbd_ymm_xmmm64 } else { Code::EVEX_Vpmovzxbd_ymm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxbd<__AsmRegisterZmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovzxbd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovzxbd_zmm_k1z_xmmm128, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxbd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovzxbd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovzxbd_xmm_xmmm32 } else { Code::EVEX_Vpmovzxbd_xmm_k1z_xmmm32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxbd<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovzxbd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovzxbd_ymm_xmmm64 } else { Code::EVEX_Vpmovzxbd_ymm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxbd<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovzxbd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovzxbd_zmm_k1z_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxbq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovzxbq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovzxbq_xmm_xmmm16 } else { Code::EVEX_Vpmovzxbq_xmm_k1z_xmmm16 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxbq<__AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovzxbq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovzxbq_ymm_xmmm32 } else { Code::EVEX_Vpmovzxbq_ymm_k1z_xmmm32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxbq<__AsmRegisterZmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovzxbq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovzxbq_zmm_k1z_xmmm64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxbq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovzxbq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovzxbq_xmm_xmmm16 } else { Code::EVEX_Vpmovzxbq_xmm_k1z_xmmm16 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxbq<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovzxbq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovzxbq_ymm_xmmm32 } else { Code::EVEX_Vpmovzxbq_ymm_k1z_xmmm32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxbq<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovzxbq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovzxbq_zmm_k1z_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxbw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovzxbw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovzxbw_xmm_xmmm64 } else { Code::EVEX_Vpmovzxbw_xmm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxbw<__AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovzxbw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovzxbw_ymm_xmmm128 } else { Code::EVEX_Vpmovzxbw_ymm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxbw<__AsmRegisterZmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovzxbw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovzxbw_zmm_k1z_ymmm256, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxbw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovzxbw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovzxbw_xmm_xmmm64 } else { Code::EVEX_Vpmovzxbw_xmm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxbw<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovzxbw(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovzxbw_ymm_xmmm128 } else { Code::EVEX_Vpmovzxbw_ymm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxbw<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovzxbw(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovzxbw_zmm_k1z_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxdq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovzxdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovzxdq_xmm_xmmm64 } else { Code::EVEX_Vpmovzxdq_xmm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxdq<__AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovzxdq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovzxdq_ymm_xmmm128 } else { Code::EVEX_Vpmovzxdq_ymm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxdq<__AsmRegisterZmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovzxdq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovzxdq_zmm_k1z_ymmm256, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxdq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovzxdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovzxdq_xmm_xmmm64 } else { Code::EVEX_Vpmovzxdq_xmm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxdq<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovzxdq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovzxdq_ymm_xmmm128 } else { Code::EVEX_Vpmovzxdq_ymm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxdq<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovzxdq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovzxdq_zmm_k1z_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxwd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovzxwd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovzxwd_xmm_xmmm64 } else { Code::EVEX_Vpmovzxwd_xmm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxwd<__AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovzxwd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovzxwd_ymm_xmmm128 } else { Code::EVEX_Vpmovzxwd_ymm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxwd<__AsmRegisterZmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovzxwd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovzxwd_zmm_k1z_ymmm256, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxwd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovzxwd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovzxwd_xmm_xmmm64 } else { Code::EVEX_Vpmovzxwd_xmm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxwd<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovzxwd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovzxwd_ymm_xmmm128 } else { Code::EVEX_Vpmovzxwd_ymm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxwd<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovzxwd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovzxwd_zmm_k1z_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxwq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovzxwq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovzxwq_xmm_xmmm32 } else { Code::EVEX_Vpmovzxwq_xmm_k1z_xmmm32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxwq<__AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovzxwq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovzxwq_ymm_xmmm64 } else { Code::EVEX_Vpmovzxwq_ymm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxwq<__AsmRegisterZmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovzxwq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovzxwq_zmm_k1z_xmmm128, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxwq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovzxwq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovzxwq_xmm_xmmm32 } else { Code::EVEX_Vpmovzxwq_xmm_k1z_xmmm32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxwq<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovzxwq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmovzxwq_ymm_xmmm64 } else { Code::EVEX_Vpmovzxwq_ymm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxwq<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovzxwq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovzxwq_zmm_k1z_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmuldq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmuldq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmuldq_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmuldq_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmuldq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmuldq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmuldq_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmuldq_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmuldq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmuldq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmuldq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmuldq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpmuldq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpmuldq_xmm_k1z_xmm_xmmm128b64
		} else if self.prefer_vex() {
			Code::VEX_Vpmuldq_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpmuldq_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmuldq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpmuldq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpmuldq_ymm_k1z_ymm_ymmm256b64
		} else if self.prefer_vex() {
			Code::VEX_Vpmuldq_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpmuldq_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmuldq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmuldq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmuldq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulhrsw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmulhrsw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmulhrsw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmulhrsw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulhrsw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmulhrsw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmulhrsw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmulhrsw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulhrsw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmulhrsw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmulhrsw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulhrsw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmulhrsw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmulhrsw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmulhrsw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulhrsw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmulhrsw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmulhrsw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmulhrsw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulhrsw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmulhrsw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmulhrsw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulhuw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmulhuw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmulhuw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmulhuw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulhuw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmulhuw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmulhuw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmulhuw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulhuw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmulhuw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmulhuw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulhuw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmulhuw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmulhuw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmulhuw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulhuw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmulhuw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmulhuw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmulhuw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulhuw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmulhuw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmulhuw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulhw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmulhw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmulhw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmulhw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulhw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmulhw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmulhw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmulhw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulhw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmulhw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmulhw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulhw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmulhw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmulhw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmulhw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulhw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmulhw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmulhw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmulhw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulhw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmulhw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmulhw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulld<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmulld(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmulld_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmulld_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulld<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmulld(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmulld_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmulld_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulld<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmulld(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmulld_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulld<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpmulld(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpmulld_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vpmulld_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpmulld_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulld<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpmulld(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpmulld_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vpmulld_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpmulld_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulld<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmulld(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmulld_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmullq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmullq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmullq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmullq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmullq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmullq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmullq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmullq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmullq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmullq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmullq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmullq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmullq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmullq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmullq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmullq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmullq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmullq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmullw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmullw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmullw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmullw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmullw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmullw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmullw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmullw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmullw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmullw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmullw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmullw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmullw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmullw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmullw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmullw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmullw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmullw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmullw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmullw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmullw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmullw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmultishiftqb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmultishiftqb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmultishiftqb_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmultishiftqb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmultishiftqb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmultishiftqb_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmultishiftqb<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmultishiftqb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmultishiftqb_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmultishiftqb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmultishiftqb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmultishiftqb_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmultishiftqb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmultishiftqb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmultishiftqb_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmultishiftqb<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmultishiftqb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmultishiftqb_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmuludq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmuludq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmuludq_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmuludq_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmuludq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmuludq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpmuludq_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmuludq_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmuludq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmuludq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmuludq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmuludq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpmuludq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpmuludq_xmm_k1z_xmm_xmmm128b64
		} else if self.prefer_vex() {
			Code::VEX_Vpmuludq_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpmuludq_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmuludq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpmuludq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpmuludq_ymm_k1z_ymm_ymmm256b64
		} else if self.prefer_vex() {
			Code::VEX_Vpmuludq_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpmuludq_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmuludq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmuludq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmuludq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntb<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpopcntb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntb_xmm_k1z_xmmm128, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntb<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpopcntb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntb_ymm_k1z_ymmm256, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntb<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpopcntb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntb_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntb<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpopcntb(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntb_xmm_k1z_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntb<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpopcntb(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntb_ymm_k1z_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntb<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpopcntb(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntb_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpopcntd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntd_xmm_k1z_xmmm128b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntd<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpopcntd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntd_ymm_k1z_ymmm256b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntd<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpopcntd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntd_zmm_k1z_zmmm512b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpopcntd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntd_xmm_k1z_xmmm128b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntd<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpopcntd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntd_ymm_k1z_ymmm256b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntd<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpopcntd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntd_zmm_k1z_zmmm512b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntq<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpopcntq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntq_xmm_k1z_xmmm128b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntq<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpopcntq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntq_ymm_k1z_ymmm256b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntq<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpopcntq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntq_zmm_k1z_zmmm512b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntq<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpopcntq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntq_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntq<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpopcntq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntq_ymm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntq<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpopcntq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntq_zmm_k1z_zmmm512b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntw<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpopcntw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntw_xmm_k1z_xmmm128, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntw<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpopcntw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntw_ymm_k1z_ymmm256, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntw<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpopcntw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntw_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntw<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpopcntw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntw_xmm_k1z_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntw<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpopcntw(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntw_ymm_k1z_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntw<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpopcntw(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntw_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpor<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpor(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpor_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpor<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpor(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpor_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpor<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpor(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpor_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpor<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpor(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpor_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpord<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpord(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpord_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpord<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpord(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpord_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpord<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpord(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpord_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpord<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpord(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpord_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpord<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpord(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpord_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpord<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpord(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpord_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVporq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vporq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vporq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVporq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vporq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vporq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVporq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vporq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vporq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVporq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vporq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vporq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVporq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vporq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vporq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVporq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vporq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vporq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpperm<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpperm(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpperm_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpperm<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpperm(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpperm_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpperm<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpperm(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpperm_xmm_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprold<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vprold(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprold_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprold<__AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vprold(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprold_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprold<__AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vprold(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprold_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprold<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vprold(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprold_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprold<__AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vprold(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprold_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprold<__AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vprold(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprold_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprold<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vprold(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprold_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprold<__AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vprold(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprold_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprold<__AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vprold(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprold_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprold<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vprold(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprold_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprold<__AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vprold(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprold_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprold<__AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vprold(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprold_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprolq<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vprolq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolq_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprolq<__AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vprolq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolq_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprolq<__AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vprolq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprolq<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vprolq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolq_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprolq<__AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vprolq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolq_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprolq<__AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vprolq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprolq<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vprolq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolq_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprolq<__AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vprolq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolq_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprolq<__AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vprolq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprolq<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vprolq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolq_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprolq<__AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vprolq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolq_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprolq<__AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vprolq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprolvd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vprolvd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolvd_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprolvd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vprolvd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolvd_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprolvd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vprolvd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolvd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprolvd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vprolvd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolvd_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprolvd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vprolvd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolvd_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprolvd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vprolvd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolvd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprolvq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vprolvq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolvq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprolvq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vprolvq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolvq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprolvq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vprolvq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolvq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprolvq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vprolvq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolvq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprolvq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vprolvq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolvq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprolvq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vprolvq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolvq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprord<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vprord(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprord_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprord<__AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vprord(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprord_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprord<__AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vprord(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprord_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprord<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vprord(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprord_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprord<__AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vprord(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprord_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprord<__AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vprord(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprord_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprord<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vprord(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprord_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprord<__AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vprord(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprord_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprord<__AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vprord(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprord_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprord<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vprord(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprord_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprord<__AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vprord(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprord_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprord<__AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vprord(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprord_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprorq<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vprorq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorq_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprorq<__AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vprorq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorq_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprorq<__AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vprorq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprorq<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vprorq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorq_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprorq<__AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vprorq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorq_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprorq<__AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vprorq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprorq<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vprorq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorq_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprorq<__AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vprorq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorq_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprorq<__AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vprorq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprorq<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vprorq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorq_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprorq<__AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vprorq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorq_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprorq<__AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vprorq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprorvd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vprorvd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorvd_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprorvd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vprorvd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorvd_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprorvd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vprorvd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorvd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprorvd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vprorvd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorvd_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprorvd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vprorvd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorvd_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprorvd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vprorvd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorvd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprorvq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vprorvq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorvq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprorvq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vprorvq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorvq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprorvq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vprorvq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorvq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprorvq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vprorvq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorvq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprorvq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vprorvq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorvq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprorvq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vprorvq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorvq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprotb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vprotb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotb_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotb<__AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vprotb(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotb_xmm_xmmm128_xmm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vprotb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotb_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotb<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vprotb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotb_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotb<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vprotb(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotb_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotb<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vprotb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotb_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotb<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vprotb(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotb_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vprotd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotd_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotd<__AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vprotd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotd_xmm_xmmm128_xmm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vprotd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotd_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotd<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vprotd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotd_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotd<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vprotd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotd_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotd<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vprotd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotd_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotd<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vprotd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotd_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vprotq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotq_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotq<__AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vprotq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotq_xmm_xmmm128_xmm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vprotq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotq_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotq<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vprotq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotq_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotq<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vprotq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotq_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotq<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vprotq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotq_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotq<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vprotq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotq_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vprotw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotw_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotw<__AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vprotw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotw_xmm_xmmm128_xmm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vprotw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotw_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotw<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vprotw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotw_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotw<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vprotw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotw_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotw<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vprotw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotw_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotw<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vprotw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotw_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsadbw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsadbw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsadbw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsadbw_xmm_xmm_xmmm128 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsadbw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsadbw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsadbw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsadbw_ymm_ymm_ymmm256 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsadbw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpsadbw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vpsadbw_zmm_zmm_zmmm512, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsadbw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsadbw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsadbw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsadbw_xmm_xmm_xmmm128 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsadbw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsadbw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsadbw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsadbw_ymm_ymm_ymmm256 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsadbw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsadbw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vpsadbw_zmm_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpscatterdd<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpscatterdd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpscatterdd_vm32x_k1_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpscatterdd<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpscatterdd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpscatterdd_vm32y_k1_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpscatterdd<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpscatterdd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpscatterdd_vm32z_k1_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpscatterdq<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpscatterdq(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpscatterdq_vm32x_k1_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpscatterdq<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpscatterdq(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpscatterdq_vm32x_k1_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpscatterdq<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpscatterdq(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpscatterdq_vm32y_k1_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpscatterqd<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	fn vpscatterqd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if op0.index().is_xmm() {
			Code::EVEX_Vpscatterqd_vm64x_k1_xmm
		} else if op0.index().is_ymm() {
			Code::EVEX_Vpscatterqd_vm64y_k1_xmm
		} else {
			return Err(IcedError::new("vpscatterqd: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpscatterqd<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpscatterqd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpscatterqd_vm64z_k1_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpscatterqq<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpscatterqq(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpscatterqq_vm64x_k1_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpscatterqq<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpscatterqq(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpscatterqq_vm64y_k1_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpscatterqq<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpscatterqq(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpscatterqq_vm64z_k1_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshab<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshab(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshab_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshab<__AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshab(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshab_xmm_xmmm128_xmm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshab<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshab(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshab_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshad<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshad(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshad_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshad<__AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshad(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshad_xmm_xmmm128_xmm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshad<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshad(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshad_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshaq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshaq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshaq_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshaq<__AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshaq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshaq_xmm_xmmm128_xmm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshaq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshaq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshaq_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshaw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshaw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshaw_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshaw<__AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshaw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshaw_xmm_xmmm128_xmm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshaw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshaw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshaw_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshlb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshlb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshlb_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshlb<__AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshlb(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshlb_xmm_xmmm128_xmm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshlb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshlb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshlb_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshld<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshld(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshld_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshld<__AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshld(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshld_xmm_xmmm128_xmm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshld<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshld(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshld_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpshldd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldd_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpshldd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldd_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpshldd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldd_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshldd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldd_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshldd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldd_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshldd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldd_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpshldd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldd_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpshldd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldd_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpshldd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldd_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshldd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldd_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshldd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldd_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshldd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldd_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpshldq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldq_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpshldq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldq_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpshldq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldq_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshldq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldq_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshldq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldq_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshldq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldq_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpshldq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldq_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpshldq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldq_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpshldq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldq_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshldq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldq_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshldq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldq_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshldq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldq_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldvd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshldvd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshldvd_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldvd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpshldvd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshldvd_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldvd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpshldvd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshldvd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldvd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshldvd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshldvd_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldvd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshldvd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshldvd_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldvd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshldvd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshldvd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldvq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshldvq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshldvq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldvq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpshldvq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshldvq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldvq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpshldvq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshldvq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldvq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshldvq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshldvq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldvq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshldvq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshldvq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldvq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshldvq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshldvq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldvw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshldvw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshldvw_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldvw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpshldvw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshldvw_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldvw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpshldvw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshldvw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldvw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshldvw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshldvw_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldvw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshldvw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshldvw_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldvw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshldvw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshldvw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpshldw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldw_xmm_k1z_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpshldw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldw_ymm_k1z_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpshldw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldw_zmm_k1z_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshldw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldw_xmm_k1z_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshldw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldw_ymm_k1z_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshldw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldw_zmm_k1z_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpshldw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldw_xmm_k1z_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpshldw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldw_ymm_k1z_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpshldw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldw_zmm_k1z_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshldw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldw_xmm_k1z_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshldw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldw_ymm_k1z_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshldw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldw_zmm_k1z_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshlq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshlq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshlq_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshlq<__AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshlq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshlq_xmm_xmmm128_xmm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshlq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshlq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshlq_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshlw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshlw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshlw_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshlw<__AsmRegisterXmm, __AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshlw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshlw_xmm_xmmm128_xmm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshlw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshlw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshlw_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpshrdd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdd_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpshrdd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdd_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpshrdd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdd_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshrdd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdd_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshrdd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdd_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshrdd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdd_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpshrdd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdd_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpshrdd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdd_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpshrdd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdd_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshrdd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdd_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshrdd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdd_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshrdd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdd_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpshrdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdq_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpshrdq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdq_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpshrdq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdq_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshrdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdq_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshrdq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdq_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshrdq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdq_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpshrdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdq_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpshrdq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdq_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpshrdq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdq_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshrdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdq_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshrdq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdq_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshrdq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdq_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdvd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshrdvd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshrdvd_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdvd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpshrdvd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshrdvd_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdvd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpshrdvd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshrdvd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdvd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshrdvd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshrdvd_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdvd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshrdvd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshrdvd_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdvd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshrdvd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshrdvd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdvq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshrdvq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshrdvq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdvq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpshrdvq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshrdvq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdvq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpshrdvq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshrdvq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdvq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshrdvq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshrdvq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdvq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshrdvq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshrdvq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdvq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshrdvq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshrdvq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdvw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshrdvw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshrdvw_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdvw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpshrdvw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshrdvw_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdvw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpshrdvw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshrdvw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdvw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshrdvw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshrdvw_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdvw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshrdvw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshrdvw_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdvw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshrdvw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshrdvw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpshrdw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdw_xmm_k1z_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpshrdw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdw_ymm_k1z_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpshrdw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdw_zmm_k1z_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshrdw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdw_xmm_k1z_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshrdw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdw_ymm_k1z_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshrdw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdw_zmm_k1z_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpshrdw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdw_xmm_k1z_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpshrdw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdw_ymm_k1z_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpshrdw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdw_zmm_k1z_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshrdw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdw_xmm_k1z_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshrdw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdw_ymm_k1z_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshrdw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdw_zmm_k1z_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshufb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpshufb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpshufb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpshufb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpshufb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpshufb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufb<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpshufb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshufb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshufb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpshufb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpshufb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshufb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpshufb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpshufb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufb<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshufb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshufb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufbitqmb<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshufbitqmb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshufbitqmb_kr_k1_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufbitqmb<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpshufbitqmb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshufbitqmb_kr_k1_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufbitqmb<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpshufbitqmb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshufbitqmb_kr_k1_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufbitqmb<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshufbitqmb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshufbitqmb_kr_k1_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufbitqmb<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshufbitqmb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshufbitqmb_kr_k1_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufbitqmb<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshufbitqmb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshufbitqmb_kr_k1_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufd<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpshufd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpshufd_xmm_xmmm128_imm8 } else { Code::EVEX_Vpshufd_xmm_k1z_xmmm128b32_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufd<__AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpshufd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpshufd_ymm_ymmm256_imm8 } else { Code::EVEX_Vpshufd_ymm_k1z_ymmm256b32_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufd<__AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpshufd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshufd_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufd<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	fn vpshufd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vpshufd_xmm_k1z_xmmm128b32_imm8
		} else if self.prefer_vex() {
			Code::VEX_Vpshufd_xmm_xmmm128_imm8
		} else {
			Code::EVEX_Vpshufd_xmm_k1z_xmmm128b32_imm8
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufd<__AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	fn vpshufd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vpshufd_ymm_k1z_ymmm256b32_imm8
		} else if self.prefer_vex() {
			Code::VEX_Vpshufd_ymm_ymmm256_imm8
		} else {
			Code::EVEX_Vpshufd_ymm_k1z_ymmm256b32_imm8
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufd<__AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshufd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshufd_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufd<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpshufd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpshufd_xmm_xmmm128_imm8 } else { Code::EVEX_Vpshufd_xmm_k1z_xmmm128b32_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufd<__AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpshufd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpshufd_ymm_ymmm256_imm8 } else { Code::EVEX_Vpshufd_ymm_k1z_ymmm256b32_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufd<__AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpshufd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshufd_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufd<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	fn vpshufd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vpshufd_xmm_k1z_xmmm128b32_imm8
		} else if self.prefer_vex() {
			Code::VEX_Vpshufd_xmm_xmmm128_imm8
		} else {
			Code::EVEX_Vpshufd_xmm_k1z_xmmm128b32_imm8
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufd<__AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	fn vpshufd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vpshufd_ymm_k1z_ymmm256b32_imm8
		} else if self.prefer_vex() {
			Code::VEX_Vpshufd_ymm_ymmm256_imm8
		} else {
			Code::EVEX_Vpshufd_ymm_k1z_ymmm256b32_imm8
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufd<__AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshufd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshufd_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufhw<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpshufhw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpshufhw_xmm_xmmm128_imm8 } else { Code::EVEX_Vpshufhw_xmm_k1z_xmmm128_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufhw<__AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpshufhw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpshufhw_ymm_ymmm256_imm8 } else { Code::EVEX_Vpshufhw_ymm_k1z_ymmm256_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufhw<__AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpshufhw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshufhw_zmm_k1z_zmmm512_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufhw<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshufhw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpshufhw_xmm_xmmm128_imm8 } else { Code::EVEX_Vpshufhw_xmm_k1z_xmmm128_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufhw<__AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshufhw(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpshufhw_ymm_ymmm256_imm8 } else { Code::EVEX_Vpshufhw_ymm_k1z_ymmm256_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufhw<__AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshufhw(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshufhw_zmm_k1z_zmmm512_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufhw<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpshufhw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpshufhw_xmm_xmmm128_imm8 } else { Code::EVEX_Vpshufhw_xmm_k1z_xmmm128_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufhw<__AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpshufhw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpshufhw_ymm_ymmm256_imm8 } else { Code::EVEX_Vpshufhw_ymm_k1z_ymmm256_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufhw<__AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpshufhw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshufhw_zmm_k1z_zmmm512_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufhw<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshufhw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpshufhw_xmm_xmmm128_imm8 } else { Code::EVEX_Vpshufhw_xmm_k1z_xmmm128_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufhw<__AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshufhw(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpshufhw_ymm_ymmm256_imm8 } else { Code::EVEX_Vpshufhw_ymm_k1z_ymmm256_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufhw<__AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshufhw(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshufhw_zmm_k1z_zmmm512_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshuflw<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpshuflw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpshuflw_xmm_xmmm128_imm8 } else { Code::EVEX_Vpshuflw_xmm_k1z_xmmm128_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshuflw<__AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpshuflw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpshuflw_ymm_ymmm256_imm8 } else { Code::EVEX_Vpshuflw_ymm_k1z_ymmm256_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshuflw<__AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpshuflw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshuflw_zmm_k1z_zmmm512_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshuflw<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshuflw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpshuflw_xmm_xmmm128_imm8 } else { Code::EVEX_Vpshuflw_xmm_k1z_xmmm128_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshuflw<__AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshuflw(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpshuflw_ymm_ymmm256_imm8 } else { Code::EVEX_Vpshuflw_ymm_k1z_ymmm256_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshuflw<__AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshuflw(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshuflw_zmm_k1z_zmmm512_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshuflw<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpshuflw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpshuflw_xmm_xmmm128_imm8 } else { Code::EVEX_Vpshuflw_xmm_k1z_xmmm128_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshuflw<__AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpshuflw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpshuflw_ymm_ymmm256_imm8 } else { Code::EVEX_Vpshuflw_ymm_k1z_ymmm256_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshuflw<__AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpshuflw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshuflw_zmm_k1z_zmmm512_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshuflw<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshuflw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpshuflw_xmm_xmmm128_imm8 } else { Code::EVEX_Vpshuflw_xmm_k1z_xmmm128_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshuflw<__AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshuflw(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpshuflw_ymm_ymmm256_imm8 } else { Code::EVEX_Vpshuflw_ymm_k1z_ymmm256_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshuflw<__AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshuflw(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshuflw_zmm_k1z_zmmm512_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsignb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsignb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpsignb_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsignb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsignb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpsignb_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsignb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsignb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpsignb_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsignb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsignb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpsignb_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsignd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsignd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpsignd_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsignd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsignd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpsignd_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsignd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsignd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpsignd_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsignd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsignd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpsignd_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsignw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsignw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpsignw_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsignw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsignw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpsignw_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsignw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsignw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpsignw_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsignw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsignw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpsignw_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpslld<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpslld(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpslld_xmm_xmm_xmmm128 } else { Code::EVEX_Vpslld_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpslld<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpslld(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpslld_ymm_ymm_xmmm128 } else { Code::EVEX_Vpslld_ymm_k1z_ymm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpslld<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpslld(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpslld_zmm_k1z_zmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpslld<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpslld(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpslld_xmm_xmm_xmmm128 } else { Code::EVEX_Vpslld_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpslld<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpslld(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpslld_ymm_ymm_xmmm128 } else { Code::EVEX_Vpslld_ymm_k1z_ymm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpslld<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpslld(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpslld_zmm_k1z_zmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpslld<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpslld(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpslld_xmm_xmm_imm8 } else { Code::EVEX_Vpslld_xmm_k1z_xmmm128b32_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpslld<__AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpslld(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpslld_ymm_ymm_imm8 } else { Code::EVEX_Vpslld_ymm_k1z_ymmm256b32_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpslld<__AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpslld(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpslld_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpslld<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpslld(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpslld_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpslld<__AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpslld(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpslld_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpslld<__AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpslld(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpslld_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpslld<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpslld(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpslld_xmm_xmm_imm8 } else { Code::EVEX_Vpslld_xmm_k1z_xmmm128b32_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpslld<__AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpslld(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpslld_ymm_ymm_imm8 } else { Code::EVEX_Vpslld_ymm_k1z_ymmm256b32_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpslld<__AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpslld(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpslld_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpslld<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpslld(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpslld_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpslld<__AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpslld(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpslld_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpslld<__AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpslld(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpslld_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpslldq<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpslldq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpslldq_xmm_xmm_imm8 } else { Code::EVEX_Vpslldq_xmm_xmmm128_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpslldq<__AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpslldq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpslldq_ymm_ymm_imm8 } else { Code::EVEX_Vpslldq_ymm_ymmm256_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpslldq<__AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpslldq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vpslldq_zmm_zmmm512_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpslldq<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpslldq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vpslldq_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpslldq<__AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpslldq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vpslldq_ymm_ymmm256_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpslldq<__AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpslldq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vpslldq_zmm_zmmm512_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpslldq<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpslldq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpslldq_xmm_xmm_imm8 } else { Code::EVEX_Vpslldq_xmm_xmmm128_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpslldq<__AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpslldq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpslldq_ymm_ymm_imm8 } else { Code::EVEX_Vpslldq_ymm_ymmm256_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpslldq<__AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpslldq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vpslldq_zmm_zmmm512_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpslldq<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpslldq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vpslldq_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpslldq<__AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpslldq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vpslldq_ymm_ymmm256_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpslldq<__AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpslldq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vpslldq_zmm_zmmm512_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsllq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsllq_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsllq_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsllq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsllq_ymm_ymm_xmmm128 } else { Code::EVEX_Vpsllq_ymm_k1z_ymm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsllq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllq_zmm_k1z_zmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsllq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsllq_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsllq_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsllq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsllq_ymm_ymm_xmmm128 } else { Code::EVEX_Vpsllq_ymm_k1z_ymm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsllq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllq_zmm_k1z_zmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllq<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpsllq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsllq_xmm_xmm_imm8 } else { Code::EVEX_Vpsllq_xmm_k1z_xmmm128b64_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllq<__AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpsllq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsllq_ymm_ymm_imm8 } else { Code::EVEX_Vpsllq_ymm_k1z_ymmm256b64_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllq<__AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpsllq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllq<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsllq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllq_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllq<__AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsllq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllq_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllq<__AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsllq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllq<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpsllq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsllq_xmm_xmm_imm8 } else { Code::EVEX_Vpsllq_xmm_k1z_xmmm128b64_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllq<__AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpsllq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsllq_ymm_ymm_imm8 } else { Code::EVEX_Vpsllq_ymm_k1z_ymmm256b64_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllq<__AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpsllq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllq<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsllq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllq_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllq<__AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsllq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllq_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllq<__AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsllq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllvd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsllvd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsllvd_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsllvd_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllvd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsllvd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsllvd_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsllvd_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllvd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpsllvd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllvd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllvd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpsllvd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpsllvd_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vpsllvd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpsllvd_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllvd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpsllvd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpsllvd_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vpsllvd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpsllvd_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllvd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsllvd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllvd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllvq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsllvq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsllvq_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsllvq_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllvq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsllvq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsllvq_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsllvq_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllvq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpsllvq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllvq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllvq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpsllvq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpsllvq_xmm_k1z_xmm_xmmm128b64
		} else if self.prefer_vex() {
			Code::VEX_Vpsllvq_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpsllvq_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllvq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpsllvq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpsllvq_ymm_k1z_ymm_ymmm256b64
		} else if self.prefer_vex() {
			Code::VEX_Vpsllvq_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpsllvq_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllvq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsllvq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllvq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllvw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsllvw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllvw_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllvw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsllvw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllvw_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllvw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpsllvw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllvw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllvw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsllvw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllvw_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllvw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsllvw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllvw_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllvw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsllvw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllvw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsllw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsllw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsllw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsllw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsllw_ymm_ymm_xmmm128 } else { Code::EVEX_Vpsllw_ymm_k1z_ymm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsllw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllw_zmm_k1z_zmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsllw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsllw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsllw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsllw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsllw_ymm_ymm_xmmm128 } else { Code::EVEX_Vpsllw_ymm_k1z_ymm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsllw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllw_zmm_k1z_zmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllw<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpsllw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsllw_xmm_xmm_imm8 } else { Code::EVEX_Vpsllw_xmm_k1z_xmmm128_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllw<__AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpsllw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsllw_ymm_ymm_imm8 } else { Code::EVEX_Vpsllw_ymm_k1z_ymmm256_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllw<__AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpsllw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllw_zmm_k1z_zmmm512_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllw<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsllw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllw_xmm_k1z_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllw<__AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsllw(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllw_ymm_k1z_ymmm256_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllw<__AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsllw(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllw_zmm_k1z_zmmm512_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllw<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpsllw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsllw_xmm_xmm_imm8 } else { Code::EVEX_Vpsllw_xmm_k1z_xmmm128_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllw<__AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpsllw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsllw_ymm_ymm_imm8 } else { Code::EVEX_Vpsllw_ymm_k1z_ymmm256_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllw<__AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpsllw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllw_zmm_k1z_zmmm512_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllw<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsllw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllw_xmm_k1z_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllw<__AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsllw(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllw_ymm_k1z_ymmm256_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllw<__AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsllw(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllw_zmm_k1z_zmmm512_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrad<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsrad(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsrad_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsrad_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrad<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsrad(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsrad_ymm_ymm_xmmm128 } else { Code::EVEX_Vpsrad_ymm_k1z_ymm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrad<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsrad(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrad_zmm_k1z_zmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrad<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsrad(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsrad_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsrad_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrad<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsrad(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsrad_ymm_ymm_xmmm128 } else { Code::EVEX_Vpsrad_ymm_k1z_ymm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrad<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsrad(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrad_zmm_k1z_zmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrad<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpsrad(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsrad_xmm_xmm_imm8 } else { Code::EVEX_Vpsrad_xmm_k1z_xmmm128b32_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrad<__AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpsrad(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsrad_ymm_ymm_imm8 } else { Code::EVEX_Vpsrad_ymm_k1z_ymmm256b32_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrad<__AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpsrad(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrad_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrad<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsrad(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrad_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrad<__AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsrad(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrad_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrad<__AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsrad(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrad_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrad<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpsrad(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsrad_xmm_xmm_imm8 } else { Code::EVEX_Vpsrad_xmm_k1z_xmmm128b32_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrad<__AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpsrad(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsrad_ymm_ymm_imm8 } else { Code::EVEX_Vpsrad_ymm_k1z_ymmm256b32_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrad<__AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpsrad(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrad_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrad<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsrad(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrad_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrad<__AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsrad(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrad_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrad<__AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsrad(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrad_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsraq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraq_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsraq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraq_ymm_k1z_ymm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsraq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraq_zmm_k1z_zmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsraq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraq_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsraq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraq_ymm_k1z_ymm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsraq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraq_zmm_k1z_zmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraq<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpsraq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraq_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraq<__AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpsraq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraq_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraq<__AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpsraq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraq<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsraq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraq_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraq<__AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsraq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraq_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraq<__AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsraq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraq<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpsraq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraq_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraq<__AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpsraq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraq_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraq<__AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpsraq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraq<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsraq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraq_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraq<__AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsraq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraq_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraq<__AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsraq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsravd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsravd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsravd_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsravd_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsravd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsravd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsravd_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsravd_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsravd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpsravd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsravd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsravd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpsravd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpsravd_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vpsravd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpsravd_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsravd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpsravd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpsravd_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vpsravd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpsravd_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsravd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsravd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsravd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsravq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsravq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsravq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsravq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsravq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsravq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsravq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpsravq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsravq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsravq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsravq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsravq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsravq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsravq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsravq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsravq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsravq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsravq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsravw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsravw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsravw_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsravw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsravw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsravw_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsravw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpsravw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsravw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsravw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsravw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsravw_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsravw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsravw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsravw_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsravw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsravw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsravw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsraw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsraw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsraw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsraw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsraw_ymm_ymm_xmmm128 } else { Code::EVEX_Vpsraw_ymm_k1z_ymm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsraw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraw_zmm_k1z_zmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsraw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsraw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsraw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsraw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsraw_ymm_ymm_xmmm128 } else { Code::EVEX_Vpsraw_ymm_k1z_ymm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsraw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraw_zmm_k1z_zmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraw<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpsraw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsraw_xmm_xmm_imm8 } else { Code::EVEX_Vpsraw_xmm_k1z_xmmm128_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraw<__AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpsraw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsraw_ymm_ymm_imm8 } else { Code::EVEX_Vpsraw_ymm_k1z_ymmm256_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraw<__AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpsraw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraw_zmm_k1z_zmmm512_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraw<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsraw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraw_xmm_k1z_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraw<__AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsraw(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraw_ymm_k1z_ymmm256_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraw<__AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsraw(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraw_zmm_k1z_zmmm512_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraw<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpsraw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsraw_xmm_xmm_imm8 } else { Code::EVEX_Vpsraw_xmm_k1z_xmmm128_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraw<__AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpsraw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsraw_ymm_ymm_imm8 } else { Code::EVEX_Vpsraw_ymm_k1z_ymmm256_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraw<__AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpsraw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraw_zmm_k1z_zmmm512_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraw<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsraw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraw_xmm_k1z_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraw<__AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsraw(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraw_ymm_k1z_ymmm256_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraw<__AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsraw(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraw_zmm_k1z_zmmm512_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrld<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsrld(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsrld_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsrld_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrld<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsrld(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsrld_ymm_ymm_xmmm128 } else { Code::EVEX_Vpsrld_ymm_k1z_ymm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrld<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsrld(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrld_zmm_k1z_zmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrld<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsrld(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsrld_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsrld_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrld<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsrld(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsrld_ymm_ymm_xmmm128 } else { Code::EVEX_Vpsrld_ymm_k1z_ymm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrld<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsrld(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrld_zmm_k1z_zmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrld<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpsrld(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsrld_xmm_xmm_imm8 } else { Code::EVEX_Vpsrld_xmm_k1z_xmmm128b32_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrld<__AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpsrld(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsrld_ymm_ymm_imm8 } else { Code::EVEX_Vpsrld_ymm_k1z_ymmm256b32_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrld<__AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpsrld(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrld_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrld<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsrld(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrld_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrld<__AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsrld(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrld_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrld<__AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsrld(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrld_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrld<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpsrld(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsrld_xmm_xmm_imm8 } else { Code::EVEX_Vpsrld_xmm_k1z_xmmm128b32_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrld<__AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpsrld(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsrld_ymm_ymm_imm8 } else { Code::EVEX_Vpsrld_ymm_k1z_ymmm256b32_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrld<__AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpsrld(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrld_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrld<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsrld(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrld_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrld<__AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsrld(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrld_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrld<__AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsrld(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrld_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrldq<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpsrldq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsrldq_xmm_xmm_imm8 } else { Code::EVEX_Vpsrldq_xmm_xmmm128_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrldq<__AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpsrldq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsrldq_ymm_ymm_imm8 } else { Code::EVEX_Vpsrldq_ymm_ymmm256_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrldq<__AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpsrldq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vpsrldq_zmm_zmmm512_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrldq<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsrldq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vpsrldq_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrldq<__AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsrldq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vpsrldq_ymm_ymmm256_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrldq<__AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsrldq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vpsrldq_zmm_zmmm512_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrldq<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpsrldq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsrldq_xmm_xmm_imm8 } else { Code::EVEX_Vpsrldq_xmm_xmmm128_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrldq<__AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpsrldq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsrldq_ymm_ymm_imm8 } else { Code::EVEX_Vpsrldq_ymm_ymmm256_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrldq<__AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpsrldq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vpsrldq_zmm_zmmm512_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrldq<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsrldq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vpsrldq_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrldq<__AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsrldq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vpsrldq_ymm_ymmm256_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrldq<__AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsrldq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vpsrldq_zmm_zmmm512_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsrlq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsrlq_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsrlq_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsrlq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsrlq_ymm_ymm_xmmm128 } else { Code::EVEX_Vpsrlq_ymm_k1z_ymm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsrlq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlq_zmm_k1z_zmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsrlq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsrlq_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsrlq_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsrlq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsrlq_ymm_ymm_xmmm128 } else { Code::EVEX_Vpsrlq_ymm_k1z_ymm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsrlq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlq_zmm_k1z_zmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlq<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpsrlq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsrlq_xmm_xmm_imm8 } else { Code::EVEX_Vpsrlq_xmm_k1z_xmmm128b64_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlq<__AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpsrlq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsrlq_ymm_ymm_imm8 } else { Code::EVEX_Vpsrlq_ymm_k1z_ymmm256b64_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlq<__AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpsrlq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlq<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsrlq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlq_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlq<__AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsrlq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlq_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlq<__AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsrlq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlq<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpsrlq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsrlq_xmm_xmm_imm8 } else { Code::EVEX_Vpsrlq_xmm_k1z_xmmm128b64_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlq<__AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpsrlq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsrlq_ymm_ymm_imm8 } else { Code::EVEX_Vpsrlq_ymm_k1z_ymmm256b64_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlq<__AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpsrlq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlq<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsrlq(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlq_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlq<__AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsrlq(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlq_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlq<__AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsrlq(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlvd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsrlvd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsrlvd_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsrlvd_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlvd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsrlvd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsrlvd_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsrlvd_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlvd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpsrlvd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlvd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlvd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpsrlvd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpsrlvd_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vpsrlvd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpsrlvd_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlvd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpsrlvd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpsrlvd_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vpsrlvd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpsrlvd_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlvd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsrlvd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlvd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlvq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsrlvq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsrlvq_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsrlvq_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlvq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsrlvq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsrlvq_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsrlvq_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlvq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpsrlvq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlvq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlvq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpsrlvq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpsrlvq_xmm_k1z_xmm_xmmm128b64
		} else if self.prefer_vex() {
			Code::VEX_Vpsrlvq_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpsrlvq_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlvq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpsrlvq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpsrlvq_ymm_k1z_ymm_ymmm256b64
		} else if self.prefer_vex() {
			Code::VEX_Vpsrlvq_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpsrlvq_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlvq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsrlvq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlvq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlvw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsrlvw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlvw_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlvw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsrlvw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlvw_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlvw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpsrlvw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlvw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlvw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsrlvw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlvw_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlvw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsrlvw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlvw_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlvw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsrlvw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlvw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsrlw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsrlw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsrlw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsrlw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsrlw_ymm_ymm_xmmm128 } else { Code::EVEX_Vpsrlw_ymm_k1z_ymm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsrlw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlw_zmm_k1z_zmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsrlw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsrlw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsrlw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsrlw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsrlw_ymm_ymm_xmmm128 } else { Code::EVEX_Vpsrlw_ymm_k1z_ymm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsrlw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlw_zmm_k1z_zmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlw<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpsrlw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsrlw_xmm_xmm_imm8 } else { Code::EVEX_Vpsrlw_xmm_k1z_xmmm128_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlw<__AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpsrlw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsrlw_ymm_ymm_imm8 } else { Code::EVEX_Vpsrlw_ymm_k1z_ymmm256_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlw<__AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpsrlw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlw_zmm_k1z_zmmm512_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlw<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsrlw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlw_xmm_k1z_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlw<__AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsrlw(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlw_ymm_k1z_ymmm256_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlw<__AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsrlw(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlw_zmm_k1z_zmmm512_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlw<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpsrlw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsrlw_xmm_xmm_imm8 } else { Code::EVEX_Vpsrlw_xmm_k1z_xmmm128_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlw<__AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpsrlw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsrlw_ymm_ymm_imm8 } else { Code::EVEX_Vpsrlw_ymm_k1z_ymmm256_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlw<__AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpsrlw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlw_zmm_k1z_zmmm512_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlw<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsrlw(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlw_xmm_k1z_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlw<__AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsrlw(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlw_ymm_k1z_ymmm256_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlw<__AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsrlw(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlw_zmm_k1z_zmmm512_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsubb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsubb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsubb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsubb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsubb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsubb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubb<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpsubb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsubb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsubb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsubb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsubb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsubb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsubb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsubb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubb<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsubb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsubb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsubd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsubd_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsubd_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsubd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsubd_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsubd_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpsubd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsubd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpsubd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpsubd_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vpsubd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpsubd_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpsubd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpsubd_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vpsubd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpsubd_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsubd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsubd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsubq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsubq_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsubq_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsubq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsubq_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsubq_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpsubq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsubq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpsubq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpsubq_xmm_k1z_xmm_xmmm128b64
		} else if self.prefer_vex() {
			Code::VEX_Vpsubq_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpsubq_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpsubq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpsubq_ymm_k1z_ymm_ymmm256b64
		} else if self.prefer_vex() {
			Code::VEX_Vpsubq_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpsubq_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsubq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsubq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubsb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsubsb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsubsb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsubsb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubsb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsubsb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsubsb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsubsb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubsb<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpsubsb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsubsb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubsb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsubsb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsubsb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsubsb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubsb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsubsb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsubsb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsubsb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubsb<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsubsb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsubsb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubsw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsubsw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsubsw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsubsw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubsw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsubsw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsubsw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsubsw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubsw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpsubsw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsubsw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubsw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsubsw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsubsw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsubsw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubsw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsubsw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsubsw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsubsw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubsw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsubsw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsubsw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubusb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsubusb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsubusb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsubusb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubusb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsubusb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsubusb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsubusb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubusb<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpsubusb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsubusb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubusb<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsubusb(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsubusb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsubusb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubusb<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsubusb(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsubusb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsubusb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubusb<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsubusb(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsubusb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubusw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsubusw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsubusw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsubusw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubusw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsubusw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsubusw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsubusw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubusw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpsubusw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsubusw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubusw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsubusw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsubusw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsubusw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubusw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsubusw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsubusw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsubusw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubusw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsubusw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsubusw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsubw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsubw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsubw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsubw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsubw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsubw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpsubw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsubw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsubw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsubw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsubw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsubw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpsubw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsubw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsubw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsubw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpternlogd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogd_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpternlogd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogd_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpternlogd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogd_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpternlogd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogd_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpternlogd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogd_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpternlogd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogd_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpternlogd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogd_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpternlogd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogd_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpternlogd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogd_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpternlogd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogd_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpternlogd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogd_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpternlogd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogd_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpternlogq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogq_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpternlogq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogq_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpternlogq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogq_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpternlogq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogq_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpternlogq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogq_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpternlogq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogq_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpternlogq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogq_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpternlogq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogq_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpternlogq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogq_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpternlogq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogq_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpternlogq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogq_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpternlogq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogq_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVptest<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vptest(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vptest_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVptest<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vptest(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vptest_ymm_ymmm256, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVptest<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptest(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vptest_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVptest<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptest(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vptest_ymm_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmb<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vptestmb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmb_kr_k1_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmb<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vptestmb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmb_kr_k1_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmb<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vptestmb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmb_kr_k1_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmb<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestmb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmb_kr_k1_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmb<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestmb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmb_kr_k1_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmb<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestmb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmb_kr_k1_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vptestmd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmd_kr_k1_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vptestmd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmd_kr_k1_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vptestmd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmd_kr_k1_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestmd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmd_kr_k1_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestmd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmd_kr_k1_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestmd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmd_kr_k1_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmq<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vptestmq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmq_kr_k1_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmq<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vptestmq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmq_kr_k1_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmq<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vptestmq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmq_kr_k1_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmq<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestmq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmq_kr_k1_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmq<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestmq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmq_kr_k1_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmq<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestmq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmq_kr_k1_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmw<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vptestmw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmw_kr_k1_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmw<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vptestmw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmw_kr_k1_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmw<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vptestmw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmw_kr_k1_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmw<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestmw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmw_kr_k1_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmw<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestmw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmw_kr_k1_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmw<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestmw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmw_kr_k1_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmb<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vptestnmb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmb_kr_k1_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmb<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vptestnmb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmb_kr_k1_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmb<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vptestnmb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmb_kr_k1_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmb<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestnmb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmb_kr_k1_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmb<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestnmb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmb_kr_k1_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmb<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestnmb(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmb_kr_k1_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmd<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vptestnmd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmd_kr_k1_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmd<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vptestnmd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmd_kr_k1_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmd<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vptestnmd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmd_kr_k1_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmd<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestnmd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmd_kr_k1_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmd<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestnmd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmd_kr_k1_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmd<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestnmd(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmd_kr_k1_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmq<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vptestnmq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmq_kr_k1_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmq<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vptestnmq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmq_kr_k1_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmq<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vptestnmq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmq_kr_k1_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmq<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestnmq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmq_kr_k1_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmq<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestnmq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmq_kr_k1_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmq<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestnmq(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmq_kr_k1_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmw<__AsmRegisterK, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vptestnmw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmw_kr_k1_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmw<__AsmRegisterK, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vptestnmw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmw_kr_k1_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmw<__AsmRegisterK, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vptestnmw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmw_kr_k1_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmw<__AsmRegisterK, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestnmw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmw_kr_k1_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmw<__AsmRegisterK, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestnmw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmw_kr_k1_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmw<__AsmRegisterK, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestnmw(&mut self, op0: __AsmRegisterK, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmw_kr_k1_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhbw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpunpckhbw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpunpckhbw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpunpckhbw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhbw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpunpckhbw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpunpckhbw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpunpckhbw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhbw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpunpckhbw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpunpckhbw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhbw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpunpckhbw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpunpckhbw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpunpckhbw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhbw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpunpckhbw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpunpckhbw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpunpckhbw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhbw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpunpckhbw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpunpckhbw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhdq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpunpckhdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpunpckhdq_xmm_xmm_xmmm128 } else { Code::EVEX_Vpunpckhdq_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhdq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpunpckhdq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpunpckhdq_ymm_ymm_ymmm256 } else { Code::EVEX_Vpunpckhdq_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhdq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpunpckhdq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpunpckhdq_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhdq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpunpckhdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpunpckhdq_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vpunpckhdq_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpunpckhdq_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhdq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpunpckhdq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpunpckhdq_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vpunpckhdq_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpunpckhdq_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhdq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpunpckhdq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpunpckhdq_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhqdq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpunpckhqdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpunpckhqdq_xmm_xmm_xmmm128 } else { Code::EVEX_Vpunpckhqdq_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhqdq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpunpckhqdq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpunpckhqdq_ymm_ymm_ymmm256 } else { Code::EVEX_Vpunpckhqdq_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhqdq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpunpckhqdq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpunpckhqdq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhqdq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpunpckhqdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpunpckhqdq_xmm_k1z_xmm_xmmm128b64
		} else if self.prefer_vex() {
			Code::VEX_Vpunpckhqdq_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpunpckhqdq_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhqdq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpunpckhqdq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpunpckhqdq_ymm_k1z_ymm_ymmm256b64
		} else if self.prefer_vex() {
			Code::VEX_Vpunpckhqdq_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpunpckhqdq_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhqdq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpunpckhqdq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpunpckhqdq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhwd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpunpckhwd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpunpckhwd_xmm_xmm_xmmm128 } else { Code::EVEX_Vpunpckhwd_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhwd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpunpckhwd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpunpckhwd_ymm_ymm_ymmm256 } else { Code::EVEX_Vpunpckhwd_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhwd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpunpckhwd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpunpckhwd_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhwd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpunpckhwd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpunpckhwd_xmm_xmm_xmmm128 } else { Code::EVEX_Vpunpckhwd_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhwd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpunpckhwd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpunpckhwd_ymm_ymm_ymmm256 } else { Code::EVEX_Vpunpckhwd_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhwd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpunpckhwd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpunpckhwd_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpcklbw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpunpcklbw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpunpcklbw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpunpcklbw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpcklbw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpunpcklbw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpunpcklbw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpunpcklbw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpcklbw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpunpcklbw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpunpcklbw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpcklbw<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpunpcklbw(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpunpcklbw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpunpcklbw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpcklbw<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpunpcklbw(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpunpcklbw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpunpcklbw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpcklbw<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpunpcklbw(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpunpcklbw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckldq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpunpckldq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpunpckldq_xmm_xmm_xmmm128 } else { Code::EVEX_Vpunpckldq_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckldq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpunpckldq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpunpckldq_ymm_ymm_ymmm256 } else { Code::EVEX_Vpunpckldq_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckldq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpunpckldq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpunpckldq_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckldq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpunpckldq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpunpckldq_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vpunpckldq_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpunpckldq_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckldq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpunpckldq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpunpckldq_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vpunpckldq_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpunpckldq_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckldq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpunpckldq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpunpckldq_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpcklqdq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpunpcklqdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpunpcklqdq_xmm_xmm_xmmm128 } else { Code::EVEX_Vpunpcklqdq_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpcklqdq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpunpcklqdq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpunpcklqdq_ymm_ymm_ymmm256 } else { Code::EVEX_Vpunpcklqdq_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpcklqdq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpunpcklqdq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpunpcklqdq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpcklqdq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpunpcklqdq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpunpcklqdq_xmm_k1z_xmm_xmmm128b64
		} else if self.prefer_vex() {
			Code::VEX_Vpunpcklqdq_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpunpcklqdq_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpcklqdq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vpunpcklqdq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpunpcklqdq_ymm_k1z_ymm_ymmm256b64
		} else if self.prefer_vex() {
			Code::VEX_Vpunpcklqdq_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpunpcklqdq_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpcklqdq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpunpcklqdq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpunpcklqdq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpcklwd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpunpcklwd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpunpcklwd_xmm_xmm_xmmm128 } else { Code::EVEX_Vpunpcklwd_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpcklwd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpunpcklwd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpunpcklwd_ymm_ymm_ymmm256 } else { Code::EVEX_Vpunpcklwd_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpcklwd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpunpcklwd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpunpcklwd_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpcklwd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpunpcklwd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpunpcklwd_xmm_xmm_xmmm128 } else { Code::EVEX_Vpunpcklwd_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpcklwd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpunpcklwd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vpunpcklwd_ymm_ymm_ymmm256 } else { Code::EVEX_Vpunpcklwd_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpcklwd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpunpcklwd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpunpcklwd_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpxor<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpxor(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpxor_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpxor<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpxor(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpxor_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpxor<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpxor(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpxor_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpxor<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpxor(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpxor_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpxord<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpxord(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpxord_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpxord<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpxord(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpxord_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpxord<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpxord(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpxord_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpxord<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpxord(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpxord_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpxord<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpxord(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpxord_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpxord<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpxord(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpxord_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpxorq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpxorq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpxorq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpxorq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpxorq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpxorq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpxorq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpxorq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpxorq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpxorq<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpxorq(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpxorq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpxorq<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpxorq(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpxorq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpxorq<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpxorq(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpxorq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangepd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vrangepd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangepd_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrangepd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vrangepd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangepd_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrangepd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vrangepd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangepd_zmm_k1z_zmm_zmmm512b64_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangepd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vrangepd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangepd_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangepd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vrangepd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangepd_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangepd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vrangepd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangepd_zmm_k1z_zmm_zmmm512b64_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangepd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vrangepd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangepd_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrangepd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vrangepd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangepd_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrangepd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vrangepd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangepd_zmm_k1z_zmm_zmmm512b64_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangepd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vrangepd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangepd_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangepd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vrangepd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangepd_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangepd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vrangepd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangepd_zmm_k1z_zmm_zmmm512b64_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangeps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vrangeps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangeps_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrangeps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vrangeps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangeps_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrangeps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vrangeps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangeps_zmm_k1z_zmm_zmmm512b32_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangeps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vrangeps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangeps_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangeps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vrangeps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangeps_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangeps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vrangeps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangeps_zmm_k1z_zmm_zmmm512b32_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangeps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vrangeps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangeps_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrangeps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vrangeps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangeps_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrangeps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vrangeps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangeps_zmm_k1z_zmm_zmmm512b32_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangeps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vrangeps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangeps_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangeps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vrangeps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangeps_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangeps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vrangeps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangeps_zmm_k1z_zmm_zmmm512b32_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangesd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vrangesd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangesd_xmm_k1z_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangesd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vrangesd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangesd_xmm_k1z_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangesd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vrangesd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangesd_xmm_k1z_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangesd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vrangesd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangesd_xmm_k1z_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangess<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vrangess(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangess_xmm_k1z_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangess<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vrangess(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangess_xmm_k1z_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangess<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vrangess(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangess_xmm_k1z_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangess<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vrangess(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangess_xmm_k1z_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp14pd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vrcp14pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcp14pd_xmm_k1z_xmmm128b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp14pd<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vrcp14pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcp14pd_ymm_k1z_ymmm256b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp14pd<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vrcp14pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcp14pd_zmm_k1z_zmmm512b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp14pd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrcp14pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcp14pd_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp14pd<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrcp14pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcp14pd_ymm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp14pd<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrcp14pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcp14pd_zmm_k1z_zmmm512b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp14ps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vrcp14ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcp14ps_xmm_k1z_xmmm128b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp14ps<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vrcp14ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcp14ps_ymm_k1z_ymmm256b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp14ps<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vrcp14ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcp14ps_zmm_k1z_zmmm512b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp14ps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrcp14ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcp14ps_xmm_k1z_xmmm128b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp14ps<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrcp14ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcp14ps_ymm_k1z_ymmm256b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp14ps<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrcp14ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcp14ps_zmm_k1z_zmmm512b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp14sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vrcp14sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrcp14sd_xmm_k1z_xmm_xmmm64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp14sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrcp14sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrcp14sd_xmm_k1z_xmm_xmmm64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp14ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vrcp14ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrcp14ss_xmm_k1z_xmm_xmmm32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp14ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrcp14ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrcp14ss_xmm_k1z_xmm_xmmm32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp28pd<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vrcp28pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcp28pd_zmm_k1z_zmmm512b64_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp28pd<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrcp28pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcp28pd_zmm_k1z_zmmm512b64_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp28ps<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vrcp28ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcp28ps_zmm_k1z_zmmm512b32_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp28ps<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrcp28ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcp28ps_zmm_k1z_zmmm512b32_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp28sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vrcp28sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrcp28sd_xmm_k1z_xmm_xmmm64_sae, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp28sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrcp28sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrcp28sd_xmm_k1z_xmm_xmmm64_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp28ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vrcp28ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrcp28ss_xmm_k1z_xmm_xmmm32_sae, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp28ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrcp28ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrcp28ss_xmm_k1z_xmm_xmmm32_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrcpph<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vrcpph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcpph_xmm_k1z_xmmm128b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrcpph<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vrcpph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcpph_ymm_k1z_ymmm256b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrcpph<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vrcpph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcpph_zmm_k1z_zmmm512b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrcpph<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrcpph(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcpph_xmm_k1z_xmmm128b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrcpph<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrcpph(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcpph_ymm_k1z_ymmm256b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrcpph<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrcpph(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcpph_zmm_k1z_zmmm512b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrcpps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vrcpps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vrcpps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVrcpps<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vrcpps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vrcpps_ymm_ymmm256, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVrcpps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrcpps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vrcpps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVrcpps<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrcpps(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vrcpps_ymm_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVrcpsh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vrcpsh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrcpsh_xmm_k1z_xmm_xmmm16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrcpsh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrcpsh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrcpsh_xmm_k1z_xmm_xmmm16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrcpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vrcpss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vrcpss_xmm_xmm_xmmm32, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVrcpss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrcpss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vrcpss_xmm_xmm_xmmm32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVreducepd<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vreducepd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreducepd_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVreducepd<__AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vreducepd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreducepd_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVreducepd<__AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vreducepd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreducepd_zmm_k1z_zmmm512b64_imm8_sae, op0.register(), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreducepd<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vreducepd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreducepd_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreducepd<__AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vreducepd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreducepd_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreducepd<__AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vreducepd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreducepd_zmm_k1z_zmmm512b64_imm8_sae, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreducepd<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vreducepd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreducepd_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVreducepd<__AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vreducepd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreducepd_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVreducepd<__AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vreducepd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreducepd_zmm_k1z_zmmm512b64_imm8_sae, op0.register(), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreducepd<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vreducepd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreducepd_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreducepd<__AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vreducepd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreducepd_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreducepd<__AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vreducepd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreducepd_zmm_k1z_zmmm512b64_imm8_sae, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceph<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vreduceph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceph_xmm_k1z_xmmm128b16_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceph<__AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vreduceph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceph_ymm_k1z_ymmm256b16_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceph<__AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vreduceph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceph_zmm_k1z_zmmm512b16_imm8_sae, op0.register(), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceph<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vreduceph(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceph_xmm_k1z_xmmm128b16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceph<__AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vreduceph(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceph_ymm_k1z_ymmm256b16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceph<__AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vreduceph(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceph_zmm_k1z_zmmm512b16_imm8_sae, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceph<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vreduceph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceph_xmm_k1z_xmmm128b16_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceph<__AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vreduceph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceph_ymm_k1z_ymmm256b16_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceph<__AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vreduceph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceph_zmm_k1z_zmmm512b16_imm8_sae, op0.register(), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceph<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vreduceph(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceph_xmm_k1z_xmmm128b16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceph<__AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vreduceph(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceph_ymm_k1z_ymmm256b16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceph<__AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vreduceph(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceph_zmm_k1z_zmmm512b16_imm8_sae, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceps<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vreduceps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceps_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceps<__AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vreduceps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceps_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceps<__AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vreduceps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceps_zmm_k1z_zmmm512b32_imm8_sae, op0.register(), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceps<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vreduceps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceps_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceps<__AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vreduceps(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceps_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceps<__AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vreduceps(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceps_zmm_k1z_zmmm512b32_imm8_sae, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceps<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vreduceps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceps_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceps<__AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vreduceps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceps_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceps<__AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vreduceps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceps_zmm_k1z_zmmm512b32_imm8_sae, op0.register(), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceps<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vreduceps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceps_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceps<__AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vreduceps(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceps_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceps<__AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vreduceps(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceps_zmm_k1z_zmmm512b32_imm8_sae, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreducesd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vreducesd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vreducesd_xmm_k1z_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreducesd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vreducesd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vreducesd_xmm_k1z_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreducesd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vreducesd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vreducesd_xmm_k1z_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreducesd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vreducesd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vreducesd_xmm_k1z_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreducesh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vreducesh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vreducesh_xmm_k1z_xmm_xmmm16_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreducesh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vreducesh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vreducesh_xmm_k1z_xmm_xmmm16_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreducesh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vreducesh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vreducesh_xmm_k1z_xmm_xmmm16_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreducesh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vreducesh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vreducesh_xmm_k1z_xmm_xmmm16_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreducess<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vreducess(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vreducess_xmm_k1z_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreducess<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vreducess(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vreducess_xmm_k1z_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreducess<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vreducess(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vreducess_xmm_k1z_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreducess<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vreducess(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vreducess_xmm_k1z_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscalepd<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vrndscalepd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscalepd_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscalepd<__AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vrndscalepd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscalepd_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscalepd<__AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vrndscalepd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscalepd_zmm_k1z_zmmm512b64_imm8_sae, op0.register(), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscalepd<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vrndscalepd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscalepd_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscalepd<__AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vrndscalepd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscalepd_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscalepd<__AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vrndscalepd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscalepd_zmm_k1z_zmmm512b64_imm8_sae, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscalepd<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vrndscalepd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscalepd_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscalepd<__AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vrndscalepd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscalepd_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscalepd<__AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vrndscalepd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscalepd_zmm_k1z_zmmm512b64_imm8_sae, op0.register(), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscalepd<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vrndscalepd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscalepd_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscalepd<__AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vrndscalepd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscalepd_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscalepd<__AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vrndscalepd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscalepd_zmm_k1z_zmmm512b64_imm8_sae, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleph<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vrndscaleph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleph_xmm_k1z_xmmm128b16_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleph<__AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vrndscaleph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleph_ymm_k1z_ymmm256b16_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleph<__AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vrndscaleph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleph_zmm_k1z_zmmm512b16_imm8_sae, op0.register(), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleph<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vrndscaleph(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleph_xmm_k1z_xmmm128b16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleph<__AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vrndscaleph(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleph_ymm_k1z_ymmm256b16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleph<__AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vrndscaleph(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleph_zmm_k1z_zmmm512b16_imm8_sae, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleph<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vrndscaleph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleph_xmm_k1z_xmmm128b16_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleph<__AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vrndscaleph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleph_ymm_k1z_ymmm256b16_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleph<__AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vrndscaleph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleph_zmm_k1z_zmmm512b16_imm8_sae, op0.register(), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleph<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vrndscaleph(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleph_xmm_k1z_xmmm128b16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleph<__AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vrndscaleph(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleph_ymm_k1z_ymmm256b16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleph<__AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vrndscaleph(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleph_zmm_k1z_zmmm512b16_imm8_sae, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleps<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vrndscaleps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleps_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleps<__AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vrndscaleps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleps_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleps<__AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vrndscaleps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleps_zmm_k1z_zmmm512b32_imm8_sae, op0.register(), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleps<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vrndscaleps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleps_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleps<__AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vrndscaleps(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleps_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleps<__AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vrndscaleps(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleps_zmm_k1z_zmmm512b32_imm8_sae, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleps<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vrndscaleps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleps_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleps<__AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vrndscaleps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleps_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleps<__AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vrndscaleps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleps_zmm_k1z_zmmm512b32_imm8_sae, op0.register(), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleps<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vrndscaleps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleps_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleps<__AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vrndscaleps(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleps_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleps<__AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vrndscaleps(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleps_zmm_k1z_zmmm512b32_imm8_sae, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscalesd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vrndscalesd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrndscalesd_xmm_k1z_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscalesd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vrndscalesd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrndscalesd_xmm_k1z_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscalesd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vrndscalesd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrndscalesd_xmm_k1z_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscalesd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vrndscalesd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrndscalesd_xmm_k1z_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscalesh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vrndscalesh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrndscalesh_xmm_k1z_xmm_xmmm16_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscalesh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vrndscalesh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrndscalesh_xmm_k1z_xmm_xmmm16_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscalesh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vrndscalesh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrndscalesh_xmm_k1z_xmm_xmmm16_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscalesh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vrndscalesh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrndscalesh_xmm_k1z_xmm_xmmm16_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaless<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vrndscaless(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrndscaless_xmm_k1z_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaless<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vrndscaless(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrndscaless_xmm_k1z_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaless<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vrndscaless(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrndscaless_xmm_k1z_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaless<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vrndscaless(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrndscaless_xmm_k1z_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVroundpd<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vroundpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vroundpd_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundpd<__AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vroundpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vroundpd_ymm_ymmm256_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundpd<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vroundpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vroundpd_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundpd<__AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vroundpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vroundpd_ymm_ymmm256_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundpd<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vroundpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vroundpd_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundpd<__AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vroundpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vroundpd_ymm_ymmm256_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundpd<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vroundpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vroundpd_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundpd<__AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vroundpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vroundpd_ymm_ymmm256_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundps<__AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vroundps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vroundps_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundps<__AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vroundps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vroundps_ymm_ymmm256_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundps<__AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vroundps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vroundps_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundps<__AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vroundps(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vroundps_ymm_ymmm256_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundps<__AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vroundps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vroundps_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundps<__AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vroundps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vroundps_ymm_ymmm256_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundps<__AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vroundps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vroundps_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundps<__AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vroundps(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vroundps_ymm_ymmm256_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vroundsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vroundsd_xmm_xmm_xmmm64_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vroundsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vroundsd_xmm_xmm_xmmm64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vroundsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vroundsd_xmm_xmm_xmmm64_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vroundsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vroundsd_xmm_xmm_xmmm64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vroundss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vroundss_xmm_xmm_xmmm32_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vroundss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vroundss_xmm_xmm_xmmm32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vroundss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vroundss_xmm_xmm_xmmm32_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vroundss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vroundss_xmm_xmm_xmmm32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt14pd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vrsqrt14pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrt14pd_xmm_k1z_xmmm128b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt14pd<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vrsqrt14pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrt14pd_ymm_k1z_ymmm256b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt14pd<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vrsqrt14pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrt14pd_zmm_k1z_zmmm512b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt14pd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrsqrt14pd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrt14pd_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt14pd<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrsqrt14pd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrt14pd_ymm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt14pd<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrsqrt14pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrt14pd_zmm_k1z_zmmm512b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt14ps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vrsqrt14ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrt14ps_xmm_k1z_xmmm128b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt14ps<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vrsqrt14ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrt14ps_ymm_k1z_ymmm256b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt14ps<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vrsqrt14ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrt14ps_zmm_k1z_zmmm512b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt14ps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrsqrt14ps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrt14ps_xmm_k1z_xmmm128b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt14ps<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrsqrt14ps(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrt14ps_ymm_k1z_ymmm256b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt14ps<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrsqrt14ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrt14ps_zmm_k1z_zmmm512b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt14sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vrsqrt14sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrsqrt14sd_xmm_k1z_xmm_xmmm64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt14sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrsqrt14sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrsqrt14sd_xmm_k1z_xmm_xmmm64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt14ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vrsqrt14ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrsqrt14ss_xmm_k1z_xmm_xmmm32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt14ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrsqrt14ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrsqrt14ss_xmm_k1z_xmm_xmmm32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt28pd<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vrsqrt28pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrt28pd_zmm_k1z_zmmm512b64_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt28pd<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrsqrt28pd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrt28pd_zmm_k1z_zmmm512b64_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt28ps<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vrsqrt28ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrt28ps_zmm_k1z_zmmm512b32_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt28ps<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrsqrt28ps(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrt28ps_zmm_k1z_zmmm512b32_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt28sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vrsqrt28sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrsqrt28sd_xmm_k1z_xmm_xmmm64_sae, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt28sd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrsqrt28sd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrsqrt28sd_xmm_k1z_xmm_xmmm64_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt28ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vrsqrt28ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrsqrt28ss_xmm_k1z_xmm_xmmm32_sae, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt28ss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrsqrt28ss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrsqrt28ss_xmm_k1z_xmm_xmmm32_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrtph<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vrsqrtph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrtph_xmm_k1z_xmmm128b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrtph<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vrsqrtph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrtph_ymm_k1z_ymmm256b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrtph<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vrsqrtph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrtph_zmm_k1z_zmmm512b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrtph<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrsqrtph(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrtph_xmm_k1z_xmmm128b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrtph<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrsqrtph(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrtph_ymm_k1z_ymmm256b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrtph<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrsqrtph(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrtph_zmm_k1z_zmmm512b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrtps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vrsqrtps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vrsqrtps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrtps<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vrsqrtps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vrsqrtps_ymm_ymmm256, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrtps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrsqrtps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vrsqrtps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrtps<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrsqrtps(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vrsqrtps_ymm_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrtsh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vrsqrtsh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrsqrtsh_xmm_k1z_xmm_xmmm16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrtsh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrsqrtsh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrsqrtsh_xmm_k1z_xmm_xmmm16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrtss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vrsqrtss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vrsqrtss_xmm_xmm_xmmm32, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrtss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrsqrtss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vrsqrtss_xmm_xmm_xmmm32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vscalefpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefpd_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vscalefpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefpd_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefpd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vscalefpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefpd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vscalefpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefpd_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vscalefpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefpd_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefpd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vscalefpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefpd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vscalefph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vscalefph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vscalefph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vscalefph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vscalefph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vscalefph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vscalefps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefps_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vscalefps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefps_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vscalefps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vscalefps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefps_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vscalefps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefps_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vscalefps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vscalefsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefsd_xmm_k1z_xmm_xmmm64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vscalefsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefsd_xmm_k1z_xmm_xmmm64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefsh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vscalefsh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefsh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefsh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vscalefsh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefsh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vscalefss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefss_xmm_k1z_xmm_xmmm32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vscalefss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefss_xmm_k1z_xmm_xmmm32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVscatterdpd<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vscatterdpd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vscatterdpd_vm32x_k1_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscatterdpd<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vscatterdpd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vscatterdpd_vm32x_k1_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscatterdpd<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vscatterdpd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vscatterdpd_vm32y_k1_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscatterdps<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vscatterdps(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vscatterdps_vm32x_k1_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscatterdps<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vscatterdps(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vscatterdps_vm32y_k1_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscatterdps<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vscatterdps(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vscatterdps_vm32z_k1_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscatterpf0dpd<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vscatterpf0dpd(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with1(Code::EVEX_Vscatterpf0dpd_vm32y_k1, op0.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscatterpf0dps<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vscatterpf0dps(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with1(Code::EVEX_Vscatterpf0dps_vm32z_k1, op0.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscatterpf0qpd<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vscatterpf0qpd(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with1(Code::EVEX_Vscatterpf0qpd_vm64z_k1, op0.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscatterpf0qps<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vscatterpf0qps(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with1(Code::EVEX_Vscatterpf0qps_vm64z_k1, op0.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscatterpf1dpd<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vscatterpf1dpd(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with1(Code::EVEX_Vscatterpf1dpd_vm32y_k1, op0.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscatterpf1dps<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vscatterpf1dps(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with1(Code::EVEX_Vscatterpf1dps_vm32z_k1, op0.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscatterpf1qpd<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vscatterpf1qpd(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with1(Code::EVEX_Vscatterpf1qpd_vm64z_k1, op0.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscatterpf1qps<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vscatterpf1qps(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with1(Code::EVEX_Vscatterpf1qps_vm64z_k1, op0.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscatterqpd<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vscatterqpd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vscatterqpd_vm64x_k1_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscatterqpd<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vscatterqpd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vscatterqpd_vm64y_k1_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscatterqpd<__AsmMemoryOperand, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vscatterqpd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vscatterqpd_vm64z_k1_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscatterqps<__AsmMemoryOperand, __AsmRegisterXmm> for CodeAssembler {
	fn vscatterqps(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if op0.index().is_xmm() {
			Code::EVEX_Vscatterqps_vm64x_k1_xmm
		} else if op0.index().is_ymm() {
			Code::EVEX_Vscatterqps_vm64y_k1_xmm
		} else {
			return Err(IcedError::new("vscatterqps: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscatterqps<__AsmMemoryOperand, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vscatterqps(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vscatterqps_vm64z_k1_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshuff32x4<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vshuff32x4(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshuff32x4_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshuff32x4<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vshuff32x4(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshuff32x4_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshuff32x4<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vshuff32x4(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshuff32x4_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshuff32x4<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vshuff32x4(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshuff32x4_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshuff32x4<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vshuff32x4(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshuff32x4_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshuff32x4<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vshuff32x4(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshuff32x4_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshuff32x4<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vshuff32x4(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshuff32x4_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshuff32x4<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vshuff32x4(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshuff32x4_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshuff64x2<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vshuff64x2(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshuff64x2_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshuff64x2<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vshuff64x2(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshuff64x2_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshuff64x2<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vshuff64x2(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshuff64x2_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshuff64x2<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vshuff64x2(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshuff64x2_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshuff64x2<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vshuff64x2(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshuff64x2_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshuff64x2<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vshuff64x2(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshuff64x2_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshuff64x2<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vshuff64x2(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshuff64x2_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshuff64x2<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vshuff64x2(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshuff64x2_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshufi32x4<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vshufi32x4(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufi32x4_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshufi32x4<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vshufi32x4(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufi32x4_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshufi32x4<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vshufi32x4(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufi32x4_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshufi32x4<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vshufi32x4(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufi32x4_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshufi32x4<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vshufi32x4(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufi32x4_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshufi32x4<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vshufi32x4(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufi32x4_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshufi32x4<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vshufi32x4(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufi32x4_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshufi32x4<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vshufi32x4(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufi32x4_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshufi64x2<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vshufi64x2(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufi64x2_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshufi64x2<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vshufi64x2(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufi64x2_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshufi64x2<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vshufi64x2(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufi64x2_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshufi64x2<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vshufi64x2(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufi64x2_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshufi64x2<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vshufi64x2(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufi64x2_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshufi64x2<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vshufi64x2(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufi64x2_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshufi64x2<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vshufi64x2(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufi64x2_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshufi64x2<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vshufi64x2(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufi64x2_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshufpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vshufpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vshufpd_xmm_xmm_xmmm128_imm8 } else { Code::EVEX_Vshufpd_xmm_k1z_xmm_xmmm128b64_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshufpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vshufpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vshufpd_ymm_ymm_ymmm256_imm8 } else { Code::EVEX_Vshufpd_ymm_k1z_ymm_ymmm256b64_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshufpd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vshufpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufpd_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshufpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	fn vshufpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vshufpd_xmm_k1z_xmm_xmmm128b64_imm8
		} else if self.prefer_vex() {
			Code::VEX_Vshufpd_xmm_xmm_xmmm128_imm8
		} else {
			Code::EVEX_Vshufpd_xmm_k1z_xmm_xmmm128b64_imm8
		};
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshufpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	fn vshufpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vshufpd_ymm_k1z_ymm_ymmm256b64_imm8
		} else if self.prefer_vex() {
			Code::VEX_Vshufpd_ymm_ymm_ymmm256_imm8
		} else {
			Code::EVEX_Vshufpd_ymm_k1z_ymm_ymmm256b64_imm8
		};
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshufpd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vshufpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufpd_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshufpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vshufpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vshufpd_xmm_xmm_xmmm128_imm8 } else { Code::EVEX_Vshufpd_xmm_k1z_xmm_xmmm128b64_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshufpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vshufpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vshufpd_ymm_ymm_ymmm256_imm8 } else { Code::EVEX_Vshufpd_ymm_k1z_ymm_ymmm256b64_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshufpd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vshufpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufpd_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshufpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	fn vshufpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vshufpd_xmm_k1z_xmm_xmmm128b64_imm8
		} else if self.prefer_vex() {
			Code::VEX_Vshufpd_xmm_xmm_xmmm128_imm8
		} else {
			Code::EVEX_Vshufpd_xmm_k1z_xmm_xmmm128b64_imm8
		};
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshufpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	fn vshufpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vshufpd_ymm_k1z_ymm_ymmm256b64_imm8
		} else if self.prefer_vex() {
			Code::VEX_Vshufpd_ymm_ymm_ymmm256_imm8
		} else {
			Code::EVEX_Vshufpd_ymm_k1z_ymm_ymmm256b64_imm8
		};
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshufpd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vshufpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufpd_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshufps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vshufps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vshufps_xmm_xmm_xmmm128_imm8 } else { Code::EVEX_Vshufps_xmm_k1z_xmm_xmmm128b32_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshufps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vshufps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vshufps_ymm_ymm_ymmm256_imm8 } else { Code::EVEX_Vshufps_ymm_k1z_ymm_ymmm256b32_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshufps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vshufps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufps_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshufps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, i32> for CodeAssembler {
	fn vshufps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vshufps_xmm_k1z_xmm_xmmm128b32_imm8
		} else if self.prefer_vex() {
			Code::VEX_Vshufps_xmm_xmm_xmmm128_imm8
		} else {
			Code::EVEX_Vshufps_xmm_k1z_xmm_xmmm128b32_imm8
		};
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshufps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, i32> for CodeAssembler {
	fn vshufps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vshufps_ymm_k1z_ymm_ymmm256b32_imm8
		} else if self.prefer_vex() {
			Code::VEX_Vshufps_ymm_ymm_ymmm256_imm8
		} else {
			Code::EVEX_Vshufps_ymm_k1z_ymm_ymmm256b32_imm8
		};
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshufps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vshufps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufps_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshufps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vshufps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vshufps_xmm_xmm_xmmm128_imm8 } else { Code::EVEX_Vshufps_xmm_k1z_xmm_xmmm128b32_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshufps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vshufps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vshufps_ymm_ymm_ymmm256_imm8 } else { Code::EVEX_Vshufps_ymm_k1z_ymm_ymmm256b32_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshufps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vshufps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufps_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshufps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand, u32> for CodeAssembler {
	fn vshufps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vshufps_xmm_k1z_xmm_xmmm128b32_imm8
		} else if self.prefer_vex() {
			Code::VEX_Vshufps_xmm_xmm_xmmm128_imm8
		} else {
			Code::EVEX_Vshufps_xmm_k1z_xmm_xmmm128b32_imm8
		};
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshufps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand, u32> for CodeAssembler {
	fn vshufps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vshufps_ymm_k1z_ymm_ymmm256b32_imm8
		} else if self.prefer_vex() {
			Code::VEX_Vshufps_ymm_ymm_ymmm256_imm8
		} else {
			Code::EVEX_Vshufps_ymm_k1z_ymm_ymmm256b32_imm8
		};
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshufps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vshufps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufps_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtpd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vsqrtpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vsqrtpd_xmm_xmmm128 } else { Code::EVEX_Vsqrtpd_xmm_k1z_xmmm128b64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtpd<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vsqrtpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vsqrtpd_ymm_ymmm256 } else { Code::EVEX_Vsqrtpd_ymm_k1z_ymmm256b64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtpd<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vsqrtpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vsqrtpd_zmm_k1z_zmmm512b64_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtpd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vsqrtpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vsqrtpd_xmm_k1z_xmmm128b64
		} else if self.prefer_vex() {
			Code::VEX_Vsqrtpd_xmm_xmmm128
		} else {
			Code::EVEX_Vsqrtpd_xmm_k1z_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtpd<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vsqrtpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vsqrtpd_ymm_k1z_ymmm256b64
		} else if self.prefer_vex() {
			Code::VEX_Vsqrtpd_ymm_ymmm256
		} else {
			Code::EVEX_Vsqrtpd_ymm_k1z_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtpd<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vsqrtpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vsqrtpd_zmm_k1z_zmmm512b64_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtph<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vsqrtph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vsqrtph_xmm_k1z_xmmm128b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtph<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vsqrtph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vsqrtph_ymm_k1z_ymmm256b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtph<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vsqrtph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vsqrtph_zmm_k1z_zmmm512b16_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtph<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vsqrtph(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vsqrtph_xmm_k1z_xmmm128b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtph<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vsqrtph(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vsqrtph_ymm_k1z_ymmm256b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtph<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vsqrtph(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vsqrtph_zmm_k1z_zmmm512b16_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vsqrtps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vsqrtps_xmm_xmmm128 } else { Code::EVEX_Vsqrtps_xmm_k1z_xmmm128b32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtps<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vsqrtps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vsqrtps_ymm_ymmm256 } else { Code::EVEX_Vsqrtps_ymm_k1z_ymmm256b32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtps<__AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vsqrtps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vsqrtps_zmm_k1z_zmmm512b32_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vsqrtps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vsqrtps_xmm_k1z_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vsqrtps_xmm_xmmm128
		} else {
			Code::EVEX_Vsqrtps_xmm_k1z_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtps<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vsqrtps(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vsqrtps_ymm_k1z_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vsqrtps_ymm_ymmm256
		} else {
			Code::EVEX_Vsqrtps_ymm_k1z_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtps<__AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vsqrtps(&mut self, op0: __AsmRegisterZmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vsqrtps_zmm_k1z_zmmm512b32_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vsqrtsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vsqrtsd_xmm_xmm_xmmm64 } else { Code::EVEX_Vsqrtsd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vsqrtsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vsqrtsd_xmm_xmm_xmmm64 } else { Code::EVEX_Vsqrtsd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtsh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vsqrtsh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vsqrtsh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtsh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vsqrtsh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vsqrtsh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vsqrtss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vsqrtss_xmm_xmm_xmmm32 } else { Code::EVEX_Vsqrtss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vsqrtss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vsqrtss_xmm_xmm_xmmm32 } else { Code::EVEX_Vsqrtss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVstmxcsr<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vstmxcsr(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::VEX_Vstmxcsr_m32, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVsubpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vsubpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vsubpd_xmm_xmm_xmmm128 } else { Code::EVEX_Vsubpd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVsubpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vsubpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vsubpd_ymm_ymm_ymmm256 } else { Code::EVEX_Vsubpd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVsubpd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vsubpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vsubpd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsubpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vsubpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vsubpd_xmm_k1z_xmm_xmmm128b64
		} else if self.prefer_vex() {
			Code::VEX_Vsubpd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vsubpd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsubpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vsubpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vsubpd_ymm_k1z_ymm_ymmm256b64
		} else if self.prefer_vex() {
			Code::VEX_Vsubpd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vsubpd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsubpd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vsubpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vsubpd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsubph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vsubph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vsubph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVsubph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vsubph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vsubph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVsubph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vsubph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vsubph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsubph<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vsubph(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vsubph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsubph<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vsubph(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vsubph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsubph<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vsubph(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vsubph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsubps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vsubps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vsubps_xmm_xmm_xmmm128 } else { Code::EVEX_Vsubps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVsubps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vsubps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vsubps_ymm_ymm_ymmm256 } else { Code::EVEX_Vsubps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVsubps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vsubps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vsubps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsubps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vsubps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vsubps_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vsubps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vsubps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsubps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vsubps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vsubps_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vsubps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vsubps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsubps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vsubps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vsubps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsubsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vsubsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vsubsd_xmm_xmm_xmmm64 } else { Code::EVEX_Vsubsd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsubsd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vsubsd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vsubsd_xmm_xmm_xmmm64 } else { Code::EVEX_Vsubsd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsubsh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vsubsh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vsubsh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsubsh<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vsubsh(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vsubsh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsubss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vsubss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vsubss_xmm_xmm_xmmm32 } else { Code::EVEX_Vsubss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsubss<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vsubss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vsubss_xmm_xmm_xmmm32 } else { Code::EVEX_Vsubss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVtestpd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vtestpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vtestpd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVtestpd<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vtestpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vtestpd_ymm_ymmm256, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVtestpd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vtestpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vtestpd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVtestpd<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vtestpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vtestpd_ymm_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVtestps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vtestps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vtestps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVtestps<__AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vtestps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vtestps_ymm_ymmm256, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVtestps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vtestps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vtestps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVtestps<__AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vtestps(&mut self, op0: __AsmRegisterYmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vtestps_ymm_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVucomisd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vucomisd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vucomisd_xmm_xmmm64 } else { Code::EVEX_Vucomisd_xmm_xmmm64_sae };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVucomisd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vucomisd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vucomisd_xmm_xmmm64 } else { Code::EVEX_Vucomisd_xmm_xmmm64_sae };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVucomish<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vucomish(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vucomish_xmm_xmmm16_sae, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVucomish<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vucomish(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vucomish_xmm_xmmm16_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVucomiss<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vucomiss(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vucomiss_xmm_xmmm32 } else { Code::EVEX_Vucomiss_xmm_xmmm32_sae };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVucomiss<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vucomiss(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vucomiss_xmm_xmmm32 } else { Code::EVEX_Vucomiss_xmm_xmmm32_sae };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVunpckhpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vunpckhpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vunpckhpd_xmm_xmm_xmmm128 } else { Code::EVEX_Vunpckhpd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVunpckhpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vunpckhpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vunpckhpd_ymm_ymm_ymmm256 } else { Code::EVEX_Vunpckhpd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVunpckhpd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vunpckhpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vunpckhpd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVunpckhpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vunpckhpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vunpckhpd_xmm_k1z_xmm_xmmm128b64
		} else if self.prefer_vex() {
			Code::VEX_Vunpckhpd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vunpckhpd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVunpckhpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vunpckhpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vunpckhpd_ymm_k1z_ymm_ymmm256b64
		} else if self.prefer_vex() {
			Code::VEX_Vunpckhpd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vunpckhpd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVunpckhpd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vunpckhpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vunpckhpd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVunpckhps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vunpckhps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vunpckhps_xmm_xmm_xmmm128 } else { Code::EVEX_Vunpckhps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVunpckhps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vunpckhps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vunpckhps_ymm_ymm_ymmm256 } else { Code::EVEX_Vunpckhps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVunpckhps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vunpckhps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vunpckhps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVunpckhps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vunpckhps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vunpckhps_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vunpckhps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vunpckhps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVunpckhps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vunpckhps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vunpckhps_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vunpckhps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vunpckhps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVunpckhps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vunpckhps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vunpckhps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVunpcklpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vunpcklpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vunpcklpd_xmm_xmm_xmmm128 } else { Code::EVEX_Vunpcklpd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVunpcklpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vunpcklpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vunpcklpd_ymm_ymm_ymmm256 } else { Code::EVEX_Vunpcklpd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVunpcklpd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vunpcklpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vunpcklpd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVunpcklpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vunpcklpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vunpcklpd_xmm_k1z_xmm_xmmm128b64
		} else if self.prefer_vex() {
			Code::VEX_Vunpcklpd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vunpcklpd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVunpcklpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vunpcklpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vunpcklpd_ymm_k1z_ymm_ymmm256b64
		} else if self.prefer_vex() {
			Code::VEX_Vunpcklpd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vunpcklpd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVunpcklpd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vunpcklpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vunpcklpd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVunpcklps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vunpcklps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vunpcklps_xmm_xmm_xmmm128 } else { Code::EVEX_Vunpcklps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVunpcklps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vunpcklps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vunpcklps_ymm_ymm_ymmm256 } else { Code::EVEX_Vunpcklps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVunpcklps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vunpcklps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vunpcklps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVunpcklps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vunpcklps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vunpcklps_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vunpcklps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vunpcklps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVunpcklps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vunpcklps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vunpcklps_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vunpcklps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vunpcklps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVunpcklps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vunpcklps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vunpcklps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVxorpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vxorpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vxorpd_xmm_xmm_xmmm128 } else { Code::EVEX_Vxorpd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVxorpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vxorpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vxorpd_ymm_ymm_ymmm256 } else { Code::EVEX_Vxorpd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVxorpd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vxorpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vxorpd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVxorpd<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vxorpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vxorpd_xmm_k1z_xmm_xmmm128b64
		} else if self.prefer_vex() {
			Code::VEX_Vxorpd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vxorpd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVxorpd<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vxorpd(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vxorpd_ymm_k1z_ymm_ymmm256b64
		} else if self.prefer_vex() {
			Code::VEX_Vxorpd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vxorpd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVxorpd<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vxorpd(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vxorpd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVxorps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vxorps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vxorps_xmm_xmm_xmmm128 } else { Code::EVEX_Vxorps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVxorps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vxorps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.prefer_vex() { Code::VEX_Vxorps_ymm_ymm_ymmm256 } else { Code::EVEX_Vxorps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVxorps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vxorps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vxorps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVxorps<__AsmRegisterXmm, __AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	fn vxorps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vxorps_xmm_k1z_xmm_xmmm128b32
		} else if self.prefer_vex() {
			Code::VEX_Vxorps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vxorps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVxorps<__AsmRegisterYmm, __AsmRegisterYmm, __AsmMemoryOperand> for CodeAssembler {
	fn vxorps(&mut self, op0: __AsmRegisterYmm, op1: __AsmRegisterYmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vxorps_ymm_k1z_ymm_ymmm256b32
		} else if self.prefer_vex() {
			Code::VEX_Vxorps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vxorps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVxorps<__AsmRegisterZmm, __AsmRegisterZmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vxorps(&mut self, op0: __AsmRegisterZmm, op1: __AsmRegisterZmm, op2: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vxorps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVzeroall for CodeAssembler {
	#[inline]
	fn vzeroall(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::VEX_Vzeroall))
	}
}

#[rustfmt::skip]
impl CodeAsmVzeroupper for CodeAssembler {
	#[inline]
	fn vzeroupper(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::VEX_Vzeroupper))
	}
}

#[rustfmt::skip]
impl CodeAsmWait for CodeAssembler {
	#[inline]
	fn wait(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Wait))
	}
}

#[rustfmt::skip]
impl CodeAsmWbinvd for CodeAssembler {
	#[inline]
	fn wbinvd(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Wbinvd))
	}
}

#[rustfmt::skip]
impl CodeAsmWbnoinvd for CodeAssembler {
	#[inline]
	fn wbnoinvd(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Wbnoinvd))
	}
}

#[rustfmt::skip]
impl CodeAsmWrfsbase<__AsmRegister32> for CodeAssembler {
	#[inline]
	fn wrfsbase(&mut self, op0: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Wrfsbase_r32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmWrfsbase<__AsmRegister64> for CodeAssembler {
	#[inline]
	fn wrfsbase(&mut self, op0: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Wrfsbase_r64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmWrgsbase<__AsmRegister32> for CodeAssembler {
	#[inline]
	fn wrgsbase(&mut self, op0: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Wrgsbase_r32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmWrgsbase<__AsmRegister64> for CodeAssembler {
	#[inline]
	fn wrgsbase(&mut self, op0: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Wrgsbase_r64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmWrmsr for CodeAssembler {
	#[inline]
	fn wrmsr(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Wrmsr))
	}
}

#[rustfmt::skip]
impl CodeAsmWrpkru for CodeAssembler {
	#[inline]
	fn wrpkru(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Wrpkru))
	}
}

#[rustfmt::skip]
impl CodeAsmWrshr<__AsmRegister32> for CodeAssembler {
	#[inline]
	fn wrshr(&mut self, op0: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Wrshr_rm32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmWrshr<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn wrshr(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Wrshr_rm32, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmWrssd<__AsmMemoryOperand, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn wrssd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Wrssd_m32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmWrssq<__AsmMemoryOperand, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn wrssq(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Wrssq_m64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmWrudbg for CodeAssembler {
	#[inline]
	fn wrudbg(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Wrudbg))
	}
}

#[rustfmt::skip]
impl CodeAsmWrussd<__AsmMemoryOperand, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn wrussd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Wrussd_m32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmWrussq<__AsmMemoryOperand, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn wrussq(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Wrussq_m64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXabort<i32> for CodeAssembler {
	#[inline]
	fn xabort(&mut self, op0: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Xabort_imm8, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmXabort<u32> for CodeAssembler {
	#[inline]
	fn xabort(&mut self, op0: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Xabort_imm8, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmXadd<__AsmRegister8, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn xadd(&mut self, op0: __AsmRegister8, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xadd_rm8_r8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXadd<__AsmMemoryOperand, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn xadd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xadd_rm8_r8, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXadd<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn xadd(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xadd_rm16_r16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXadd<__AsmMemoryOperand, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn xadd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xadd_rm16_r16, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXadd<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn xadd(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xadd_rm32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXadd<__AsmMemoryOperand, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn xadd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xadd_rm32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXadd<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn xadd(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xadd_rm64_r64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXadd<__AsmMemoryOperand, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn xadd(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xadd_rm64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXbegin<CodeLabel> for CodeAssembler {
	#[inline]
	fn xbegin(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_xbegin(self.bitness(), op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXbegin<u64> for CodeAssembler {
	#[inline]
	fn xbegin(&mut self, op0: u64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_xbegin(self.bitness(), op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmXbts<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn xbts(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xbts_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXbts<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn xbts(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xbts_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXbts<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn xbts(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xbts_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmXbts<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn xbts(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xbts_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmXchg<__AsmRegister8, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn xchg(&mut self, op0: __AsmRegister8, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xchg_rm8_r8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXchg<__AsmMemoryOperand, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn xchg(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xchg_rm8_r8, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXchg<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn xchg(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		let code = if op1.register() == Register::AX { Code::Xchg_r16_AX } else { Code::Xchg_rm16_r16 };
		self.add_instr(Instruction::with2(code, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXchg<__AsmMemoryOperand, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn xchg(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xchg_rm16_r16, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXchg<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn xchg(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		let code = if op1.register() == Register::EAX { Code::Xchg_r32_EAX } else { Code::Xchg_rm32_r32 };
		self.add_instr(Instruction::with2(code, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXchg<__AsmMemoryOperand, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn xchg(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xchg_rm32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXchg<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn xchg(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		let code = if op1.register() == Register::RAX { Code::Xchg_r64_RAX } else { Code::Xchg_rm64_r64 };
		self.add_instr(Instruction::with2(code, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXchg<__AsmMemoryOperand, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn xchg(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xchg_rm64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXcryptcbc for CodeAssembler {
	fn xcryptcbc(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Xcryptcbc_64
		} else if self.bitness() >= 32 {
			Code::Xcryptcbc_32
		} else {
			Code::Xcryptcbc_16
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmXcryptcfb for CodeAssembler {
	fn xcryptcfb(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Xcryptcfb_64
		} else if self.bitness() >= 32 {
			Code::Xcryptcfb_32
		} else {
			Code::Xcryptcfb_16
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmXcryptctr for CodeAssembler {
	fn xcryptctr(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Xcryptctr_64
		} else if self.bitness() >= 32 {
			Code::Xcryptctr_32
		} else {
			Code::Xcryptctr_16
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmXcryptecb for CodeAssembler {
	fn xcryptecb(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Xcryptecb_64
		} else if self.bitness() >= 32 {
			Code::Xcryptecb_32
		} else {
			Code::Xcryptecb_16
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmXcryptofb for CodeAssembler {
	fn xcryptofb(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Xcryptofb_64
		} else if self.bitness() >= 32 {
			Code::Xcryptofb_32
		} else {
			Code::Xcryptofb_16
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmXend for CodeAssembler {
	#[inline]
	fn xend(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Xend))
	}
}

#[rustfmt::skip]
impl CodeAsmXgetbv for CodeAssembler {
	#[inline]
	fn xgetbv(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Xgetbv))
	}
}

#[rustfmt::skip]
impl CodeAsmXor<__AsmRegister8, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn xor(&mut self, op0: __AsmRegister8, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xor_rm8_r8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXor<__AsmMemoryOperand, __AsmRegister8> for CodeAssembler {
	#[inline]
	fn xor(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xor_rm8_r8, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXor<__AsmRegister16, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn xor(&mut self, op0: __AsmRegister16, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xor_rm16_r16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXor<__AsmMemoryOperand, __AsmRegister16> for CodeAssembler {
	#[inline]
	fn xor(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xor_rm16_r16, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXor<__AsmRegister32, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn xor(&mut self, op0: __AsmRegister32, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xor_rm32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXor<__AsmMemoryOperand, __AsmRegister32> for CodeAssembler {
	#[inline]
	fn xor(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xor_rm32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXor<__AsmRegister64, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn xor(&mut self, op0: __AsmRegister64, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xor_rm64_r64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXor<__AsmMemoryOperand, __AsmRegister64> for CodeAssembler {
	#[inline]
	fn xor(&mut self, op0: __AsmMemoryOperand, op1: __AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xor_rm64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXor<__AsmRegister8, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn xor(&mut self, op0: __AsmRegister8, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xor_r8_rm8, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmXor<__AsmRegister16, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn xor(&mut self, op0: __AsmRegister16, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xor_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmXor<__AsmRegister32, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn xor(&mut self, op0: __AsmRegister32, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xor_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmXor<__AsmRegister64, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn xor(&mut self, op0: __AsmRegister64, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xor_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmXor<__AsmRegister8, i32> for CodeAssembler {
	#[inline]
	fn xor(&mut self, op0: __AsmRegister8, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AL { Code::Xor_AL_imm8 } else { Code::Xor_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmXor<__AsmRegister16, i32> for CodeAssembler {
	fn xor(&mut self, op0: __AsmRegister16, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AX {
			Code::Xor_AX_imm16
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Xor_rm16_imm8
		} else {
			Code::Xor_rm16_imm16
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmXor<__AsmRegister32, i32> for CodeAssembler {
	fn xor(&mut self, op0: __AsmRegister32, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::EAX {
			Code::Xor_EAX_imm32
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Xor_rm32_imm8
		} else {
			Code::Xor_rm32_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmXor<__AsmRegister64, i32> for CodeAssembler {
	fn xor(&mut self, op0: __AsmRegister64, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::RAX {
			Code::Xor_RAX_imm32
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Xor_rm64_imm8
		} else {
			Code::Xor_rm64_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmXor<__AsmMemoryOperand, i32> for CodeAssembler {
	fn xor(&mut self, op0: __AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Xor_rm64_imm8 } else { Code::Xor_rm64_imm32 }
		} else if op0.size() == MemoryOperandSize::Dword {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Xor_rm32_imm8 } else { Code::Xor_rm32_imm32 }
		} else if op0.size() == MemoryOperandSize::Word {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Xor_rm16_imm8 } else { Code::Xor_rm16_imm16 }
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Xor_rm8_imm8
		} else {
			return Err(IcedError::new("xor: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmXor<__AsmRegister8, u32> for CodeAssembler {
	#[inline]
	fn xor(&mut self, op0: __AsmRegister8, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AL { Code::Xor_AL_imm8 } else { Code::Xor_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmXor<__AsmRegister16, u32> for CodeAssembler {
	fn xor(&mut self, op0: __AsmRegister16, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AX {
			Code::Xor_AX_imm16
		} else if op1 <= i8::MAX as u32 || (0xFF80 <= op1 && op1 <= 0xFFFF) {
			Code::Xor_rm16_imm8
		} else {
			Code::Xor_rm16_imm16
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmXor<__AsmRegister32, u32> for CodeAssembler {
	fn xor(&mut self, op0: __AsmRegister32, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::EAX {
			Code::Xor_EAX_imm32
		} else if op1 <= i8::MAX as u32 || 0xFFFF_FF80 <= op1 {
			Code::Xor_rm32_imm8
		} else {
			Code::Xor_rm32_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmXor<__AsmMemoryOperand, u32> for CodeAssembler {
	fn xor(&mut self, op0: __AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Dword {
			if op1 <= i8::MAX as u32 || 0xFFFF_FF80 <= op1 { Code::Xor_rm32_imm8 } else { Code::Xor_rm32_imm32 }
		} else if op0.size() == MemoryOperandSize::Word {
			if op1 <= i8::MAX as u32 || (0xFF80 <= op1 && op1 <= 0xFFFF) { Code::Xor_rm16_imm8 } else { Code::Xor_rm16_imm16 }
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Xor_rm8_imm8
		} else {
			return Err(IcedError::new("xor: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmXorpd<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn xorpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xorpd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXorpd<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn xorpd(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xorpd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmXorps<__AsmRegisterXmm, __AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn xorps(&mut self, op0: __AsmRegisterXmm, op1: __AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xorps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXorps<__AsmRegisterXmm, __AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn xorps(&mut self, op0: __AsmRegisterXmm, op1: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xorps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmXresldtrk for CodeAssembler {
	#[inline]
	fn xresldtrk(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Xresldtrk))
	}
}

#[rustfmt::skip]
impl CodeAsmXrstor<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn xrstor(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Xrstor_mem, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmXrstor64<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn xrstor64(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Xrstor64_mem, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmXrstors<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn xrstors(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Xrstors_mem, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmXrstors64<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn xrstors64(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Xrstors64_mem, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmXsave<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn xsave(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Xsave_mem, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmXsave64<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn xsave64(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Xsave64_mem, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmXsavec<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn xsavec(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Xsavec_mem, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmXsavec64<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn xsavec64(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Xsavec64_mem, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmXsaveopt<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn xsaveopt(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Xsaveopt_mem, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmXsaveopt64<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn xsaveopt64(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Xsaveopt64_mem, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmXsaves<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn xsaves(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Xsaves_mem, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmXsaves64<__AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn xsaves64(&mut self, op0: __AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Xsaves64_mem, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmXsetbv for CodeAssembler {
	#[inline]
	fn xsetbv(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Xsetbv))
	}
}

#[rustfmt::skip]
impl CodeAsmXsha1 for CodeAssembler {
	fn xsha1(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Xsha1_64
		} else if self.bitness() >= 32 {
			Code::Xsha1_32
		} else {
			Code::Xsha1_16
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmXsha256 for CodeAssembler {
	fn xsha256(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Xsha256_64
		} else if self.bitness() >= 32 {
			Code::Xsha256_32
		} else {
			Code::Xsha256_16
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmXstore for CodeAssembler {
	fn xstore(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Xstore_64
		} else if self.bitness() >= 32 {
			Code::Xstore_32
		} else {
			Code::Xstore_16
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmXsusldtrk for CodeAssembler {
	#[inline]
	fn xsusldtrk(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Xsusldtrk))
	}
}

#[rustfmt::skip]
impl CodeAsmXtest for CodeAssembler {
	#[inline]
	fn xtest(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Xtest))
	}
}
