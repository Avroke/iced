-- SPDX-License-Identifier: MIT
-- Copyright (C) 2018-present iced project and contributors

-- ‚ö†Ô∏èThis file was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è

---@meta
---@diagnostic disable unused-local

---A 16/32/64-bit x86 instruction. Created by `Decoder` or by `Instruction:create*()` methods
---
---@class Instruction
local Instruction = {}

---Creates a new empty instruction
---
---@return Instruction
function Instruction:new() end

---Creates a new instruction that's exactly identical to this one
---
---@return Instruction
function Instruction:copy() end

---Checks if two instructions are equal, comparing all bits, not ignoring anything. `==` ignores some fields.
---
---@param other Instruction #Other instruction
function Instruction:eq_all_bits(other) end

---Gets the 16-bit IP of the instruction
---
---@return integer
function Instruction:ip16() end

---Gets the 16-bit IP of the instruction
---
---@param new_value integer #New value
function Instruction:set_ip16(new_value) end

---Gets the 32-bit IP of the instruction
---
---@return integer
function Instruction:ip32() end

---Gets the 32-bit IP of the instruction
---
---@param new_value integer #New value
function Instruction:set_ip32(new_value) end

---Gets the 64-bit IP of the instruction
---
---@return integer
function Instruction:ip() end

---Gets the 64-bit IP of the instruction
---
---@param new_value integer #New value
function Instruction:set_ip(new_value) end

---Gets the 16-bit IP of the next instruction
---
---@return integer
function Instruction:next_ip16() end

---Gets the 16-bit IP of the next instruction
---
---@param new_value integer #New value
function Instruction:set_next_ip16(new_value) end

---Gets the 32-bit IP of the next instruction
---
---@return integer
function Instruction:next_ip32() end

---Gets the 32-bit IP of the next instruction
---
---@param new_value integer #New value
function Instruction:set_next_ip32(new_value) end

---Gets the 64-bit IP of the next instruction
---
---@return integer
function Instruction:next_ip() end

---Gets the 64-bit IP of the next instruction
---
---@param new_value integer #New value
function Instruction:set_next_ip(new_value) end

---Gets the code size (a `CodeSize` enum value) when the instruction was decoded.
---
---# Note
---This value is informational and can be used by a formatter.
---
---@return integer #A `CodeSize` enum value
function Instruction:code_size() end

---Gets the code size (a `CodeSize` enum value) when the instruction was decoded.
---
---# Note
---This value is informational and can be used by a formatter.
---
---@param new_value integer #New value (A `CodeSize` enum value)
function Instruction:set_code_size(new_value) end

---Checks if it's an invalid instruction (`Instruction:code()` == `Code.INVALID`)
---
---@return boolean
function Instruction:is_invalid() end

---Gets the instruction code (a `Code` enum value), see also `Instruction:mnemonic()`
---
---@return integer #A `Code` enum value
function Instruction:code() end

---Gets the instruction code (a `Code` enum value), see also `Instruction:mnemonic()`
---
---@param new_value integer #New value (A `Code` enum value)
function Instruction:set_code(new_value) end

---Gets the mnemonic (a `Mnemonic` enum value), see also `Instruction:code()`
---
---@return integer #A `Mnemonic` enum value
function Instruction:mnemonic() end

---Gets the operand count. An instruction can have 0-5 operands.
---
---@return integer
---
---# Examples
---
---```lua
---from iced_x86 import *
---
---# add [rax],ebx
---data = b"\x01\x18"
---decoder = Decoder(64, data)
---instr = decoder.decode()
---
---assert instr.op_count == 2
---```
function Instruction:op_count() end

---Gets the length of the instruction, 0-15 bytes.
---
---You can also call `#instr` to get this value.
---
---# Note
---This is just informational. If you modify the instruction or create a new one, this method could return the wrong value.
---
---@return integer
function Instruction:len() end

---Gets the length of the instruction, 0-15 bytes.
---
---You can also call `#instr` to get this value.
---
---# Note
---This is just informational. If you modify the instruction or create a new one, this method could return the wrong value.
---
---@param new_value integer #New value
function Instruction:set_len(new_value) end

---`true` if the instruction has the `XACQUIRE` prefix (`F2`)
---
---@return boolean
function Instruction:has_xacquire_prefix() end

---`true` if the instruction has the `XACQUIRE` prefix (`F2`)
---
---@param new_value boolean #New value
function Instruction:set_has_xacquire_prefix(new_value) end

---`true` if the instruction has the `XRELEASE` prefix (`F3`)
---
---@return boolean
function Instruction:has_xrelease_prefix() end

---`true` if the instruction has the `XRELEASE` prefix (`F3`)
---
---@param new_value boolean #New value
function Instruction:set_has_xrelease_prefix(new_value) end

---`true` if the instruction has the `REPE` or `REP` prefix (`F3`)
---
---@return boolean
function Instruction:has_rep_prefix() end

---`true` if the instruction has the `REPE` or `REP` prefix (`F3`)
---
---@param new_value boolean #New value
function Instruction:set_has_rep_prefix(new_value) end

---`true` if the instruction has the `REPE` or `REP` prefix (`F3`)
---
---@return boolean
function Instruction:has_repe_prefix() end

---`true` if the instruction has the `REPE` or `REP` prefix (`F3`)
---
---@param new_value boolean #New value
function Instruction:set_has_repe_prefix(new_value) end

---`true` if the instruction has the `REPNE` prefix (`F2`)
---
---@return boolean
function Instruction:has_repne_prefix() end

---`true` if the instruction has the `REPNE` prefix (`F2`)
---
---@param new_value boolean #New value
function Instruction:set_has_repne_prefix(new_value) end

---`true` if the instruction has the `LOCK` prefix (`F0`)
---
---@return boolean
function Instruction:has_lock_prefix() end

---`true` if the instruction has the `LOCK` prefix (`F0`)
---
---@param new_value boolean #New value
function Instruction:set_has_lock_prefix(new_value) end

---Gets operand #0's kind (an `OpKind` enum value) if the operand exists (see `Instruction:op_count()` and `Instruction:op_kind()`)
---
---@return integer #An `OpKind` enum value
function Instruction:op0_kind() end

---Gets operand #0's kind (an `OpKind` enum value) if the operand exists (see `Instruction:op_count()` and `Instruction:op_kind()`)
---
---@param new_value integer #New value (An `OpKind` enum value)
function Instruction:set_op0_kind(new_value) end

---Gets operand #1's kind (an `OpKind` enum value) if the operand exists (see `Instruction:op_count()` and `Instruction:op_kind()`)
---
---@return integer #An `OpKind` enum value
function Instruction:op1_kind() end

---Gets operand #1's kind (an `OpKind` enum value) if the operand exists (see `Instruction:op_count()` and `Instruction:op_kind()`)
---
---@param new_value integer #New value (An `OpKind` enum value)
function Instruction:set_op1_kind(new_value) end

---Gets operand #2's kind (an `OpKind` enum value) if the operand exists (see `Instruction:op_count()` and `Instruction:op_kind()`)
---
---@return integer #An `OpKind` enum value
function Instruction:op2_kind() end

---Gets operand #2's kind (an `OpKind` enum value) if the operand exists (see `Instruction:op_count()` and `Instruction:op_kind()`)
---
---@param new_value integer #New value (An `OpKind` enum value)
function Instruction:set_op2_kind(new_value) end

---Gets operand #3's kind (an `OpKind` enum value) if the operand exists (see `Instruction:op_count()` and `Instruction:op_kind()`)
---
---@return integer #An `OpKind` enum value
function Instruction:op3_kind() end

---Gets operand #3's kind (an `OpKind` enum value) if the operand exists (see `Instruction:op_count()` and `Instruction:op_kind()`)
---
---@param new_value integer #New value (An `OpKind` enum value)
function Instruction:set_op3_kind(new_value) end

---Gets operand #4's kind (an `OpKind` enum value) if the operand exists (see `Instruction:op_count()` and `Instruction:op_kind()`)
---
---@return integer #An `OpKind` enum value
function Instruction:op4_kind() end

---Gets operand #4's kind (an `OpKind` enum value) if the operand exists (see `Instruction:op_count()` and `Instruction:op_kind()`)
---
---@param new_value integer #New value (An `OpKind` enum value)
function Instruction:set_op4_kind(new_value) end

---Gets an operand's kind (an `OpKind` enum value) if it exists (see `Instruction:op_count()`)
---
---@param operand integer #Operand number, 0-4
---@return integer #An `OpKind` enum value
---
---# Examples
---
---```lua
---from iced_x86 import *
---
---# add [rax],ebx
---data = b"\x01\x18"
---decoder = Decoder(64, data)
---instr = decoder.decode()
---
---assert instr.op_count == 2
---assert instr.op_kind(0) == OpKind.Memory
---assert instr.memory_base == Register.RAX
---assert instr.memory_index == Register.NONE
---assert instr.op_kind(1) == OpKind.Register
---assert instr.op_register(1) == Register.EBX
---```
function Instruction:op_kind(operand) end

---Gets an operand's kind (an `OpKind` enum value) if it exists (see `Instruction:op_count()`)
---
---@param operand integer #Operand number, 0-4
---@param op_kind integer #New value (An `OpKind` enum value)
---
---# Examples
---
---```lua
---from iced_x86 import *
---
---# add [rax],ebx
---data = b"\x01\x18"
---decoder = Decoder(64, data)
---instr = decoder.decode()
---
---assert instr.op_count == 2
---assert instr.op_kind(0) == OpKind.Memory
---assert instr.memory_base == Register.RAX
---assert instr.memory_index == Register.NONE
---assert instr.op_kind(1) == OpKind.Register
---assert instr.op_register(1) == Register.EBX
---```
function Instruction:set_op_kind(operand, op_kind) end

---Checks if the instruction has a segment override prefix, see `Instruction:segment_prefix()`
---
---@return boolean
function Instruction:has_segment_prefix() end

---Gets the segment override prefix (a `Register` enum value) or `Register.None` if none.
---
---See also `Instruction:memory_segment()`.
---
---Use this method if the operand has kind `OpKind.Memory`,
---`OpKind.MemorySegSI`, `OpKind.MemorySegESI`, `OpKind.MemorySegRSI`
---
---@return integer #A `Register` enum value
function Instruction:segment_prefix() end

---Gets the segment override prefix (a `Register` enum value) or `Register.None` if none.
---
---See also `Instruction:memory_segment()`.
---
---Use this method if the operand has kind `OpKind.Memory`,
---`OpKind.MemorySegSI`, `OpKind.MemorySegESI`, `OpKind.MemorySegRSI`
---
---@param new_value integer #New value (A `Register` enum value)
function Instruction:set_segment_prefix(new_value) end

---Gets the effective segment register used to reference the memory location (a `Register` enum value).
---
---Use this method if the operand has kind `OpKind.Memory`, `OpKind.MemorySegSI`, `OpKind.MemorySegESI`, `OpKind.MemorySegRSI`
---
---@return integer #A `Register` enum value
function Instruction:memory_segment() end

---Gets the size of the memory displacement in bytes.
---
---Valid values are `0`, `1` (16/32/64-bit), `2` (16-bit), `4` (32-bit), `8` (64-bit).
---
---Note that the return value can be 1 and `Instruction:memory_displacement()` may still not fit in
---a signed byte if it's an EVEX/MVEX encoded instruction.
---
---Use this method if the operand has kind `OpKind.Memory`
---
---@return integer
function Instruction:memory_displ_size() end

---Gets the size of the memory displacement in bytes.
---
---Valid values are `0`, `1` (16/32/64-bit), `2` (16-bit), `4` (32-bit), `8` (64-bit).
---
---Note that the return value can be 1 and `Instruction:memory_displacement()` may still not fit in
---a signed byte if it's an EVEX/MVEX encoded instruction.
---
---Use this method if the operand has kind `OpKind.Memory`
---
---@param new_value integer #New value
function Instruction:set_memory_displ_size(new_value) end

---`true` if the data is broadcast (EVEX instructions only)
---
---@return boolean
function Instruction:is_broadcast() end

---`true` if the data is broadcast (EVEX instructions only)
---
---@param new_value boolean #New value
function Instruction:set_is_broadcast(new_value) end

---`true` if eviction hint bit is set (`{eh}`) (MVEX instructions only)
---
---@return boolean
function Instruction:is_mvex_eviction_hint() end

---`true` if eviction hint bit is set (`{eh}`) (MVEX instructions only)
---
---@param new_value boolean #New value
function Instruction:set_is_mvex_eviction_hint(new_value) end

---(MVEX) Register/memory operand conversion function (an `MvexRegMemConv` enum value)
---
---@return integer #An `MvexRegMemConv` enum value
function Instruction:mvex_reg_mem_conv() end

---(MVEX) Register/memory operand conversion function (an `MvexRegMemConv` enum value)
---
---@param new_value integer #New value (An `MvexRegMemConv` enum value)
function Instruction:set_mvex_reg_mem_conv(new_value) end

---Gets the size of the memory location (a `MemorySize` enum value) that is referenced by the operand.
---
---See also `Instruction:is_broadcast()`.
---
---Use this method if the operand has kind `OpKind.Memory`,
---`OpKind.MemorySegSI`, `OpKind.MemorySegESI`, `OpKind.MemorySegRSI`,
---`OpKind.MemoryESDI`, `OpKind.MemoryESEDI`, `OpKind.MemoryESRDI`
---
---@return integer #A `MemorySize` enum value
function Instruction:memory_size() end

---Gets the index register scale value, valid values are `*1`, `*2`, `*4`, `*8`.
---
---Use this method if the operand has kind `OpKind.Memory`
---
---@return integer
function Instruction:memory_index_scale() end

---Gets the index register scale value, valid values are `*1`, `*2`, `*4`, `*8`.
---
---Use this method if the operand has kind `OpKind.Memory`
---
---@param new_value integer #New value
function Instruction:set_memory_index_scale(new_value) end

---Gets the memory operand's displacement or the 64-bit absolute address if it's
---an `EIP` or `RIP` relative memory operand.
---
---Use this method if the operand has kind `OpKind.Memory`
---
---@return integer
function Instruction:memory_displacement() end

---Gets the memory operand's displacement or the 64-bit absolute address if it's
---an `EIP` or `RIP` relative memory operand.
---
---Use this method if the operand has kind `OpKind.Memory`
---
---@param new_value integer #New value
function Instruction:set_memory_displacement(new_value) end

---Gets an operand's immediate value
---
---@param operand integer #Operand number, 0-4
---@return integer #(`u64`) The immediate
function Instruction:immediate(operand) end

---Sets an operand's immediate value
---
---@param operand integer #Operand number, 0-4
---@param new_value integer #(`i32`) Immediate
function Instruction:set_immediate_i32(operand, new_value) end

---Sets an operand's immediate value
---
---@param operand integer #Operand number, 0-4
---@param new_value integer #(`u32`) Immediate
function Instruction:set_immediate_u32(operand, new_value) end

---Sets an operand's immediate value
---
---@param operand integer #Operand number, 0-4
---@param new_value integer #(`i64`) Immediate
function Instruction:set_immediate_i64(operand, new_value) end

---Sets an operand's immediate value
---
---@param operand integer #Operand number, 0-4
---@param new_value integer #(`u64`) Immediate
function Instruction:set_immediate_u64(operand, new_value) end

---Gets the operand's immediate value.
---
---Use this method if the operand has kind `OpKind.Immediate8`
---
---@return integer
function Instruction:immediate8() end

---Gets the operand's immediate value.
---
---Use this method if the operand has kind `OpKind.Immediate8`
---
---@param new_value integer #New value
function Instruction:set_immediate8(new_value) end

---Gets the operand's immediate value.
---
---Use this method if the operand has kind `OpKind.Immediate8_2nd`
---
---@return integer
function Instruction:immediate8_2nd() end

---Gets the operand's immediate value.
---
---Use this method if the operand has kind `OpKind.Immediate8_2nd`
---
---@param new_value integer #New value
function Instruction:set_immediate8_2nd(new_value) end

---Gets the operand's immediate value.
---
---Use this method if the operand has kind `OpKind.Immediate16`
---
---@return integer
function Instruction:immediate16() end

---Gets the operand's immediate value.
---
---Use this method if the operand has kind `OpKind.Immediate16`
---
---@param new_value integer #New value
function Instruction:set_immediate16(new_value) end

---Gets the operand's immediate value.
---
---Use this method if the operand has kind `OpKind.Immediate32`
---
---@return integer
function Instruction:immediate32() end

---Gets the operand's immediate value.
---
---Use this method if the operand has kind `OpKind.Immediate32`
---
---@param new_value integer #New value
function Instruction:set_immediate32(new_value) end

---Gets the operand's immediate value.
---
---Use this method if the operand has kind `OpKind.Immediate64`
---
---@return integer
function Instruction:immediate64() end

---Gets the operand's immediate value.
---
---Use this method if the operand has kind `OpKind.Immediate64`
---
---@param new_value integer #New value
function Instruction:set_immediate64(new_value) end

---Gets the operand's immediate value.
---
---Use this method if the operand has kind `OpKind.Immediate8To16`
---
---@return integer
function Instruction:immediate8to16() end

---Gets the operand's immediate value.
---
---Use this method if the operand has kind `OpKind.Immediate8To16`
---
---@param new_value integer #New value
function Instruction:set_immediate8to16(new_value) end

---Gets the operand's immediate value.
---
---Use this method if the operand has kind `OpKind.Immediate8To32`
---
---@return integer
function Instruction:immediate8to32() end

---Gets the operand's immediate value.
---
---Use this method if the operand has kind `OpKind.Immediate8To32`
---
---@param new_value integer #New value
function Instruction:set_immediate8to32(new_value) end

---Gets the operand's immediate value.
---
---Use this method if the operand has kind `OpKind.Immediate8To64`
---
---@return integer
function Instruction:immediate8to64() end

---Gets the operand's immediate value.
---
---Use this method if the operand has kind `OpKind.Immediate8To64`
---
---@param new_value integer #New value
function Instruction:set_immediate8to64(new_value) end

---Gets the operand's immediate value.
---
---Use this method if the operand has kind `OpKind.Immediate32To64`
---
---@return integer
function Instruction:immediate32to64() end

---Gets the operand's immediate value.
---
---Use this method if the operand has kind `OpKind.Immediate32To64`
---
---@param new_value integer #New value
function Instruction:set_immediate32to64(new_value) end

---Gets the operand's branch target.
---
---Use this method if the operand has kind `OpKind.NearBranch16`
---
---@return integer
function Instruction:near_branch16() end

---Gets the operand's branch target.
---
---Use this method if the operand has kind `OpKind.NearBranch16`
---
---@param new_value integer #New value
function Instruction:set_near_branch16(new_value) end

---Gets the operand's branch target.
---
---Use this method if the operand has kind `OpKind.NearBranch32`
---
---@return integer
function Instruction:near_branch32() end

---Gets the operand's branch target.
---
---Use this method if the operand has kind `OpKind.NearBranch32`
---
---@param new_value integer #New value
function Instruction:set_near_branch32(new_value) end

---Gets the operand's branch target.
---
---Use this method if the operand has kind `OpKind.NearBranch64`
---
---@return integer
function Instruction:near_branch64() end

---Gets the operand's branch target.
---
---Use this method if the operand has kind `OpKind.NearBranch64`
---
---@param new_value integer #New value
function Instruction:set_near_branch64(new_value) end

---Gets the near branch target if it's a `CALL`/`JMP`/`Jcc` near branch instruction
---
---(i.e., if `Instruction:op0_kind()` is `OpKind.NearBranch16`, `OpKind.NearBranch32` or `OpKind.NearBranch64`)
---
---@return integer
function Instruction:near_branch_target() end

---Gets the operand's branch target.
---
---Use this method if the operand has kind `OpKind.FarBranch16`
---
---@return integer
function Instruction:far_branch16() end

---Gets the operand's branch target.
---
---Use this method if the operand has kind `OpKind.FarBranch16`
---
---@param new_value integer #New value
function Instruction:set_far_branch16(new_value) end

---Gets the operand's branch target.
---
---Use this method if the operand has kind `OpKind.FarBranch32`
---
---@return integer
function Instruction:far_branch32() end

---Gets the operand's branch target.
---
---Use this method if the operand has kind `OpKind.FarBranch32`
---
---@param new_value integer #New value
function Instruction:set_far_branch32(new_value) end

---Gets the operand's branch target selector.
---
---Use this method if the operand has kind `OpKind.FarBranch16` or `OpKind.FarBranch32`
---
---@return integer
function Instruction:far_branch_selector() end

---Gets the operand's branch target selector.
---
---Use this method if the operand has kind `OpKind.FarBranch16` or `OpKind.FarBranch32`
---
---@param new_value integer #New value
function Instruction:set_far_branch_selector(new_value) end

---Gets the memory operand's base register (a `Register` enum value) or `Register.None` if none.
---
---Use this method if the operand has kind `OpKind.Memory`
---
---@return integer #A `Register` enum value
function Instruction:memory_base() end

---Gets the memory operand's base register (a `Register` enum value) or `Register.None` if none.
---
---Use this method if the operand has kind `OpKind.Memory`
---
---@param new_value integer #New value (A `Register` enum value)
function Instruction:set_memory_base(new_value) end

---Gets the memory operand's index register (a `Register` enum value) or `Register.None` if none.
---
---Use this method if the operand has kind `OpKind.Memory`
---
---@return integer #A `Register` enum value
function Instruction:memory_index() end

---Gets the memory operand's index register (a `Register` enum value) or `Register.None` if none.
---
---Use this method if the operand has kind `OpKind.Memory`
---
---@param new_value integer #New value (A `Register` enum value)
function Instruction:set_memory_index(new_value) end

---Gets operand #0's register value (a `Register` enum value).
---
---Use this method if operand #0 (`Instruction:op0_kind()`) has kind `OpKind.Register`, see `Instruction:op_count()` and `Instruction:op_register()`
---
---@return integer #A `Register` enum value
function Instruction:op0_register() end

---Gets operand #0's register value (a `Register` enum value).
---
---Use this method if operand #0 (`Instruction:op0_kind()`) has kind `OpKind.Register`, see `Instruction:op_count()` and `Instruction:op_register()`
---
---@param new_value integer #New value (A `Register` enum value)
function Instruction:set_op0_register(new_value) end

---Gets operand #1's register value (a `Register` enum value).
---
---Use this method if operand #1 (`Instruction:op0_kind()`) has kind `OpKind.Register`, see `Instruction:op_count()` and `Instruction:op_register()`
---
---@return integer #A `Register` enum value
function Instruction:op1_register() end

---Gets operand #1's register value (a `Register` enum value).
---
---Use this method if operand #1 (`Instruction:op0_kind()`) has kind `OpKind.Register`, see `Instruction:op_count()` and `Instruction:op_register()`
---
---@param new_value integer #New value (A `Register` enum value)
function Instruction:set_op1_register(new_value) end

---Gets operand #2's register value (a `Register` enum value).
---
---Use this method if operand #2 (`Instruction:op0_kind()`) has kind `OpKind.Register`, see `Instruction:op_count()` and `Instruction:op_register()`
---
---@return integer #A `Register` enum value
function Instruction:op2_register() end

---Gets operand #2's register value (a `Register` enum value).
---
---Use this method if operand #2 (`Instruction:op0_kind()`) has kind `OpKind.Register`, see `Instruction:op_count()` and `Instruction:op_register()`
---
---@param new_value integer #New value (A `Register` enum value)
function Instruction:set_op2_register(new_value) end

---Gets operand #3's register value (a `Register` enum value).
---
---Use this method if operand #3 (`Instruction:op0_kind()`) has kind `OpKind.Register`, see `Instruction:op_count()` and `Instruction:op_register()`
---
---@return integer #A `Register` enum value
function Instruction:op3_register() end

---Gets operand #3's register value (a `Register` enum value).
---
---Use this method if operand #3 (`Instruction:op0_kind()`) has kind `OpKind.Register`, see `Instruction:op_count()` and `Instruction:op_register()`
---
---@param new_value integer #New value (A `Register` enum value)
function Instruction:set_op3_register(new_value) end

---Gets operand #4's register value (a `Register` enum value).
---
---Use this method if operand #4 (`Instruction:op0_kind()`) has kind `OpKind.Register`, see `Instruction:op_count()` and `Instruction:op_register()`
---
---@return integer #A `Register` enum value
function Instruction:op4_register() end

---Gets operand #4's register value (a `Register` enum value).
---
---Use this method if operand #4 (`Instruction:op0_kind()`) has kind `OpKind.Register`, see `Instruction:op_count()` and `Instruction:op_register()`
---
---@param new_value integer #New value (A `Register` enum value)
function Instruction:set_op4_register(new_value) end

---Gets the operand's register value (a `Register` enum value).
---
---Use this method if the operand has kind `OpKind.Register`
---
---@param operand integer #Operand number, 0-4
---@return integer #(A `Register` enum value) The operand's register value
---
---# Examples
---
---```lua
---from iced_x86 import *
---
---# add [rax],ebx
---data = b"\x01\x18"
---decoder = Decoder(64, data)
---instr = decoder.decode()
---
---assert instr.op_count == 2
---assert instr.op_kind(0) == OpKind.Memory
---assert instr.op_kind(1) == OpKind.Register
---assert instr.op_register(1) == Register.EBX
---```
function Instruction:op_register(operand) end

---Gets the operand's register value (a `Register` enum value).
---
---Use this method if the operand has kind `OpKind.Register`
---
---@param operand integer #Operand number, 0-4
---@param new_value integer #New value ((A `Register` enum value) The operand's register value)
---
---# Examples
---
---```lua
---from iced_x86 import *
---
---# add [rax],ebx
---data = b"\x01\x18"
---decoder = Decoder(64, data)
---instr = decoder.decode()
---
---assert instr.op_count == 2
---assert instr.op_kind(0) == OpKind.Memory
---assert instr.op_kind(1) == OpKind.Register
---assert instr.op_register(1) == Register.EBX
---```
function Instruction:set_op_register(operand, new_value) end

---Gets the opmask register (`Register.K1` - `Register.K7`) or `Register.None` if none (a `Register` enum value)
---
---@return integer #A `Register` enum value
function Instruction:op_mask() end

---Gets the opmask register (`Register.K1` - `Register.K7`) or `Register.None` if none (a `Register` enum value)
---
---@param new_value integer #New value (A `Register` enum value)
function Instruction:set_op_mask(new_value) end

---Checks if there's an opmask register (`Instruction:op_mask()`)
---
---@return boolean
function Instruction:has_op_mask() end

---`true` if zeroing-masking, `false` if merging-masking.
---
---Only used by most EVEX encoded instructions that use opmask registers.
---
---@return boolean
function Instruction:zeroing_masking() end

---`true` if zeroing-masking, `false` if merging-masking.
---
---Only used by most EVEX encoded instructions that use opmask registers.
---
---@param new_value boolean #New value
function Instruction:set_zeroing_masking(new_value) end

---`true` if merging-masking, `false` if zeroing-masking.
---
---Only used by most EVEX encoded instructions that use opmask registers.
---
---@return boolean
function Instruction:merging_masking() end

---`true` if merging-masking, `false` if zeroing-masking.
---
---Only used by most EVEX encoded instructions that use opmask registers.
---
---@param new_value boolean #New value
function Instruction:set_merging_masking(new_value) end

---Gets the rounding control (a `RoundingControl` enum value) or `RoundingControl.None` if the instruction doesn't use it.
---
---# Note
---SAE is implied but `Instruction:suppress_all_exceptions()` still returns `false`.
---
---@return integer #A `RoundingControl` enum value
function Instruction:rounding_control() end

---Gets the rounding control (a `RoundingControl` enum value) or `RoundingControl.None` if the instruction doesn't use it.
---
---# Note
---SAE is implied but `Instruction:suppress_all_exceptions()` still returns `false`.
---
---@param new_value integer #New value (A `RoundingControl` enum value)
function Instruction:set_rounding_control(new_value) end

---Gets the number of elements in a `db`/`dw`/`dd`/`dq` directive.
---
---Can only be called if `Instruction:code()` is `Code.DeclareByte`, `Code.DeclareWord`, `Code.DeclareDword`, `Code.DeclareQword`
---
---@return integer
function Instruction:declare_data_len() end

---Gets the number of elements in a `db`/`dw`/`dd`/`dq` directive.
---
---Can only be called if `Instruction:code()` is `Code.DeclareByte`, `Code.DeclareWord`, `Code.DeclareDword`, `Code.DeclareQword`
---
---@param new_value integer #New value
function Instruction:set_declare_data_len(new_value) end

---Sets a new `db` value, see also `Instruction:declare_data_len()`.
---
---Can only be called if `Instruction:code()` is `Code.DeclareByte`
---
---@param index integer #Index (0-15)
---@param new_value integer #(`u8`) New value
function Instruction:set_declare_byte_value(index, new_value) end

---Gets a `db` value, see also `Instruction:declare_data_len()`.
---
---Can only be called if `Instruction:code()` is `Code.DeclareByte`
---
---@param index integer #Index (0-15)
---@return integer #(`u8`) The value
function Instruction:get_declare_byte_value(index) end

---Gets a `db` value, see also `Instruction:declare_data_len()`.
---
---Can only be called if `Instruction:code()` is `Code.DeclareByte`
---
---@param index integer #Index (0-15)
---@return integer #(`i8`) The value
function Instruction:get_declare_byte_value_i8(index) end

---Sets a new `dw` value, see also `Instruction:declare_data_len()`.
---
---Can only be called if `Instruction:code()` is `Code.DeclareWord`
---
---@param index integer #Index (0-7)
---@param new_value integer #(`u16`) New value
function Instruction:set_declare_word_value(index, new_value) end

---Gets a `dw` value, see also `Instruction:declare_data_len()`.
---
---Can only be called if `Instruction:code()` is `Code.DeclareWord`
---
---@param index integer #Index (0-7)
---@return integer #(`u16`) The value
function Instruction:get_declare_word_value(index) end

---Gets a `dw` value, see also `Instruction:declare_data_len()`.
---
---Can only be called if `Instruction:code()` is `Code.DeclareWord`
---
---@param index integer #Index (0-7)
---@return integer #(`i16`) The value
function Instruction:get_declare_word_value_i16(index) end

---Sets a new `dd` value, see also `Instruction:declare_data_len()`.
---
---Can only be called if `Instruction:code()` is `Code.DeclareDword`
---
---@param index integer #Index (0-3)
---@param new_value integer #(`u32`) New value
function Instruction:set_declare_dword_value(index, new_value) end

---Gets a `dd` value, see also `Instruction:declare_data_len()`.
---
---Can only be called if `Instruction:code()` is `Code.DeclareDword`
---
---@param index integer #Index (0-3)
---@return integer #(`u32`) The value
function Instruction:get_declare_dword_value(index) end

---Gets a `dd` value, see also `Instruction:declare_data_len()`.
---
---Can only be called if `Instruction:code()` is `Code.DeclareDword`
---
---@param index integer #Index (0-3)
---@return integer #(`i32`) The value
function Instruction:get_declare_dword_value_i32(index) end

---Sets a new `dq` value, see also `Instruction:declare_data_len()`.
---
---Can only be called if `Instruction:code()` is `Code.DeclareQword`
---
---@param index integer #Index (0-1)
---@param new_value integer #(`u64`) New value
function Instruction:set_declare_qword_value(index, new_value) end

---Gets a `dq` value, see also `Instruction:declare_data_len()`.
---
---Can only be called if `Instruction:code()` is `Code.DeclareQword`
---
---@param index integer #Index (0-1)
---@return integer #(`u64`) The value
function Instruction:get_declare_qword_value(index) end

---Gets a `dq` value, see also `Instruction:declare_data_len()`.
---
---Can only be called if `Instruction:code()` is `Code.DeclareQword`
---
---@param index integer #Index (0-1)
---@return integer #(`i64`) The value
function Instruction:get_declare_qword_value_i64(index) end

---Checks if this is a VSIB instruction, see also `Instruction:is_vsib32()`, `Instruction:is_vsib64()`
---
---@return boolean
function Instruction:is_vsib() end

---VSIB instructions only (`Instruction:is_vsib()`): `true` if it's using 32-bit indexes, `false` if it's using 64-bit indexes
---
---@return boolean
function Instruction:is_vsib32() end

---VSIB instructions only (`Instruction:is_vsib()`): `true` if it's using 64-bit indexes, `false` if it's using 32-bit indexes
---
---@return boolean
function Instruction:is_vsib64() end

---Checks if it's a vsib instruction.
---
---- Returns `true` if it's a VSIB instruction with 64-bit indexes
---- Returns `false` if it's a VSIB instruction with 32-bit indexes
---- Returns `nil` if it's not a VSIB instruction.
---
---@return boolean|nil
function Instruction:vsib() end

---Gets the suppress all exceptions flag (EVEX/MVEX encoded instructions). Note that if `Instruction:rounding_control()` is not `RoundingControl.None`, SAE is implied but this method will still return `false`.
---
---@return boolean
function Instruction:suppress_all_exceptions() end

---Gets the suppress all exceptions flag (EVEX/MVEX encoded instructions). Note that if `Instruction:rounding_control()` is not `RoundingControl.None`, SAE is implied but this method will still return `false`.
---
---@param new_value boolean #New value
function Instruction:set_suppress_all_exceptions(new_value) end

---Checks if the memory operand is `RIP`/`EIP` relative
---
---@return boolean
function Instruction:is_ip_rel_memory_operand() end

---Gets the `RIP`/`EIP` releative address (`Instruction:memory_displacement()`).
---
---This method is only valid if there's a memory operand with `RIP`/`EIP` relative addressing, see `Instruction:is_ip_rel_memory_operand()`
---
---@return integer
function Instruction:ip_rel_memory_address() end

---Gets the number of bytes added to `SP`/`ESP`/`RSP` or 0 if it's not an instruction that pushes or pops data.
---
---This method assumes the instruction doesn't change the privilege level (eg. `IRET/D/Q`). If it's the `LEAVE`
---instruction, this method returns 0.
---
---@return integer
---
---# Examples
---
---```lua
---from iced_x86 import *
---
---# pushfq
---data = b"\x9C"
---decoder = Decoder(64, data)
---instr = decoder.decode()
---
---assert instr.is_stack_instruction
---assert instr.stack_pointer_increment == -8
---```
function Instruction:stack_pointer_increment() end

---Gets the FPU status word's `TOP` increment and whether it's a conditional or unconditional push/pop and whether `TOP` is written.
---
---@return FpuStackIncrementInfo #FPU stack info
---
---# Examples
---
---```lua
---from iced_x86 import *
---
---# ficomp dword ptr [rax]
---data = b"\xDA\x18"
---decoder = Decoder(64, data)
---instr = decoder.decode()
---
---info = instr.fpu_stack_increment_info()
---# It pops the stack once
---assert info.increment == 1
---assert not info.conditional
---assert info.writes_top
---```
function Instruction:fpu_stack_increment_info() end

---Instruction encoding, eg. Legacy, 3DNow!, VEX, EVEX, XOP (an `EncodingKind` enum value)
---
---@return integer #An `EncodingKind` enum value
---
---# Examples
---
---```lua
---from iced_x86 import *
---
---# vmovaps xmm1,xmm5
---data = b"\xC5\xF8\x28\xCD"
---decoder = Decoder(64, data)
---instr = decoder.decode()
---
---assert instr.encoding == EncodingKind.VEX
---```
function Instruction:encoding() end

---Gets the CPU or CPUID feature flags (an array of `CpuidFeature` enum values)
---
---@return integer[] #(A `CpuidFeature` array) CPU or CPUID feature flags
---
---# Examples
---
---```lua
---from iced_x86 import *
---
---# vmovaps xmm1,xmm5
---# vmovaps xmm10{k3}{z},xmm19
---data = b"\xC5\xF8\x28\xCD\x62\x31\x7C\x8B\x28\xD3"
---decoder = Decoder(64, data)
---
---# vmovaps xmm1,xmm5
---instr = decoder.decode()
---cpuid = instr.cpuid_features()
---assert len(cpuid) == 1
---assert cpuid[0] == CpuidFeature.AVX
---
---# vmovaps xmm10{k3}{z},xmm19
---instr = decoder.decode()
---cpuid = instr.cpuid_features()
---assert len(cpuid) == 2
---assert cpuid[0] == CpuidFeature.AVX512VL
---assert cpuid[1] == CpuidFeature.AVX512F
---```
function Instruction:cpuid_features() end

---Control flow info (a `FlowControl` enum value)
---
---@return integer #A `FlowControl` enum value
---
---# Examples
---
---```lua
---from iced_x86 import *
---
---# or ecx,esi
---# ud0 rcx,rsi
---# call rcx
---data = b"\x0B\xCE\x48\x0F\xFF\xCE\xFF\xD1"
---decoder = Decoder(64, data)
---
---# or ecx,esi
---instr = decoder.decode()
---assert instr.flow_control == FlowControl.NEXT
---
---# ud0 rcx,rsi
---instr = decoder.decode()
---assert instr.flow_control == FlowControl.EXCEPTION
---
---# call rcx
---instr = decoder.decode()
---assert instr.flow_control == FlowControl.INDIRECT_CALL
---```
function Instruction:flow_control() end

---`true` if it's a privileged instruction (all CPL=0 instructions (except `VMCALL`) and IOPL instructions `IN`, `INS`, `OUT`, `OUTS`, `CLI`, `STI`)
---
---@return boolean
function Instruction:is_privileged() end

---`true` if this is an instruction that implicitly uses the stack pointer (`SP`/`ESP`/`RSP`), eg. `CALL`, `PUSH`, `POP`, `RET`, etc.
---
---See also `Instruction:stack_pointer_increment()`
---
---@return boolean
---
---# Examples
---
---```lua
---from iced_x86 import *
---
---# or ecx,esi
---# push rax
---data = b"\x0B\xCE\x50"
---decoder = Decoder(64, data)
---
---# or ecx,esi
---instr = decoder.decode()
---assert not instr.is_stack_instruction
---
---# push rax
---instr = decoder.decode()
---assert instr.is_stack_instruction
---assert instr.stack_pointer_increment == -8
---```
function Instruction:is_stack_instruction() end

---`true` if it's an instruction that saves or restores too many registers (eg. `FXRSTOR`, `XSAVE`, etc).
---
---@return boolean
function Instruction:is_save_restore_instruction() end

---`true` if it's a "string" instruction, such as `MOVS`, `LODS`, `SCAS`, etc.
---
---@return boolean
function Instruction:is_string_instruction() end

---All flags that are read by the CPU when executing the instruction.
---
---This method returns an `RflagsBits` value. See also `Instruction:rflags_modified()`.
---
---@return integer #An `RflagsBits` enum value
---
---# Examples
---
---```lua
---from iced_x86 import *
---
---# adc rsi,rcx
---# xor rdi,5Ah
---data = b"\x48\x11\xCE\x48\x83\xF7\x5A"
---decoder = Decoder(64, data)
---
---# adc rsi,rcx
---instr = decoder.decode()
---assert instr.rflags_read == RflagsBits.CF
---assert instr.rflags_written == RflagsBits.OF | RflagsBits.SF | RflagsBits.ZF | RflagsBits.AF | RflagsBits.CF | RflagsBits.PF
---assert instr.rflags_cleared == RflagsBits.NONE
---assert instr.rflags_set == RflagsBits.NONE
---assert instr.rflags_undefined == RflagsBits.NONE
---assert instr.rflags_modified == RflagsBits.OF | RflagsBits.SF | RflagsBits.ZF | RflagsBits.AF | RflagsBits.CF | RflagsBits.PF
---
---# xor rdi,5Ah
---instr = decoder.decode()
---assert instr.rflags_read == RflagsBits.NONE
---assert instr.rflags_written == RflagsBits.SF | RflagsBits.ZF | RflagsBits.PF
---assert instr.rflags_cleared == RflagsBits.OF | RflagsBits.CF
---assert instr.rflags_set == RflagsBits.NONE
---assert instr.rflags_undefined == RflagsBits.AF
---assert instr.rflags_modified == RflagsBits.OF | RflagsBits.SF | RflagsBits.ZF | RflagsBits.AF | RflagsBits.CF | RflagsBits.PF
---```
function Instruction:rflags_read() end

---All flags that are written by the CPU, except those flags that are known to be undefined, always set or always cleared.
---
---This method returns an `RflagsBits` value. See also `Instruction:rflags_modified()`.
---
---@return integer #An `RflagsBits` enum value
---
---# Examples
---
---```lua
---from iced_x86 import *
---
---# adc rsi,rcx
---# xor rdi,5Ah
---data = b"\x48\x11\xCE\x48\x83\xF7\x5A"
---decoder = Decoder(64, data)
---
---# adc rsi,rcx
---instr = decoder.decode()
---assert instr.rflags_read == RflagsBits.CF
---assert instr.rflags_written == RflagsBits.OF | RflagsBits.SF | RflagsBits.ZF | RflagsBits.AF | RflagsBits.CF | RflagsBits.PF
---assert instr.rflags_cleared == RflagsBits.NONE
---assert instr.rflags_set == RflagsBits.NONE
---assert instr.rflags_undefined == RflagsBits.NONE
---assert instr.rflags_modified == RflagsBits.OF | RflagsBits.SF | RflagsBits.ZF | RflagsBits.AF | RflagsBits.CF | RflagsBits.PF
---
---# xor rdi,5Ah
---instr = decoder.decode()
---assert instr.rflags_read == RflagsBits.NONE
---assert instr.rflags_written == RflagsBits.SF | RflagsBits.ZF | RflagsBits.PF
---assert instr.rflags_cleared == RflagsBits.OF | RflagsBits.CF
---assert instr.rflags_set == RflagsBits.NONE
---assert instr.rflags_undefined == RflagsBits.AF
---assert instr.rflags_modified == RflagsBits.OF | RflagsBits.SF | RflagsBits.ZF | RflagsBits.AF | RflagsBits.CF | RflagsBits.PF
---```
function Instruction:rflags_written() end

---All flags that are always cleared by the CPU.
---
---This method returns an `RflagsBits` value. See also `Instruction:rflags_modified()`.
---
---@return integer #An `RflagsBits` enum value
---
---# Examples
---
---```lua
---from iced_x86 import *
---
---# adc rsi,rcx
---# xor rdi,5Ah
---data = b"\x48\x11\xCE\x48\x83\xF7\x5A"
---decoder = Decoder(64, data)
---
---# adc rsi,rcx
---instr = decoder.decode()
---assert instr.rflags_read == RflagsBits.CF
---assert instr.rflags_written == RflagsBits.OF | RflagsBits.SF | RflagsBits.ZF | RflagsBits.AF | RflagsBits.CF | RflagsBits.PF
---assert instr.rflags_cleared == RflagsBits.NONE
---assert instr.rflags_set == RflagsBits.NONE
---assert instr.rflags_undefined == RflagsBits.NONE
---assert instr.rflags_modified == RflagsBits.OF | RflagsBits.SF | RflagsBits.ZF | RflagsBits.AF | RflagsBits.CF | RflagsBits.PF
---
---# xor rdi,5Ah
---instr = decoder.decode()
---assert instr.rflags_read == RflagsBits.NONE
---assert instr.rflags_written == RflagsBits.SF | RflagsBits.ZF | RflagsBits.PF
---assert instr.rflags_cleared == RflagsBits.OF | RflagsBits.CF
---assert instr.rflags_set == RflagsBits.NONE
---assert instr.rflags_undefined == RflagsBits.AF
---assert instr.rflags_modified == RflagsBits.OF | RflagsBits.SF | RflagsBits.ZF | RflagsBits.AF | RflagsBits.CF | RflagsBits.PF
---```
function Instruction:rflags_cleared() end

---All flags that are always set by the CPU.
---
---This method returns an `RflagsBits` value. See also `Instruction:rflags_modified()`.
---
---@return integer #An `RflagsBits` enum value
---
---# Examples
---
---```lua
---from iced_x86 import *
---
---# adc rsi,rcx
---# xor rdi,5Ah
---data = b"\x48\x11\xCE\x48\x83\xF7\x5A"
---decoder = Decoder(64, data)
---
---# adc rsi,rcx
---instr = decoder.decode()
---assert instr.rflags_read == RflagsBits.CF
---assert instr.rflags_written == RflagsBits.OF | RflagsBits.SF | RflagsBits.ZF | RflagsBits.AF | RflagsBits.CF | RflagsBits.PF
---assert instr.rflags_cleared == RflagsBits.NONE
---assert instr.rflags_set == RflagsBits.NONE
---assert instr.rflags_undefined == RflagsBits.NONE
---assert instr.rflags_modified == RflagsBits.OF | RflagsBits.SF | RflagsBits.ZF | RflagsBits.AF | RflagsBits.CF | RflagsBits.PF
---
---# xor rdi,5Ah
---instr = decoder.decode()
---assert instr.rflags_read == RflagsBits.NONE
---assert instr.rflags_written == RflagsBits.SF | RflagsBits.ZF | RflagsBits.PF
---assert instr.rflags_cleared == RflagsBits.OF | RflagsBits.CF
---assert instr.rflags_set == RflagsBits.NONE
---assert instr.rflags_undefined == RflagsBits.AF
---assert instr.rflags_modified == RflagsBits.OF | RflagsBits.SF | RflagsBits.ZF | RflagsBits.AF | RflagsBits.CF | RflagsBits.PF
---```
function Instruction:rflags_set() end

---All flags that are undefined after executing the instruction.
---
---This method returns an `RflagsBits` value. See also `Instruction:rflags_modified()`.
---
---@return integer #An `RflagsBits` enum value
---
---# Examples
---
---```lua
---from iced_x86 import *
---
---# adc rsi,rcx
---# xor rdi,5Ah
---data = b"\x48\x11\xCE\x48\x83\xF7\x5A"
---decoder = Decoder(64, data)
---
---# adc rsi,rcx
---instr = decoder.decode()
---assert instr.rflags_read == RflagsBits.CF
---assert instr.rflags_written == RflagsBits.OF | RflagsBits.SF | RflagsBits.ZF | RflagsBits.AF | RflagsBits.CF | RflagsBits.PF
---assert instr.rflags_cleared == RflagsBits.NONE
---assert instr.rflags_set == RflagsBits.NONE
---assert instr.rflags_undefined == RflagsBits.NONE
---assert instr.rflags_modified == RflagsBits.OF | RflagsBits.SF | RflagsBits.ZF | RflagsBits.AF | RflagsBits.CF | RflagsBits.PF
---
---# xor rdi,5Ah
---instr = decoder.decode()
---assert instr.rflags_read == RflagsBits.NONE
---assert instr.rflags_written == RflagsBits.SF | RflagsBits.ZF | RflagsBits.PF
---assert instr.rflags_cleared == RflagsBits.OF | RflagsBits.CF
---assert instr.rflags_set == RflagsBits.NONE
---assert instr.rflags_undefined == RflagsBits.AF
---assert instr.rflags_modified == RflagsBits.OF | RflagsBits.SF | RflagsBits.ZF | RflagsBits.AF | RflagsBits.CF | RflagsBits.PF
---```
function Instruction:rflags_undefined() end

---All flags that are modified by the CPU. This is `rflags_written + rflags_cleared + rflags_set + rflags_undefined`.
---
---This method returns an `RflagsBits` value.
---
---@return integer #An `RflagsBits` enum value
---
---# Examples
---
---```lua
---from iced_x86 import *
---
---# adc rsi,rcx
---# xor rdi,5Ah
---data = b"\x48\x11\xCE\x48\x83\xF7\x5A"
---decoder = Decoder(64, data)
---
---# adc rsi,rcx
---instr = decoder.decode()
---assert instr.rflags_read == RflagsBits.CF
---assert instr.rflags_written == RflagsBits.OF | RflagsBits.SF | RflagsBits.ZF | RflagsBits.AF | RflagsBits.CF | RflagsBits.PF
---assert instr.rflags_cleared == RflagsBits.NONE
---assert instr.rflags_set == RflagsBits.NONE
---assert instr.rflags_undefined == RflagsBits.NONE
---assert instr.rflags_modified == RflagsBits.OF | RflagsBits.SF | RflagsBits.ZF | RflagsBits.AF | RflagsBits.CF | RflagsBits.PF
---
---# xor rdi,5Ah
---instr = decoder.decode()
---assert instr.rflags_read == RflagsBits.NONE
---assert instr.rflags_written == RflagsBits.SF | RflagsBits.ZF | RflagsBits.PF
---assert instr.rflags_cleared == RflagsBits.OF | RflagsBits.CF
---assert instr.rflags_set == RflagsBits.NONE
---assert instr.rflags_undefined == RflagsBits.AF
---assert instr.rflags_modified == RflagsBits.OF | RflagsBits.SF | RflagsBits.ZF | RflagsBits.AF | RflagsBits.CF | RflagsBits.PF
---```
function Instruction:rflags_modified() end

---Checks if it's a `Jcc SHORT` or `Jcc NEAR` instruction
---
---@return boolean
function Instruction:is_jcc_short_or_near() end

---Checks if it's a `Jcc NEAR` instruction
---
---@return boolean
function Instruction:is_jcc_near() end

---Checks if it's a `Jcc SHORT` instruction
---
---@return boolean
function Instruction:is_jcc_short() end

---Checks if it's a `JMP SHORT` instruction
---
---@return boolean
function Instruction:is_jmp_short() end

---Checks if it's a `JMP NEAR` instruction
---
---@return boolean
function Instruction:is_jmp_near() end

---Checks if it's a `JMP SHORT` or a `JMP NEAR` instruction
---
---@return boolean
function Instruction:is_jmp_short_or_near() end

---Checks if it's a `JMP FAR` instruction
---
---@return boolean
function Instruction:is_jmp_far() end

---Checks if it's a `CALL NEAR` instruction
---
---@return boolean
function Instruction:is_call_near() end

---Checks if it's a `CALL FAR` instruction
---
---@return boolean
function Instruction:is_call_far() end

---Checks if it's a `JMP NEAR reg/[mem]` instruction
---
---@return boolean
function Instruction:is_jmp_near_indirect() end

---Checks if it's a `JMP FAR [mem]` instruction
---
---@return boolean
function Instruction:is_jmp_far_indirect() end

---Checks if it's a `CALL NEAR reg/[mem]` instruction
---
---@return boolean
function Instruction:is_call_near_indirect() end

---Checks if it's a `CALL FAR [mem]` instruction
---
---@return boolean
function Instruction:is_call_far_indirect() end

---Checks if it's a `JKccD SHORT` or `JKccD NEAR` instruction
---
---@return boolean
function Instruction:is_jkcc_short_or_near() end

---Checks if it's a `JKccD NEAR` instruction
---
---@return boolean
function Instruction:is_jkcc_near() end

---Checks if it's a `JKccD SHORT` instruction
---
---@return boolean
function Instruction:is_jkcc_short() end

---Checks if it's a `JCXZ SHORT`, `JECXZ SHORT` or `JRCXZ SHORT` instruction
---
---@return boolean
function Instruction:is_jcx_short() end

---Checks if it's a `LOOPcc SHORT` instruction
---
---@return boolean
function Instruction:is_loopcc() end

---Checks if it's a `LOOP SHORT` instruction
---
---@return boolean
function Instruction:is_loop() end

---Negates the condition code, eg. `JE` -> `JNE`.
---
---Can be used if it's `Jcc`, `SETcc`, `CMOVcc`, `LOOPcc` and does nothing if the instruction doesn't have a condition code.
---
---# Examples
---
---```lua
---from iced_x86 import *
---
---# setbe al
---data = b"\x0F\x96\xC0"
---decoder = Decoder(64, data)
---
---instr = decoder.decode()
---assert instr.code == Code.SETBE_RM8
---assert instr.condition_code == ConditionCode.BE
---instr.negate_condition_code()
---assert instr.code == Code.SETA_RM8
---assert instr.condition_code == ConditionCode.A
---```
function Instruction:negate_condition_code() end

---Converts `Jcc/JMP NEAR` to `Jcc/JMP SHORT` and does nothing if it's not a `Jcc/JMP NEAR` instruction
---
---# Examples
---
---```lua
---from iced_x86 import *
---
---# jbe near ptr label
---data = b"\x0F\x86\x5A\xA5\x12\x34"
---decoder = Decoder(64, data)
---
---instr = decoder.decode()
---assert instr.code == Code.JBE_REL32_64
---instr.as_short_branch()
---assert instr.code == Code.JBE_REL8_64
---instr.as_short_branch()
---assert instr.code == Code.JBE_REL8_64
---```
function Instruction:as_short_branch() end

---Converts `Jcc/JMP SHORT` to `Jcc/JMP NEAR` and does nothing if it's not a `Jcc/JMP SHORT` instruction
---
---# Examples
---
---```lua
---from iced_x86 import *
---
---# jbe short label
---data = b"\x76\x5A"
---decoder = Decoder(64, data)
---
---instr = decoder.decode()
---assert instr.code == Code.JBE_REL8_64
---instr.as_near_branch()
---assert instr.code == Code.JBE_REL32_64
---instr.as_near_branch()
---assert instr.code == Code.JBE_REL32_64
---```
function Instruction:as_near_branch() end

---Gets the condition code (a `ConditionCode` enum value) if it's `Jcc`, `SETcc`, `CMOVcc`, `LOOPcc` else `ConditionCode.None` is returned
---
---@return integer #A `ConditionCode` enum value
---
---# Examples
---
---```lua
---from iced_x86 import *
---
---# setbe al
---# jl short label
---# cmovne ecx,esi
---# nop
---data = b"\x0F\x96\xC0\x7C\x5A\x0F\x45\xCE\x90"
---decoder = Decoder(64, data)
---
---# setbe al
---instr = decoder.decode()
---assert instr.condition_code == ConditionCode.BE
---
---# jl short label
---instr = decoder.decode()
---assert instr.condition_code == ConditionCode.L
---
---# cmovne ecx,esi
---instr = decoder.decode()
---assert instr.condition_code == ConditionCode.NE
---
---# nop
---instr = decoder.decode()
---assert instr.condition_code == ConditionCode.NONE
---```
function Instruction:condition_code() end

---Gets the `OpCodeInfo`
---
---@return OpCodeInfo #Op code info
function Instruction:op_code() end

---Gets all used registers
---
---See also `Instruction:used_memory()`, `Instruction:op_accesses()`, `Instruction:used_regs_mem()`, `Instruction:used_values()`
---
---@return UsedRegister[] #All used registers
---
---# Examples
---
---```lua
-----TODO: show an example here
---```
function Instruction:used_registers() end

---Gets all used memory locations
---
---See also `Instruction:used_registers()`, `Instruction:op_accesses()`, `Instruction:used_regs_mem()`, `Instruction:used_values()`
---
---@return UsedMemory[] #All used memory locations
---
---# Examples
---
---```lua
-----TODO: show an example here
---```
function Instruction:used_memory() end

---Gets all operand accesses (Array of `OpAccess` values)
---
---See also `Instruction:used_registers()`, `Instruction:used_memory()`, `Instruction:used_regs_mem()`, `Instruction:used_values()`
---
---@return integer[] #Array of `OpAccess` values
---
---# Examples
---
---```lua
-----TODO: show an example here
---```
function Instruction:op_accesses() end

---Gets all used registers and all used memory locations
---
---See also `Instruction:used_registers()`, `Instruction:used_memory()`, `Instruction:op_accesses()`, `Instruction:used_values()`
---
---@return UsedRegister[], UsedMemory[] #Used registers, used memory locations
---
---# Examples
---
---```lua
-----TODO: show an example here
---```
function Instruction:used_regs_mem() end

---Gets all used registers, all used memory locations and all operand accesses
---
---See also `Instruction:used_registers()`, `Instruction:used_memory()`, `Instruction:op_accesses()`, `Instruction:used_regs_mem()`
---
---@return UsedRegister[], UsedMemory[], integer[] #Used registers, used memory locations and `OpAccess`[]
---
---# Examples
---
---```lua
-----TODO: show an example here
---```
function Instruction:used_values() end

return Instruction
