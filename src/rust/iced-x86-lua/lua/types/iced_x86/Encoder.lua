-- SPDX-License-Identifier: MIT
-- Copyright (C) 2018-present iced project and contributors

-- ‚ö†Ô∏èThis file was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è

---@meta
---@diagnostic disable unused-local

---Encodes instructions decoded by the decoder or instructions created by other code.
---See also `BlockEncoder` which can encode any number of instructions.
---
---@class Encoder
local Encoder = {}

---Encodes instructions decoded by the decoder or instructions created by other code.
---
---See also `BlockEncoder` which can encode any number of instructions.
---
---@param bitness integer #16, 32 or 64
---@param capacity? integer #(default = 0) Initial capacity of the byte buffer
---@return Encoder
---
---# Examples
---
---```lua
---from iced_x86 import *
---
---# xchg ah,[rdx+rsi+16h]
---data = b"\x86\x64\x32\x16"
---decoder = Decoder(64, data, ip=0x1234_5678)
---instr = decoder.decode()
---
---encoder = Encoder(64)
---try:
---    instr_len = encoder.encode(instr, 0x5555_5555)
---    assert instr_len == 4
---except ValueError as ex:
---    print(f"Failed to encode the instruction: {ex}")
---    raise
---
---# We're done, take ownership of the buffer
---buffer = encoder.take_buffer()
---assert buffer == b"\x86\x64\x32\x16"
---```
function Encoder:new(bitness, capacity) end

---Encodes an instruction and returns the size of the encoded instruction
---
---Error if it failed to encode the instruction (eg. a target branch / RIP-rel operand is too far away)
---
---@param instruction Instruction #Instruction to encode
---@param rip integer #(`u64`) `RIP` of the encoded instruction
---@return integer #Size of the encoded instruction
---
---# Examples
---
---```lua
---from iced_x86 import *
---
---# je short $+4
---data = b"\x75\x02"
---decoder = Decoder(64, data, ip=0x1234_5678)
---instr = decoder.decode()
---
---encoder = Encoder(64)
---try:
---    # Use a different IP (orig rip + 0x10)
---    instr_len = encoder.encode(instr, 0x1234_5688)
---    assert instr_len == 2
---except ValueError as ex:
---    print(f"Failed to encode the instruction: {ex}")
---    raise
---
---# We're done, take ownership of the buffer
---buffer = encoder.take_buffer()
---assert buffer == b"\x75\xF2"
---```
function Encoder:encode(instruction, rip) end

---Writes a byte to the output buffer
---
---@param value integer #(`u8`) Value to write
---
---# Examples
---
---```lua
---from iced_x86 import *
---
---# je short $+4
---data = b"\x75\x02"
---decoder = Decoder(64, data, ip=0x1234_5678)
---instr = decoder.decode()
---
---encoder = Encoder(64)
---# Add a random byte
---encoder.write_u8(0x90)
---
---try:
---    # Use a different IP (orig rip + 0x10)
---    instr_len = encoder.encode(instr, 0x1234_5688)
---    assert instr_len == 2
---except ValueError as ex:
---    print(f"Failed to encode the instruction: {ex}")
---    raise
---
---# Add a random byte
---encoder.write_u8(0x90)
---
---# We're done, take ownership of the buffer
---buffer = encoder.take_buffer()
---assert buffer == b"\x90\x75\xF2\x90"
---```
function Encoder:write_u8(value) end

---Returns the buffer and initializes the internal buffer to an empty array.
---
---Should be called when you've encoded all instructions and need the raw instruction bytes.
---
---@return string #The encoded instructions
function Encoder:take_buffer() end

---Gets the offsets of the constants (memory displacement and immediate) in the encoded instruction.
---
---The caller can use this information to add relocations if needed.
---
---@return ConstantOffsets #Offsets and sizes of immediates
function Encoder:get_constant_offsets() end

---Disables 2-byte VEX encoding and encodes all VEX instructions with the 3-byte VEX encoding
---
---@return boolean
function Encoder:prevent_vex2() end

---Disables 2-byte VEX encoding and encodes all VEX instructions with the 3-byte VEX encoding
---
---@param new_value boolean #New value
function Encoder:set_prevent_vex2(new_value) end

---Value of the `VEX.W` bit to use if it's an instruction that ignores the bit. Default is 0.
---
---@return integer
function Encoder:vex_wig() end

---Value of the `VEX.W` bit to use if it's an instruction that ignores the bit. Default is 0.
---
---@param new_value integer #New value
function Encoder:set_vex_wig(new_value) end

---Value of the `VEX.L` bit to use if it's an instruction that ignores the bit. Default is 0.
---
---@return integer
function Encoder:vex_lig() end

---Value of the `VEX.L` bit to use if it's an instruction that ignores the bit. Default is 0.
---
---@param new_value integer #New value
function Encoder:set_vex_lig(new_value) end

---Value of the `EVEX.W` bit to use if it's an instruction that ignores the bit. Default is 0.
---
---@return integer
function Encoder:evex_wig() end

---Value of the `EVEX.W` bit to use if it's an instruction that ignores the bit. Default is 0.
---
---@param new_value integer #New value
function Encoder:set_evex_wig(new_value) end

---Value of the `EVEX.L'L` bits to use if it's an instruction that ignores the bits. Default is 0.
---
---@return integer
function Encoder:evex_lig() end

---Value of the `EVEX.L'L` bits to use if it's an instruction that ignores the bits. Default is 0.
---
---@param new_value integer #New value
function Encoder:set_evex_lig(new_value) end

---Value of the `MVEX.W` bit to use if it's an instruction that ignores the bit. Default is 0.
---
---@return integer
function Encoder:mvex_wig() end

---Value of the `MVEX.W` bit to use if it's an instruction that ignores the bit. Default is 0.
---
---@param new_value integer #New value
function Encoder:set_mvex_wig(new_value) end

---Gets the bitness (16, 32 or 64)
---
---@return integer
function Encoder:bitness() end

return Encoder
